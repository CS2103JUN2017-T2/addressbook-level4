# A0125586X
###### \java\seedu\multitasky\commons\events\ui\ListTypeUpdateEvent.java
``` java
/**
 * Indicates that the entries listed in the UI are now a different type (active/archived/deleted).
 */
public class ListTypeUpdateEvent extends BaseEvent {

    public final Entry.State state;

    public ListTypeUpdateEvent(Entry.State state) {
        this.state = state;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\multitasky\commons\events\ui\NewCommandEvent.java
``` java
/**
 * Indicates that there is a new command to put into the text box.
 */
public class NewCommandEvent extends BaseEvent {

    public final String command;

    public NewCommandEvent(String command) {
        this.command = command;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\multitasky\commons\events\ui\NewCommandToExecuteEvent.java
``` java
/**
 * Indicates that there is a new command to execute.
 */
public class NewCommandToExecuteEvent extends BaseEvent {

    public final String command;

    public NewCommandToExecuteEvent(String command) {
        this.command = command;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\multitasky\commons\util\PowerMatch.java
``` java
/**
 * Checks for matches using a variety of criteria between an input and a list of potential outputs.
 * Can be quite computationally intensive so is is best to call it with short inputs. Developer testing is
 * encouraged to confirm response time is reasonable for your application.
 */
public class PowerMatch {

    public static final int PERMUTATION_MATCH_MAX_ALLOWED_LENGTH = 8;
    public static final int MISSING_INNER_MATCH_MAX_ALLOWED_LENGTH = 8;
    public static final int WRONG_INNER_MATCH_MAX_ALLOWED_LENGTH = 6;

    public static final String REGEX_ANY_NON_WHITESPACE = "((\\S?)+)";
    public static final String REGEX_ANY_PRESENT_NON_WHITESPACE = "(\\S+)";
    public static final String REGEX_ANY_CHARACTER = "((.+)?)";

    /**
     * Attempts to find a match between the input and a single entry in {@code potentialMatches}.
     * Types of matches attempted are substring, prefix, acronym, permutation, missing inner characters,
     * wrong/extra inner characters.
     *
     * @param input            the input to attempt to find a match for
     * @param potentialMatches the list of potential matches for {@code input}
     * @return the match for {@code input}, if one is found. Otherwise {@code null} is returned.
     *         {@code null} is also returned if there is a null input string or {@code potentialMatches} is null.
     */
    public static String match(final String input, final String... potentialMatches) {
        if (input == null || potentialMatches == null || input.isEmpty() || potentialMatches.length == 0) {
            return null;
        }
        // Create copy to avoid modifying original input string
        String keyword = new String(input.trim().toLowerCase());
        String match = null;

        match = getSubstringMatch(keyword, potentialMatches);
        if (match != null) {
            return match;
        }

        match = getPrefixMatch(keyword, potentialMatches);
        if (match != null) {
            return match;
        }

        match = getAcronymMatch(keyword, potentialMatches);
        if (match != null) {
            return match;
        }

        if (input.length() <= PERMUTATION_MATCH_MAX_ALLOWED_LENGTH) {
            match = getPermutationMatch(keyword, potentialMatches);
            if (match != null) {
                return match;
            }
        }

        if (input.length() <= MISSING_INNER_MATCH_MAX_ALLOWED_LENGTH) {
            match = getMissingInnerMatch(keyword, potentialMatches);
            if (match != null) {
                return match;
            }
        }

        if (input.length() <= WRONG_INNER_MATCH_MAX_ALLOWED_LENGTH) {
            match = getWrongInnerMatch(keyword, potentialMatches);
            if (match != null) {
                return match;
            }
        }

        return null;
    }

    /**
     * Attempts to match the input with the potential match.
     * Types of matches attempted are substring, prefix, acronym, permutation, missing inner characters,
     * wrong/extra inner characters.
     *
     * @param input          the input to attempt to find a match for
     * @param potentialMatch the potential match {@code input}
     * @return if {@code input} can be matched to {@code potentialMatch} using the PowerMatch algorithm.
     */
    public static boolean isMatch(final String input, final String potentialMatch) {
        if (input == null || potentialMatch == null || potentialMatch.isEmpty()) {
            return false;
        } else if (input.isEmpty()) {
            return true;
        }
        // Create copy to avoid modifying original input string
        String keyword = new String(input.trim().toLowerCase());

        return getSubstringMatch(keyword, potentialMatch) != null
               || getPrefixMatch(keyword, potentialMatch) != null
               || getAcronymMatch(keyword, potentialMatch) != null
               || (input.length() < PERMUTATION_MATCH_MAX_ALLOWED_LENGTH
                    && getPermutationMatch(keyword, potentialMatch) != null)
               || (input.length() < MISSING_INNER_MATCH_MAX_ALLOWED_LENGTH
                    && getMissingInnerMatch(keyword, potentialMatch) != null)
               || (input.length() < WRONG_INNER_MATCH_MAX_ALLOWED_LENGTH
                    && getWrongInnerMatch(keyword, potentialMatch) != null);
    }


    private static String getRegexMatch(final String regex, final String... potentialMatches) {
        ArrayList<String> matches = new ArrayList<>();
        for (String potentialMatch : potentialMatches) {
            if (potentialMatch.matches(regex)) {
                matches.add(potentialMatch);
            }
        }
        return filterMatches(matches);
    }

    private static String getSubstringMatch(final String keyword, final String... potentialMatches) {
        final ArrayList<String> matches = new ArrayList<>();
        for (String potentialMatch : potentialMatches) {
            if (potentialMatch.contains(keyword)) {
                matches.add(potentialMatch);
            }
        }
        return filterMatches(matches);
    }

    private static String getPrefixMatch(final String keyword, final String... potentialMatches) {
        final ArrayList<String> matches = new ArrayList<>();
        for (String potentialMatch : potentialMatches) {
            if (potentialMatch.startsWith(keyword)) {
                matches.add(potentialMatch);
            }
        }
        return filterMatches(matches);
    }

    private static String getAcronymMatch(final String keyword, final String... potentialMatches) {
        String regex = getAcronymRegex(keyword);
        return getRegexMatch(regex, potentialMatches);
    }

    private static String getPermutationMatch(final String keyword,
                                              final String... potentialMatches) {
        final ArrayList<String> permutations = getPermutations(keyword);
        String match;
        for (String permutation : permutations) {
            match = getSubstringMatch(permutation, potentialMatches);
            if (match != null) {
                return match;
            }
            match = getPrefixMatch(permutation, potentialMatches);
            if (match != null) {
                return match;
            }
        }
        return null;
    }

    private static String getMissingInnerMatch(final String keyword,
                                               final String... potentialMatches) {
        final ArrayList<String> permutations = getMissingInnerPermutations(keyword);
        String match;
        for (String permutation : permutations) {
            // Use of regex instead of string literal comparison here
            match = getRegexMatch(permutation, potentialMatches);
            if (match != null) {
                return match;
            }
        }
        return null;
    }

    /**
     * Accounts for up to 3 wrong/extra characters
     */
    private static String getWrongInnerMatch(final String keyword,
                                             final String... potentialMatches) {
        final ArrayList<String> permutations = getWrongInnerPermutations(keyword);
        String match;
        for (String permutation : permutations) {
            // Use of regex instead of string literal comparison here
            match = getRegexMatch(permutation, potentialMatches);
            if (match != null) {
                return match;
            }
        }
        return null;
    }

    private static String getAcronymRegex(String keyword) {
        final ArrayList<String> chars = new ArrayList<>(Arrays.asList(keyword.split("")));
        final StringBuilder regex = new StringBuilder();
        // Alternate keyword characters and any non whitespace
        regex.append(REGEX_ANY_NON_WHITESPACE);
        for (String singleChar : chars) {
            regex.append(singleChar);
            regex.append(REGEX_ANY_NON_WHITESPACE);
        }
        return regex.toString();
    }

    private static ArrayList<String> getPermutations(final String keyword) {
        HashSet<String> permutations = new HashSet<>();
        ArrayList<String> chars = new ArrayList<>(Arrays.asList(keyword.split("")));
        generateUniquePermutations(chars, 0, keyword.length() - 1, permutations);
        return new ArrayList<String>(permutations);
    }

    private static ArrayList<String> getMissingInnerPermutations(final String keyword) {
        HashSet<String> permutations = new HashSet<>();
        ArrayList<String> chars = new ArrayList<>(Arrays.asList(keyword.split("")));
        // Add in a regex expression for any missing non-whitespace character
        chars.add(REGEX_ANY_PRESENT_NON_WHITESPACE);
        generateUniquePermutations(chars, 0, keyword.length(), permutations); // No -1 due to the extra regex
        // Add in regex expressions before and after to match any substring
        ArrayList<String> permutationsList = new ArrayList<>(permutations);
        for (int i = 0; i < permutationsList.size(); ++i) {
            String permutation = permutationsList.get(i);
            permutation = REGEX_ANY_CHARACTER + permutation + REGEX_ANY_CHARACTER;
            permutationsList.set(i, permutation);
        }
        return permutationsList;
    }

    private static ArrayList<String> getWrongInnerPermutations(final String keyword) {
        HashSet<String> permutations = new HashSet<>();
        ArrayList<String> chars = new ArrayList<>(Arrays.asList(keyword.split("")));
        /**
         * For single wrong/extra character:
         * Replace each character in turn with a regex expression
         * that can match any non-whitespace character or no character at all
         */
        if (chars.size() > 1) {
            for (int i = 0; i < chars.size(); ++i) {
                String temp = chars.get(i);
                chars.set(i, REGEX_ANY_NON_WHITESPACE);
                HashSet<String> tempPermutations = new HashSet<>();
                generateUniquePermutations(chars, 0, keyword.length() - 1, tempPermutations);
                for (String permutation : tempPermutations) {
                    permutations.add(permutation);
                }
                chars.set(i, temp);
            }
        }
        /**
         * For two wrong/extra characters:
         * Replace each two-character combination in turn with a regex expression
         * that can match any non-whitespace character or no character at all
         */
        if (chars.size() > 2) {
            for (int i = 0; i < chars.size(); ++i) {
                for (int j = i + 1; j < chars.size(); ++j) {
                    String iTemp = chars.get(i);
                    String jTemp = chars.get(j);
                    chars.set(i, REGEX_ANY_NON_WHITESPACE);
                    chars.set(j, REGEX_ANY_NON_WHITESPACE);
                    HashSet<String> tempPermutations = new HashSet<>();
                    generateUniquePermutations(chars, 0, keyword.length() - 1, tempPermutations);
                    for (String permutation : tempPermutations) {
                        permutations.add(permutation);
                    }
                    chars.set(i, iTemp);
                    chars.set(j, jTemp);
                }
            }
        }
        /**
         * For three wrong/extra characters:
         * Replace each three-character combination in turn with a regex expression
         * that can match any non-whitespace character or no character at all
         */
        if (chars.size() > 3) {
            for (int i = 0; i < chars.size(); ++i) {
                for (int j = i + 1; j < chars.size(); ++j) {
                    for (int k = j + 1; k < chars.size(); ++k) {
                        String iTemp = chars.get(i);
                        String jTemp = chars.get(j);
                        String kTemp = chars.get(k);
                        chars.set(i, REGEX_ANY_NON_WHITESPACE);
                        chars.set(j, REGEX_ANY_NON_WHITESPACE);
                        chars.set(k, REGEX_ANY_NON_WHITESPACE);
                        HashSet<String> tempPermutations = new HashSet<>();
                        generateUniquePermutations(chars, 0, keyword.length() - 1, tempPermutations);
                        for (String permutation : tempPermutations) {
                            permutations.add(permutation);
                        }
                        chars.set(i, iTemp);
                        chars.set(j, jTemp);
                        chars.set(k, kTemp);
                    }
                }
            }
        }
        /**
         * Stopping at three since it's a bit unreasonable to expect the user to enter four or more
         * wrong/extra characters in a single word
         */
        // Add in regex expressions before and after to match any substring
        ArrayList<String> permutationsList = new ArrayList<>(permutations);
        for (int i = 0; i < permutationsList.size(); ++i) {
            String permutation = permutationsList.get(i);
            permutation = REGEX_ANY_CHARACTER + permutation + REGEX_ANY_CHARACTER;
            permutationsList.set(i, permutation);
        }
        return permutationsList;
    }

    private static void generateUniquePermutations(ArrayList<String> chars, int i, int permutationLength,
                                                   HashSet<String> permutations) {
        // Filled up the permutation to the specified length
        if (i == permutationLength) {
            permutations.add(buildString(chars));
        } else {
            for (int j = i; j <= permutationLength; ++j) {
                Collections.swap(chars, i, j);
                generateUniquePermutations(chars, i + 1, permutationLength, permutations);
                Collections.swap(chars, i, j);
            }
        }
    }

    private static String buildString(final ArrayList<String> chars) {
        StringBuilder builder = new StringBuilder();
        for (String string : chars) {
            builder.append(string);
        }
        return builder.toString();
    }

    private static String filterMatches(ArrayList<String> matches) {
        // For now, the match is only accepted if there is only one match.
        if (matches.size() == 1) {
            return matches.get(0);
        }
        return null;
    }
}
```
###### \java\seedu\multitasky\logic\commands\ListCommand.java
``` java
/**
 * Lists all entries in the entry book to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Lists entries in the entry book. " + "\n"
                                               + "Format: " + COMMAND_WORD
                                               + " [" + "[" + CliSyntax.PREFIX_ARCHIVE + "]" + " |"
                                               + " [" + CliSyntax.PREFIX_BIN + "]" + "]"
                                               + " [" + CliSyntax.PREFIX_UPCOMING + "]"
                                               + " [" + CliSyntax.PREFIX_REVERSE + "]" + "\n"
                                               + "Example: " + COMMAND_WORD + " " + CliSyntax.PREFIX_UPCOMING;

    public static final String MESSAGE_ALL_SUCCESS = "Listed all entries";

    public static final String MESSAGE_ACTIVE_SUCCESS = "Listed all active entries";

    public static final String MESSAGE_ARCHIVE_SUCCESS = "Listed all entries in the archive";

    public static final String MESSAGE_BIN_SUCCESS = "Listed all entries in the bin";

    public static final String MESSAGE_DEFAULT_ORDER = "in default order";

    public static final String MESSAGE_REVERSE_ORDER = "in reverse order";

    public static final String MESSAGE_UPCOMING_ORDER = "in upcoming order";

    public static final String[] VALID_PREFIXES = { CliSyntax.PREFIX_ARCHIVE.toString(),
                                                    CliSyntax.PREFIX_BIN.toString(),
                                                    CliSyntax.PREFIX_ALL.toString(),
                                                    CliSyntax.PREFIX_UPCOMING.toString(),
                                                    CliSyntax.PREFIX_REVERSE.toString(),
                                                    CliSyntax.PREFIX_FROM.toString(),
                                                    CliSyntax.PREFIX_TO.toString() };

    public enum ShowType { ACTIVE, ARCHIVE, BIN, ALL }

    public enum Ordering { DEFAULT, REVERSE, UPCOMING }

    private static final HashSet<String> MATCH_ALL_KEYWORDS;

    private ShowType showType;
    private Ordering ordering;

    private Calendar startDate;
    private Calendar endDate;

    static {
        MATCH_ALL_KEYWORDS = new HashSet<>();
        MATCH_ALL_KEYWORDS.add("");
    }

    public ListCommand() {
        showType = ShowType.ACTIVE;
        ordering = Ordering.DEFAULT;
    }

    public ListCommand(Calendar startDate, Calendar endDate, ArrayList<String> prefixes) {
        this.startDate = startDate;
        this.endDate = endDate;

        if (prefixes.contains(CliSyntax.PREFIX_ARCHIVE.toString())) {
            showType = ShowType.ARCHIVE;
        } else if (prefixes.contains(CliSyntax.PREFIX_BIN.toString())) {
            showType = ShowType.BIN;
        } else if (prefixes.contains(CliSyntax.PREFIX_ALL.toString())) {
            showType = ShowType.ALL;
        } else {
            showType = ShowType.ACTIVE;
        }

        if (prefixes.contains(CliSyntax.PREFIX_REVERSE.toString())) {
            ordering = Ordering.REVERSE;
        } else if (prefixes.contains(CliSyntax.PREFIX_UPCOMING.toString())) {
            ordering = Ordering.UPCOMING;
        } else {
            ordering = Ordering.DEFAULT;
        }
    }

    @Override
    public CommandResult execute() {
        StringBuilder commandResultBuilder = new StringBuilder();

        switch (showType) {
        case ARCHIVE:
            commandResultBuilder.append(MESSAGE_ARCHIVE_SUCCESS);
            model.updateAllFilteredLists(MATCH_ALL_KEYWORDS, startDate, endDate, Entry.State.ARCHIVED);
            raise(new ListTypeUpdateEvent(Entry.State.ARCHIVED));
            history.setPrevSearch(MATCH_ALL_KEYWORDS, startDate, endDate, Entry.State.ARCHIVED);
            break;
        case BIN:
            commandResultBuilder.append(MESSAGE_BIN_SUCCESS);
            model.updateAllFilteredLists(MATCH_ALL_KEYWORDS, startDate, endDate, Entry.State.DELETED);
            raise(new ListTypeUpdateEvent(Entry.State.DELETED));
            history.setPrevSearch(MATCH_ALL_KEYWORDS, startDate, endDate, Entry.State.DELETED);
            break;
        case ACTIVE:
            commandResultBuilder.append(MESSAGE_ACTIVE_SUCCESS);
            model.updateAllFilteredLists(MATCH_ALL_KEYWORDS, startDate, endDate, Entry.State.ACTIVE);
            raise(new ListTypeUpdateEvent(Entry.State.ACTIVE));
            history.setPrevSearch(MATCH_ALL_KEYWORDS, startDate, endDate, Entry.State.ACTIVE);
            break;
        case ALL:
            commandResultBuilder.append(MESSAGE_ALL_SUCCESS);
            model.updateAllFilteredLists(MATCH_ALL_KEYWORDS, startDate, endDate, null);
            raise(new ListTypeUpdateEvent(null));
            history.setPrevSearch(MATCH_ALL_KEYWORDS, startDate, endDate, null);
            break;
        default:
            throw new AssertionError("Unknown list show type");
        }

        switch (ordering) {
        case REVERSE:
            model.updateSortingComparators(Comparators.EVENT_REVERSE, Comparators.DEADLINE_REVERSE,
                    Comparators.FLOATING_TASK_REVERSE);
            commandResultBuilder.append(" ").append(MESSAGE_REVERSE_ORDER);
            return new CommandResult(commandResultBuilder.toString());
        case UPCOMING:
            model.updateSortingComparators(Comparators.EVENT_UPCOMING, Comparators.DEADLINE_UPCOMING,
                    Comparators.FLOATING_TASK_UPCOMING);
            commandResultBuilder.append(" ").append(MESSAGE_UPCOMING_ORDER);
            return new CommandResult(commandResultBuilder.toString());
        case DEFAULT:
            model.updateSortingComparators(Comparators.EVENT_DEFAULT, Comparators.DEADLINE_DEFAULT,
                    Comparators.FLOATING_TASK_DEFAULT);
            return new CommandResult(commandResultBuilder.toString());
        default:
            throw new AssertionError("Unknown list command ordering type");
        }
    }

    private void raise(BaseEvent event) {
        EventsCenter.getInstance().post(event);
    }

    @Override
    public void setData(Model model, CommandHistory history) {
        requireNonNull(model);
        requireNonNull(history);
        this.model = model;
        this.history = history;
    }

}
```
###### \java\seedu\multitasky\logic\parser\ArgumentMultimap.java
``` java
    /**
     * Method to extract an ArrayList of specified prefixes that are present in the ArgumentMultimap
     */
    public ArrayList<String> getPresentPrefixes(String... prefixes) {
        ArrayList<String> presentPrefixes = new ArrayList<>();
        for (String prefix : prefixes) {
            if (getAllValues(new Prefix(prefix)).size() != 0) {
                presentPrefixes.add(prefix);
            }
        }
        return presentPrefixes;
    }

}
```
###### \java\seedu\multitasky\logic\parser\ListCommandParser.java
``` java
/**
 * Parses input arguments and creates a new ListCommand object
 */
public class ListCommandParser {

    /** Parses the given arguments in the context of a list command.
     *
     * @param args the arguments for the list command in a single String
     * @return     the ListCommand object for execution
     * @throws ParseException if the user input does not confirm to the expected format
     */
    public ListCommand parse(String args) throws ParseException {
        String trimmedArgs = args.trim();

        if (trimmedArgs.isEmpty()) {
            return new ListCommand();
        }
        // Preamble is necessary due to how ArgumentTokenizer works
        // TODO modify ArgumentTokenizer to be able to detect without preamble
        ArgumentMultimap argumentMultimap = ArgumentTokenizer.tokenize("preamble " + trimmedArgs,
                                                                       toPrefixArray(ListCommand.VALID_PREFIXES));
        ArrayList<String> prefixesPresent = argumentMultimap.getPresentPrefixes(ListCommand.VALID_PREFIXES);
        if (!hasValidPrefixCombination(prefixesPresent)) {
            throw new ParseException(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT,
                                                   ListCommand.MESSAGE_USAGE));
        }
        Calendar startDate = getStartDate(argumentMultimap);
        Calendar endDate = getEndDate(argumentMultimap);

        return new ListCommand(startDate, endDate, prefixesPresent);
    }

    private Calendar getStartDate(ArgumentMultimap argumentMultimap) {
        ArrayList<String> dateArgs = (ArrayList<String>) argumentMultimap.getAllValues(CliSyntax.PREFIX_FROM);
        return getDate(getString(dateArgs).trim());
    }

    private Calendar getEndDate(ArgumentMultimap argumentMultimap) {
        ArrayList<String> dateArgs = (ArrayList<String>) argumentMultimap.getAllValues(CliSyntax.PREFIX_TO);
        return getDate(getString(dateArgs).trim());
    }

    private Calendar getDate(String rawDate) {
        if (rawDate.isEmpty()) {
            return null;
        }
        try {
            Calendar date = ParserUtil.parseDate(rawDate);
            return date;
        } catch (ParseException e) {
            return null;
        }
    }

    private boolean hasValidPrefixCombination(ArrayList<String> prefixes) {
        // Cannot have any unknown prefixes
        if (!Arrays.asList(ListCommand.VALID_PREFIXES).containsAll(prefixes)) {
            return false;
        }
        // Check for invalid flag combinations
        if (prefixes.contains(CliSyntax.PREFIX_ARCHIVE.toString())
            && prefixes.contains(CliSyntax.PREFIX_BIN.toString())) {
            return false;
        } else if (prefixes.contains(CliSyntax.PREFIX_UPCOMING.toString())
                   && prefixes.contains(CliSyntax.PREFIX_REVERSE.toString())) {
            return false;
        }
        return true;
    }

    private Prefix[] toPrefixArray(String... stringPrefixes) {
        Prefix[] prefixes = new Prefix[stringPrefixes.length];
        for (int i = 0; i < stringPrefixes.length; ++i) {
            prefixes[i] = new Prefix(stringPrefixes[i]);
        }
        return prefixes;
    }

    private String getString(ArrayList<String> parts) {
        StringBuilder builder = new StringBuilder();
        for (String part : parts) {
            builder.append(part);
        }
        return builder.toString();
    }

}
```
###### \java\seedu\multitasky\logic\parser\ParserUtil.java
``` java
    /**
     * converts a String array of prefixes into a Prefix array
     */
    public static Prefix[] toPrefixArray(String... stringPrefixes) {
        Prefix[] prefixes = new Prefix[stringPrefixes.length];
        for (int i = 0; i < stringPrefixes.length; ++i) {
            prefixes[i] = new Prefix(stringPrefixes[i]);
        }
        return prefixes;
    }

}
```
###### \java\seedu\multitasky\model\entry\DeadlineList.java
``` java
    public DeadlineList() {
        super();
        comparator = Comparators.DEADLINE_DEFAULT;
    }
```
###### \java\seedu\multitasky\model\entry\DeadlineList.java
``` java
    /**
     * Overrides updateEntry in DeadlineList to sort after updating in case start date was changed.
     *
     * @throws EntryNotFoundException if {@code target} could not be found in the list.
     * @throws DuplicateEntryException if {@code editedEntry} already exists in the list.
     */
    @Override
    public void updateEntry(ReadOnlyEntry target, ReadOnlyEntry editedEntry)
            throws DuplicateEntryException, EntryNotFoundException {
        super.updateEntry(target, editedEntry);
        sortInternalList();
    }

```
###### \java\seedu\multitasky\model\entry\EntryList.java
``` java
    /**
     * Sorts the internal list using the comparator stored inside the class
     */
    protected void sortInternalList() {
        Collections.sort(internalList, comparator);
    }

    /**
     * Sets the comparator for this list, and sorts it using the comparator.
     */
    public void setComparator(Comparator<ReadOnlyEntry> comparator) {
        this.comparator = comparator;
        sortInternalList();
    }
```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
    public EventList() {
        super();
        comparator = Comparators.EVENT_DEFAULT;
    }
```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
    /**
     * Updates an existing entry with the data of a given Entry.
     * The list is sorted after updating in case start date was changed.
     *
     * @throws EntryNotFoundException if {@code target} could not be found in the list.
     * @throws DuplicateEntryException if {@code editedEntry} already exists in the list.
     */
    @Override
    public void updateEntry(ReadOnlyEntry target, ReadOnlyEntry editedEntry)
            throws DuplicateEntryException, EntryNotFoundException {
        super.updateEntry(target, editedEntry);
        sortInternalList();
    }
```
###### \java\seedu\multitasky\model\entry\FloatingTaskList.java
``` java
    public FloatingTaskList() {
        super();
        comparator = Comparators.FLOATING_TASK_DEFAULT;
    }
```
###### \java\seedu\multitasky\model\entry\util\Comparators.java
``` java
/**
 * Utility class of different comparators to use when comparing two entries
 */
public class Comparators {

    /**
     * Default ordering in general is to have no change
     */
    public static final Comparator<ReadOnlyEntry> ENTRY_DEFAULT = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            return 0;
        }
    };

    /**
     * Default ordering for events is by starting date and time, earliest first
     */
    public static final Comparator<ReadOnlyEntry> EVENT_DEFAULT = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            assert entry1 instanceof Event : "Event comparator must receive Event"
                                             + "object as argument";
            assert entry2 instanceof Event : "Event comparator must receive Event"
                                             + "object as argument";
            // Order by increasing starting date and time
            return entry1.getStartDateAndTime().compareTo(entry2.getStartDateAndTime());
        }
    };

    /**
     * Default ordering for deadlines is by ending date and time, earliest first
     */
    public static final Comparator<ReadOnlyEntry> DEADLINE_DEFAULT = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            assert entry1 instanceof Deadline : "Deadline comparator must receive Deadline"
                                                + "object as argument";
            assert entry2 instanceof Deadline : "Event comparator must receive Deadline"
                                                + "object as argument";
            // Order by increasing ending(deadline) date and time
            return entry1.getEndDateAndTime().compareTo(entry2.getEndDateAndTime());
        }
    };

    /**
     * Default ordering for floating tasks is the order in which they were added, earliest first
     */
    public static final Comparator<ReadOnlyEntry> FLOATING_TASK_DEFAULT = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            assert entry1 instanceof FloatingTask : "FloatingTask comparator must receive FloatingTask"
                                                    + "object as argument";
            assert entry2 instanceof FloatingTask : "FloatingTask comparator must receive FloatingTask"
                                                    + "object as argument";
            // No re-ordering of floating tasks
            return 0;
        }
    };

    /**
     * Reverse ordering for events is by starting date and time, latest first
     */
    public static final Comparator<ReadOnlyEntry> EVENT_REVERSE = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            assert entry1 instanceof Event : "Event comparator must receive Event"
                                             + "object as argument";
            assert entry2 instanceof Event : "Event comparator must receive Event"
                                             + "object as argument";
            // Order by increasing starting date and time
            return entry2.getStartDateAndTime().compareTo(entry1.getStartDateAndTime());
        }
    };

    /**
     * Default ordering for deadlines is by ending date and time, latest first
     */
    public static final Comparator<ReadOnlyEntry> DEADLINE_REVERSE = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            assert entry1 instanceof Deadline : "Deadline comparator must receive Deadline"
                                                + "object as argument";
            assert entry2 instanceof Deadline : "Event comparator must receive Deadline"
                                                + "object as argument";
            // Order by increasing ending(deadline) date and time
            return entry2.getEndDateAndTime().compareTo(entry1.getEndDateAndTime());
        }
    };

    /**
     * Default ordering for floating tasks is the order in which they were added, earliest first
     */
    public static final Comparator<ReadOnlyEntry> FLOATING_TASK_REVERSE = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            assert entry1 instanceof FloatingTask : "FloatingTask comparator must receive FloatingTask"
                                                    + "object as argument";
            assert entry2 instanceof FloatingTask : "FloatingTask comparator must receive FloatingTask"
                                                    + "object as argument";
            // No re-ordering of floating tasks
            return 0;
        }
    };

    /**
     * Upcoming ordering for events is to show events that are not over yet first,
     * followed by events that are over.
     */
    public static final Comparator<ReadOnlyEntry> EVENT_UPCOMING = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            assert entry1 instanceof Event : "Event comparator must receive Event"
                                             + "object as argument";
            assert entry2 instanceof Event : "Event comparator must receive Event"
                                             + "object as argument";
            Calendar currentTime = new GregorianCalendar();
            currentTime.setTime(new Date());
            if (entry1.getStartDateAndTime().before(currentTime)) {
                if (entry2.getStartDateAndTime().before(currentTime)) {
                    // Both events are in the past, perform normal sort relative to each other
                    return entry1.getStartDateAndTime().compareTo(entry2.getStartDateAndTime());
                } else {
                    // wrong order: entry1 should be after entry2 since it is in the past and entry2 is not
                    return 1;
                }
            } else if (entry2.getStartDateAndTime().before(currentTime)) {
                // correct order: entry2 should be after entry1 since it is in the past and entry1 is not
                return -1;
            } else {
                // Both events are upcoming, perform normal sort relative to each other
                return entry1.getStartDateAndTime().compareTo(entry2.getStartDateAndTime());
            }
        }
    };

    /**
     * Upcoming ordering for deadlines is to show deadlines that are not over yet first,
     * followed by deadlines that are over.
     */
    public static final Comparator<ReadOnlyEntry> DEADLINE_UPCOMING = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            assert entry1 instanceof Deadline : "Deadline comparator must receive Deadline"
                                                + "object as argument";
            assert entry2 instanceof Deadline : "Deadline comparator must receive Deadline"
                                                + "object as argument";
            Calendar currentTime = new GregorianCalendar();
            currentTime.setTime(new Date());
            if (entry1.getEndDateAndTime().before(currentTime)) {
                if (entry2.getEndDateAndTime().before(currentTime)) {
                    // Both deadlines are in the past, perform normal sort relative to each other
                    return entry1.getEndDateAndTime().compareTo(entry2.getEndDateAndTime());
                } else {
                    // wrong order: entry1 should be after entry2 since it is in the past and entry2 is not
                    return 1;
                }
            } else if (entry2.getEndDateAndTime().before(currentTime)) {
                // correct order: entry2 should be after entry1 since it is in the past and entry1 is not
                return -1;
            } else {
                // Both deadlines are upcoming, perform normal sort relative to each other
                return entry1.getEndDateAndTime().compareTo(entry2.getEndDateAndTime());
            }
        }
    };

    /**
     * Upcoming ordering for floating tasks is the order in which they were added
     */
    public static final Comparator<ReadOnlyEntry> FLOATING_TASK_UPCOMING = FLOATING_TASK_DEFAULT;
}
```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
    public void setComparators(Comparator<ReadOnlyEntry> eventComparator,
                               Comparator<ReadOnlyEntry> deadlineComparator,
                               Comparator<ReadOnlyEntry> floatingTaskComparator) {
        _eventList.setComparator(eventComparator);
        _deadlineList.setComparator(deadlineComparator);
        _floatingTaskList.setComparator(floatingTaskComparator);
    }
```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void updateAllFilteredLists(Set<String> keywords, Calendar startDate, Calendar endDate,
                                       Entry.State state) {
        // Attempt until at least one result shown
        for (Search search : Search.values()) {
            updateFilteredEventList(new PredicateExpression(new NameDateStateQualifier(keywords,
                                                                                       startDate, endDate,
                                                                                       state, search)));
            updateFilteredDeadlineList(new PredicateExpression(new NameDateStateQualifier(keywords,
                                                                                          startDate, endDate,
                                                                                          state, search)));
            updateFilteredFloatingTaskList(new PredicateExpression(new NameDateStateQualifier(keywords,
                                                                                              startDate,
                                                                                              endDate, state,
                                                                                              search)));
            if ((getFilteredEventList().size() + getFilteredDeadlineList().size()
                 + getFilteredFloatingTaskList().size()) > 0) {
                break; // No need to search further
            }
        }
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void updateFilteredEventList(Set<String> keywords, Calendar startDate, Calendar endDate,
                                        Entry.State state, Search search) {
        updateFilteredEventList(new PredicateExpression(new NameDateStateQualifier(keywords,
                                                                                   startDate, endDate, state,
                                                                                   search)));
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void updateFilteredDeadlineList(Set<String> keywords, Calendar startDate,
                                           Calendar endDate, Entry.State state, Search search) {
        updateFilteredDeadlineList(new PredicateExpression(new NameDateStateQualifier(keywords,
                                                                                      startDate, endDate,
                                                                                      state, search)));
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void updateFilteredFloatingTaskList(Set<String> keywords, Calendar startDate,
                                               Calendar endDate, Entry.State state, Search search) {
        updateFilteredFloatingTaskList(new PredicateExpression(new NameDateStateQualifier(keywords,
                                                                                          startDate, endDate,
                                                                                          state, search)));
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    /** Updates the sorting comparators used. */
    @Override
    public void updateSortingComparators(Comparator<ReadOnlyEntry> eventComparator,
                                         Comparator<ReadOnlyEntry> deadlineComparator,
                                         Comparator<ReadOnlyEntry> floatingTaskComparator) {
        _entryBook.setComparators(eventComparator, deadlineComparator, floatingTaskComparator);
    }
```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    /**
     * Represents a qualifier can check the presence of all keywords in the name
     * and tags of a ReadOnlyEntry, if a ReadOnlyEntry falls within a given date range,
     * and if a ReadOnlyEntry matches the required state.
     */
    private class NameDateStateQualifier implements Qualifier {

        protected Set<String> nameAndTagKeywords;
        protected Calendar startDate;
        protected Calendar endDate;
        protected Entry.State state;
        protected Search search;

        protected DateFormat dateFormat;

        /**
         * Constructs the NameDateStateQualifier.
         *
         * @param nameAndTagKeywords the keywords to match against the entry's name and tags. cannot be null.
         * @param startDate the earliest date that will produce a match. if it is null then
         *            there is no lower limit on the entry's date.
         * @param endDate the latest date that will produce a match. if it is null then
         *            there is no upper limit on the entry's date.
         * @param state the required state to match against the entry's state. if it is null
         *            then entries of any state will match.
         * @param search the type of search to use (AND, OR, POWER_AND, POWER_OR). cannot be null.
         */
        NameDateStateQualifier(Set<String> nameAndTagKeywords,
                Calendar startDate, Calendar endDate,
                Entry.State state, Search search) {
            assert nameAndTagKeywords != null : "nameAndTagKeywords for NameDateStateQualifier cannot be null";
            assert search != null : "search type for NameDateStateQualifier cannot be null";

            this.nameAndTagKeywords = nameAndTagKeywords;
            this.startDate = startDate;
            this.endDate = endDate;
            this.state = state;
            this.search = search;

            dateFormat = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT);
        }

        @Override
        public boolean run(ReadOnlyEntry entry) {
            if ((state == null || entry.getState().equals(state))
                && matchesNameAndTagKeywords(entry)) {
                if (entry instanceof FloatingTask
                    || entry instanceof Deadline && isWithinRange(entry.getEndDateAndTime())
                    || entry instanceof Event && isWithinRange(entry.getStartDateAndTime())) {
                    return true;
                } else {
                    assert false : "DateAndStatusQualifier::run received ReadOnlyEntry of unknown type";
                }
            }
            return false;
        }

        protected boolean matchesNameAndTagKeywords(ReadOnlyEntry entry) {
            String nameAndTags = parseWordsInNameAndTags(entry).trim().toLowerCase();
            switch (search) {
            case AND:
                for (String keyword : nameAndTagKeywords) {
                    if (!nameAndTags.contains(keyword.trim().toLowerCase())) {
                        return false;
                    }
                }
                return true;
            case OR:
                if (nameAndTagKeywords.size() == 0) {
                    return true;
                }
                for (String keyword : nameAndTagKeywords) {
                    if (nameAndTags.contains(keyword.trim().toLowerCase())) {
                        return true;
                    }
                }
                return false;
            case POWER_AND:
                for (String keyword : nameAndTagKeywords) {
                    if (!PowerMatch.isMatch(keyword, nameAndTags)) {
                        return false;
                    }
                }
                return true;
            case POWER_OR:
                if (nameAndTagKeywords.size() == 0) {
                    return true;
                }
                for (String keyword : nameAndTagKeywords) {
                    if (PowerMatch.isMatch(keyword, nameAndTags)) {
                        return true;
                    }
                }
                return false;
            default:
                assert false : "DateAndStatusQualifier: unknown search type";
            }
            return false;
        }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
        /**
         * Checks if the given date to check is within the start and end dates of this Qualifier.
         */
        protected boolean isWithinRange(Calendar checkDate) {
            if (startDate == null) {
                if (endDate == null) {
                    return true;
                } else {
                    return checkDate.compareTo(endDate) <= 0;
                }
            } else if (endDate == null) {
                return checkDate.compareTo(startDate) >= 0;
            } else {
                return (checkDate.compareTo(startDate) <= 0) && (checkDate.compareTo(endDate) >= 0);
            }
        }
```
###### \java\seedu\multitasky\model\util\EntryBuilder.java
``` java
/**
 * A utility class containing methods to construct Event, Deadline or FloatingTask objects.
 */
public class EntryBuilder {

    public static final String DEFAULT_NAME = "defaultName";
    public static final String DEFAULT_TAGS = "defaultTag";

    /**
     * Builds an entry with the class-level default parameters
     */
    public static Entry build() {
        Entry entry;
        try {
            entry = build(DEFAULT_NAME, DEFAULT_TAGS);
            return entry;
        } catch (IllegalValueException e) {
            throw new AssertionError("Sample data cannot be invalid");
        }
    }

    /******************
     * Multi-builders *
     *****************/
    /**
     * Builds the appropriate Event, Deadline or FloatingTask object as a copy of {@code entryToCopy}.
     * @param entryToCopy the entry that data will be read from to create the new object
     * @return            a copy of {@code entryToCopy}
     */
    public static Entry build(final ReadOnlyEntry entryToCopy) {
        Objects.requireNonNull(entryToCopy);
        Entry entry;
        if (entryToCopy instanceof Event) {
            entry = new Event(entryToCopy);
        } else if (entryToCopy instanceof Deadline) {
            entry = new Deadline(entryToCopy);
        } else if (entryToCopy instanceof FloatingTask) {
            entry = new FloatingTask(entryToCopy);
        } else {
            entry = null;
            throw new AssertionError("entryToCopy must be Event, Deadline or FloatingTask");
        }
        return entry;
    }

    /******************
     * Event builders *
     *****************/
    /**
     * Builds an Event object from the provided arguments.
     * @param name             the name of the event
     * @param startDateAndTime the starting date and time of the event
     * @param endDateAndTime   the ending date and time of the event
     * @param tags             the tags associated with the event
     * @return                 the constructed Event object - returns a Deadline or FloatingTask object if
     *                         there are null Calendar parameters
     * @throws IllegalValueException if any of the arguments are invalid or if there is the combination of
     *                               non-null start date and null end date.
     */
    public static Entry build(String name, Calendar startDateAndTime, Calendar endDateAndTime, String... tags)
            throws IllegalValueException {
        return build(new Name(name), startDateAndTime, endDateAndTime, TagSetBuilder.getTagSet(tags));
    }

    /**
     * Builds an Event object from the provided arguments.
     * @param name             the name of the event
     * @param startDateAndTime the starting date and time of the event
     * @param endDateAndTime   the ending date and time of the event
     * @param tags             the tags associated with the event
     * @return                 the constructed Event object - returns a Deadline or FloatingTask object if
     *                         there are null Calendar parameters
     * @throws IllegalValueException if any of the arguments are invalid or if there is the combination of
     *                               non-null start date and null end date.
     */
    public static Entry build(String name, Calendar startDateAndTime, Calendar endDateAndTime, Set<Tag> tags)
            throws IllegalValueException {
        return build(new Name(name), startDateAndTime, endDateAndTime, tags);
    }

    /**
     * Builds an Event object from the provided arguments.
     * @param name             the name of the event
     * @param startDateAndTime the starting date and time of the event
     * @param endDateAndTime   the ending date and time of the event
     * @param tags             the tags associated with the event
     * @return                 the constructed Event object - returns a Deadline or FloatingTask object if
     *                         there are null Calendar parameters
     * @throws IllegalValueException if any of the arguments are invalid or if there is the combination of
     *                               non-null start date and null end date.
     */
    public static Entry build(Name name, Calendar startDateAndTime, Calendar endDateAndTime, String... tags)
            throws IllegalValueException {
        return build(name, startDateAndTime, endDateAndTime, TagSetBuilder.getTagSet(tags));
    }

    /**
     * Builds an Event object from the provided arguments.
     * @param name             the name of the event
     * @param startDateAndTime the starting date and time of the event
     * @param endDateAndTime   the ending date and time of the event
     * @param tags             the tags associated with the event
     * @return                 the constructed Event object - returns a Deadline or FloatingTask object if
     *                         there are null Calendar parameters
     * @throws IllegalValueException if any of the arguments are invalid or if there is the combination of
     *                               non-null start date and null end date.
     */
    public static Entry build(Name name, Calendar startDateAndTime, Calendar endDateAndTime, Set<Tag> tags)
            throws IllegalValueException {
        if (startDateAndTime == null) {
            if (endDateAndTime == null) {
                Entry entry = build(name, tags);
                return entry;
            } else {
                Entry entry = build(name, endDateAndTime, tags);
                return entry;
            }
        } else if (endDateAndTime != null) {
            Entry entry = new Event(name, startDateAndTime, endDateAndTime, tags);
            return entry;
        } else {
            throw new IllegalValueException("Wrong combination of non-null start date and null end date");
        }
    }

    /*********************
     * Deadline builders *
     ********************/
    /**
     * Builds a Deadline object from the provided arguments.
     * @param name             the name of the deadline
     * @param endDateAndTime   the date and time of the deadline
     * @param tags             the tags associated with the deadline
     * @return                 the constructed Deadline object - returns a FloatingTask object if
     *                         {@code endDateAndTime} is null
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(String name, Calendar endDateAndTime, String... tags)
            throws IllegalValueException {
        return build(new Name(name), endDateAndTime, TagSetBuilder.getTagSet(tags));
    }

    /**
     * Builds a Deadline object from the provided arguments.
     * @param name             the name of the deadline
     * @param endDateAndTime   the date and time of the deadline
     * @param tags             the tags associated with the deadline
     * @return                 the constructed Deadline object - returns a FloatingTask object if
     *                         {@code endDateAndTime} is null
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(String name, Calendar endDateAndTime, Set<Tag> tags)
            throws IllegalValueException {
        return build(new Name(name), endDateAndTime, tags);
    }

    /**
     * Builds a Deadline object from the provided arguments.
     * @param name             the name of the deadline
     * @param endDateAndTime   the date and time of the deadline
     * @param tags             the tags associated with the deadline
     * @return                 the constructed Deadline object - returns a FloatingTask object if
     *                         {@code endDateAndTime} is null
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(Name name, Calendar endDateAndTime, String... tags)
            throws IllegalValueException {
        return build(name, endDateAndTime, TagSetBuilder.getTagSet(tags));
    }

    /**
     * Builds a Deadline object from the provided arguments.
     * @param name             the name of the deadline
     * @param endDateAndTime   the date and time of the deadline
     * @param tags             the tags associated with the deadline
     * @return                 the constructed Deadline object - returns a FloatingTask object if
     *                         {@code endDateAndTime} is null
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(Name name, Calendar endDateAndTime, Set<Tag> tags)
            throws IllegalValueException {
        if (endDateAndTime == null) {
            return build(name, tags);
        } else {
            return new Deadline(name, endDateAndTime, tags);
        }
    }

    /*************************
     * FloatingTask builders *
     ************************/
    /**
     * Builds a FloatingTask object from the provided arguments.
     * @param name             the name of the floating task
     * @return                 the constructed FloatingTask object
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(String name) throws IllegalValueException {
        return build(new Name(name), TagSetBuilder.getTagSet());
    }

    /**
     * Builds a FloatingTask object from the provided arguments.
     * @param name             the name of the floating task
     * @return                 the constructed FloatingTask object
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(Name name) throws IllegalValueException {
        return build(name, TagSetBuilder.getTagSet());
    }

    /**
     * Builds a FloatingTask object from the provided arguments.
     * @param name             the name of the floating task
     * @param tags             the tags associated with the floating task
     * @return                 the constructed FloatingTask object
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(String name, String... tags) throws IllegalValueException {
        return build(new Name(name), TagSetBuilder.getTagSet(tags));
    }

    /**
     * Builds a FloatingTask object from the provided arguments.
     * @param name             the name of the floating task
     * @param tags             the tags associated with the floating task
     * @return                 the constructed FloatingTask object
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(String name, Set<Tag> tags) throws IllegalValueException {
        return build(new Name(name), tags);
    }

    /**
     * Builds a FloatingTask object from the provided arguments.
     * @param name             the name of the floating task
     * @param tags             the tags associated with the floating task
     * @return                 the constructed FloatingTask object
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(Name name, String... tags) throws IllegalValueException {
        return build(name, TagSetBuilder.getTagSet(tags));
    }

    /**
     * Builds a FloatingTask object from the provided arguments.
     * @param name             the name of the floating task
     * @param tags             the tags associated with the floating task
     * @return                 the constructed FloatingTask object
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(Name name, Set<Tag> tags) throws IllegalValueException {
        return new FloatingTask(name, tags);
    }
}
```
###### \java\seedu\multitasky\ui\CommandBox.java
``` java
/**
 * Handles text input from the user into the command box.
 * Keeps a history of previous commands entered by the user to provide
 * Linux-style command history navigation.
 */
public class CommandBox extends UiPart<Region> {

    public static final String ERROR_STYLE_CLASS = "error";
    private static final String FXML = "CommandBox.fxml";

    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private final Logic logic;

    private CommandAutocomplete commandAutocomplete;
    private CommandHistory commandHistory;

    @FXML
    private TextField commandTextField;

    public CommandBox(Logic logic) {
        super(FXML);
        this.logic = logic;
        commandHistory = new CommandHistory(getRoot(), commandTextField);
        commandAutocomplete = new CommandAutocomplete(getRoot(), commandTextField);
        setCommandTextFieldFocus();
        onlyShowActiveEntries();
        registerAsAnEventHandler(this);
    }

    /**
     * Requests focus on the command text field once the main UI window is open,
     * so that the user can immediately begin typing.
     */
    private void setCommandTextFieldFocus() {
        Platform.runLater(new Runnable() {
            public void run() {
                commandTextField.requestFocus();
            }
        });
    }

    @FXML
    private void handleCommandInputChanged() throws DuplicateEntryException {
        commandHistory.saveCommand();
        executeLogic(commandTextField.getText().trim());
        commandTextField.setText("");
    }

    /**
     * Calls the logic component to execute the command given by the string.
     */
    private void executeLogic(String command) {
        try {
            CommandResult commandResult = logic.execute(command);
            // process result of the command
            setStyleToIndicateCommandSuccess();
            logger.info("Result: " + commandResult.feedbackToUser);
            raise(new NewResultAvailableEvent(commandResult.feedbackToUser));

        } catch (CommandException | ParseException e) {
            // handle command failure
            setStyleToIndicateCommandFailure();
            logger.info("Invalid command: " + command);
            raise(new NewResultAvailableEvent(e.getMessage()));
        } catch (DuplicateEntryException e) {
            setStyleToIndicateCommandFailure();
            logger.info("Unable to add duplicate entry with command: " + command);
            raise(new NewResultAvailableEvent(e.getMessage()));
        }
    }

    /**
     * Sets the command box style to indicate a successful command.
     */
    private void setStyleToIndicateCommandSuccess() {
        commandTextField.getStyleClass().remove(ERROR_STYLE_CLASS);
    }

    /**
     * Sets the command box style to indicate a failed command.
     */
    private void setStyleToIndicateCommandFailure() {
        ObservableList<String> styleClass = commandTextField.getStyleClass();

        if (styleClass.contains(ERROR_STYLE_CLASS)) {
            return;
        }

        styleClass.add(ERROR_STYLE_CLASS);
    }

    private void onlyShowActiveEntries() {
        try {
            logic.execute(ListCommand.COMMAND_WORD);
        } catch (Exception e) {
            assert false : "Initial list of active entries cannot throw exceptions";
        }
    }

    @Subscribe
    private void handleNewCommandEvent(NewCommandEvent event) {
        commandTextField.setText(event.command);
        commandTextField.positionCaret(commandTextField.getText().length());
    }

    @Subscribe
    private void handleNewCommandToExecuteEvent(NewCommandToExecuteEvent event) {
        executeLogic(event.command);
    }

}
```
###### \java\seedu\multitasky\ui\DeadlineListPanel.java
``` java
/**
 * Panel containing the list of deadlines.
 */
public class DeadlineListPanel extends UiPart<Region> {
    private static final String FXML = "DeadlineListPanel.fxml";

    @FXML
    private ListView<ReadOnlyEntry> deadlineListView;

    public DeadlineListPanel(ObservableList<ReadOnlyEntry> deadlineList) {
        super(FXML);
        setConnections(deadlineList);
    }

    private void setConnections(ObservableList<ReadOnlyEntry> deadlineList) {
        deadlineListView.setItems(deadlineList);
        deadlineListView.setCellFactory(listView -> new DeadlineListViewCell());
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            deadlineListView.scrollTo(index);
            deadlineListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class DeadlineListViewCell extends ListCell<ReadOnlyEntry> {

        @Override
        protected void updateItem(ReadOnlyEntry entry, boolean empty) {
            super.updateItem(entry, empty);

            if (empty || entry == null) {
                setGraphic(null);
                setText(null);
            } else {
                int index = getIndex() + 1;
                assert index > 0 : "getIndex returned invalid index";

                Calendar current = new GregorianCalendar();
                // Deadline is over
                if (current.compareTo(entry.getEndDateAndTime()) > 0) {
                    setGraphic(new DeadlineOverdueCard(entry, index).getRoot());
                } else {
                    setGraphic(new DeadlineCard(entry, index).getRoot());
                }
            }
        }
    }

}
```
###### \java\seedu\multitasky\ui\EntryCard.java
``` java
/**
 * EntryCard implements a superclass for the different types of entry cards to inherit from.
 * This class is declared as abstract as the classes for each type of entry card
 * should be instantiated instead of a generic entry card.
 */
public abstract class EntryCard extends UiPart<Region> {

    private static final String FXML = "EntryCard.fxml";

    /**
     * Note: Certain keywords such as "location" and "resources" are reserved keywords in JavaFX.
     * As a consequence, UI elements' variable names cannot be set to such keywords
     * or an exception will be thrown by JavaFX during runtime.
     *
     * @see <a href="https://github.com/se-edu/addressbook-level4/issues/336">The issue on AddressBook level 4</a>
     */

    @FXML
    protected HBox cardPane;
    @FXML
    protected Label name;
    @FXML
    protected Label id;
    @FXML
    protected Label startDateTime;
    @FXML
    protected Label endDateTime;
    @FXML
    protected Label additionalInfo;
    @FXML
    protected FlowPane tags;

    protected DateFormat dateFormat;
    protected PrettyTime prettyTime;

    public EntryCard(ReadOnlyEntry entry, int displayedIndex) {
        super(FXML);
        initAll(entry, displayedIndex);
        dateFormat = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT);
        prettyTime = new PrettyTime();
    }

    public EntryCard(String fxml, ReadOnlyEntry entry, int displayedIndex) {
        super(fxml);
        initAll(entry, displayedIndex);
        dateFormat = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT);
        prettyTime = new PrettyTime();
    }

    protected void initAll(ReadOnlyEntry entry, int displayedIndex) {
        initNameId(entry, displayedIndex);
        initTags(entry);
    }

    protected void initNameId(ReadOnlyEntry entry, int displayedIndex) {
        name.setText(entry.getName().toString());
        id.setText(displayedIndex + ". ");
    }

    protected void initTags(ReadOnlyEntry entry) {
        entry.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }

    protected String formatDate(Date date) {
        return dateFormat.format(date);
    }

    protected String prettyTimeFormatDate(Date date) {
        return prettyTime.format(date);
    }
}
```
###### \java\seedu\multitasky\ui\EventListPanel.java
``` java
/**
 * Panel containing the list of events.
 */
public class EventListPanel extends UiPart<Region> {
    private static final String FXML = "EventListPanel.fxml";

    @FXML
    private ListView<ReadOnlyEntry> eventListView;

    public EventListPanel(ObservableList<ReadOnlyEntry> eventList) {
        super(FXML);
        setConnections(eventList);
    }

    private void setConnections(ObservableList<ReadOnlyEntry> eventList) {
        eventListView.setItems(eventList);
        eventListView.setCellFactory(listView -> new EventListViewCell());
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            eventListView.scrollTo(index);
            eventListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class EventListViewCell extends ListCell<ReadOnlyEntry> {

        @Override
        protected void updateItem(ReadOnlyEntry entry, boolean empty) {
            super.updateItem(entry, empty);

            if (empty || entry == null) {
                setGraphic(null);
                setText(null);
            } else {
                int index = getIndex() + 1;
                assert index > 0 : "getIndex returned invalid index";

                Calendar current = new GregorianCalendar();
                // Event has already started
                if (current.compareTo(entry.getStartDateAndTime()) > 0) {
                    setGraphic(new EventOverdueCard(entry, index).getRoot());
                } else {
                    setGraphic(new EventCard(entry, index).getRoot());
                }
            }
        }
    }

}
```
###### \java\seedu\multitasky\ui\FloatingTaskListPanel.java
``` java
/**
 * Panel containing the list of floating tasks.
 */
public class FloatingTaskListPanel extends UiPart<Region> {
    private static final String FXML = "FloatingTaskListPanel.fxml";

    @FXML
    private ListView<ReadOnlyEntry> floatingTaskListView;

    public FloatingTaskListPanel(ObservableList<ReadOnlyEntry> floatingTaskList) {
        super(FXML);
        setConnections(floatingTaskList);
    }

    private void setConnections(ObservableList<ReadOnlyEntry> floatingTaskList) {
        floatingTaskListView.setItems(floatingTaskList);
        floatingTaskListView.setCellFactory(listView -> new FloatingTaskListViewCell());
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            floatingTaskListView.scrollTo(index);
            floatingTaskListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class FloatingTaskListViewCell extends ListCell<ReadOnlyEntry> {

        @Override
        protected void updateItem(ReadOnlyEntry entry, boolean empty) {
            super.updateItem(entry, empty);

            if (empty || entry == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(new FloatingTaskCard(entry, getIndex() + 1).getRoot());
            }
        }
    }

}
```
###### \java\seedu\multitasky\ui\MainWindow.java
``` java
/**
 * The Main Window. Provides the basic application layout containing
 * a menu bar and space where other JavaFX elements can be placed.
 */
public class MainWindow extends UiPart<Region> {

    private static final String ICON = "/images/calendar.png";
    private static final String FXML = "MainWindow.fxml";
    private static final int MIN_HEIGHT = 600;
    private static final int MIN_WIDTH = 450;

    private Stage primaryStage;
    private Logic logic;

    // Independent Ui parts residing in this Ui container
    private EventListPanel eventListPanel;
    private DeadlineListPanel deadlineListPanel;
    private FloatingTaskListPanel floatingTaskListPanel;
    private Config config;
    private UserPrefs prefs;

    @FXML
    private MenuItem helpMenuItem;

    @FXML
    private Label stateCurrentlyShown;

    @FXML
    private StackPane eventListPanelPlaceholder;

    @FXML
    private StackPane deadlineListPanelPlaceholder;

    @FXML
    private StackPane floatingTaskListPanelPlaceholder;

    @FXML
    private StackPane resultDisplayPlaceholder;

    @FXML
    private StackPane commandBoxPlaceholder;

    @FXML
    private StackPane statusbarPlaceholder;

    public MainWindow(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {
        super(FXML);

        // Set dependencies
        this.primaryStage = primaryStage;
        this.logic = logic;
        this.config = config;
        this.prefs = prefs;

        // Configure the UI
        setTitle(config.getAppTitle());
        setIcon(ICON);
        setWindowMinSize();
        setWindowDefaultSize(prefs);
        Scene scene = new Scene(getRoot());
        primaryStage.setScene(scene);

        setAccelerators();
        setCommandShortcuts();

        registerAsAnEventHandler(this);
    }

    public Stage getPrimaryStage() {
        return primaryStage;
    }

    private void setAccelerators() {
        setAccelerator(helpMenuItem, KeyCombination.valueOf("F1"));
    }

    private void setCommandShortcuts() {
        setCommandExecuteShortcut(UndoCommand.COMMAND_WORD,
                                  new KeyCodeCombination(KeyCode.Z, KeyCombination.CONTROL_DOWN));
        setCommandExecuteShortcut(RedoCommand.COMMAND_WORD,
                                  new KeyCodeCombination(KeyCode.R, KeyCombination.CONTROL_DOWN));

        setCommandShortcut(EditCommand.COMMAND_WORD + " ", new KeyCodeCombination(KeyCode.F2));
        setCommandShortcut(FindCommand.COMMAND_WORD + " ", new KeyCodeCombination(KeyCode.F3));
        setCommandShortcut(ExitCommand.COMMAND_WORD + " ", new KeyCodeCombination(KeyCode.F4));
        setCommandShortcut(ListCommand.COMMAND_WORD + " ", new KeyCodeCombination(KeyCode.F5));
    }

    /**
     * Sets the accelerator of a MenuItem.
     * @param keyCombination the KeyCombination value of the accelerator
     */
    private void setAccelerator(MenuItem menuItem, KeyCombination keyCombination) {
        menuItem.setAccelerator(keyCombination);
        getRoot().addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            if (event.getTarget() instanceof TextInputControl && keyCombination.match(event)) {
                menuItem.getOnAction().handle(new ActionEvent());
                event.consume();
            }
        });
    }

    /**
     * Sets up a command execute shortcut.
     * When the shortcut key combination is pressed, the command string is executed.
     */
    private void setCommandExecuteShortcut(String command, KeyCodeCombination keyCodeCombination) {
        getRoot().addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            if (event.getTarget() instanceof TextInputControl && keyCodeCombination.match(event)) {
                raise(new NewCommandToExecuteEvent(command));
                event.consume();
            }
        });
    }

    /**
     * Sets up a command shortcut.
     * When the shortcut key combination is pressed, the command string is entered into the command box,
     * but not executed.
     */
    private void setCommandShortcut(String command, KeyCodeCombination keyCodeCombination) {
        getRoot().addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            if (event.getTarget() instanceof TextInputControl && keyCodeCombination.match(event)) {
                raise(new NewCommandEvent(command));
                event.consume();
            }
        });
    }

    void fillInnerParts() {
        stateCurrentlyShown.setText(String.format(Messages.MESSAGE_CURRENTLY_DISPLAYING,
                                    stateToString(Entry.State.ACTIVE)));

        eventListPanel = new EventListPanel(logic.getFilteredEventList());
        eventListPanelPlaceholder.getChildren().add(eventListPanel.getRoot());

        deadlineListPanel = new DeadlineListPanel(logic.getFilteredDeadlineList());
        deadlineListPanelPlaceholder.getChildren().add(deadlineListPanel.getRoot());

        floatingTaskListPanel = new FloatingTaskListPanel(logic.getFilteredFloatingTaskList());
        floatingTaskListPanelPlaceholder.getChildren().add(floatingTaskListPanel.getRoot());

        ResultDisplay resultDisplay = new ResultDisplay();
        resultDisplayPlaceholder.getChildren().add(resultDisplay.getRoot());

        StatusBarFooter statusBarFooter = new StatusBarFooter(prefs.getEntryBookFilePath());
        statusbarPlaceholder.getChildren().add(statusBarFooter.getRoot());

        CommandBox commandBox = new CommandBox(logic);
        commandBoxPlaceholder.getChildren().add(commandBox.getRoot());

    }

    void hide() {
        primaryStage.hide();
    }

    /**
     * To format the state in a form that is consistent with command syntax.
     * ARCHIVED -> archive
     * DELETED -> bin
     */
    private String stateToString(Entry.State state) {
        if (state == null) {
            return "all";
        }
        switch (state) {
        case ACTIVE:
            return "active";
        case ARCHIVED:
            return "archive";
        case DELETED:
            return "bin";
        default:
            return "error";
        }
    }

    private void setTitle(String appTitle) {
        primaryStage.setTitle(appTitle);
    }

    /**
     * Sets the given image as the icon of the main window.
     * @param iconSource e.g. {@code "/images/help_icon.png"}
     */
    private void setIcon(String iconSource) {
        FxViewUtil.setStageIcon(primaryStage, iconSource);
    }

    /**
     * Sets the default size based on user preferences.
     */
    private void setWindowDefaultSize(UserPrefs prefs) {
        primaryStage.setHeight(prefs.getGuiSettings().getWindowHeight());
        primaryStage.setWidth(prefs.getGuiSettings().getWindowWidth());
        if (prefs.getGuiSettings().getWindowCoordinates() != null) {
            primaryStage.setX(prefs.getGuiSettings().getWindowCoordinates().getX());
            primaryStage.setY(prefs.getGuiSettings().getWindowCoordinates().getY());
        }
    }

    private void setWindowMinSize() {
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }

    /**
     * Returns the current size and the position of the main Window.
     */
    GuiSettings getCurrentGuiSetting() {
        return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(),
                (int) primaryStage.getX(), (int) primaryStage.getY());
    }

    @FXML
    public void handleHelp() {
        HelpWindow helpWindow = new HelpWindow();
        helpWindow.show();
    }

    void show() {
        primaryStage.show();
    }

    /**
     * Closes the application.
     */
    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }

    public EventListPanel getEventListPanel() {
        return this.eventListPanel;
    }

    public DeadlineListPanel getDeadlineListPanel() {
        return this.deadlineListPanel;
    }

    public FloatingTaskListPanel getFloatingTaskListPanel() {
        return this.floatingTaskListPanel;
    }

    @Subscribe
    private void handleListTypeUpdateEvent(ListTypeUpdateEvent event) {
        stateCurrentlyShown.setText(String.format(Messages.MESSAGE_CURRENTLY_DISPLAYING,
                                    stateToString(event.state)));
    }

}
```
###### \java\seedu\multitasky\ui\util\CommandAutocomplete.java
``` java
/**
 * Provides autocomplete functionality to the command box.
 * Uses {@code PowerMatch} from {@code seedu.multitasky.commons.util} to come up with matches.
 * Listens and responds to the {@code TAB} key pressed automatically, as long as it's pressed while
 * focus is on the command text field.
 */
public class CommandAutocomplete {

    private static final int COMMAND_WORD_IDX = 0;
    private static final int LAST_WORD_IDX = 1;

    private static final String[] commandWords = new String[] {
        AddCommand.COMMAND_WORD,
        ClearCommand.COMMAND_WORD,
        CompleteCommand.COMMAND_WORD,
        DeleteCommand.COMMAND_WORD,
        EditCommand.COMMAND_WORD,
        ExitCommand.COMMAND_WORD,
        FindCommand.COMMAND_WORD,
        HelpCommand.COMMAND_WORD,
        HistoryCommand.COMMAND_WORD,
        ListCommand.COMMAND_WORD,
        RedoCommand.COMMAND_WORD,
        RestoreCommand.COMMAND_WORD,
        UndoCommand.COMMAND_WORD,
    };

    private static final HashMap<String, String[]> commandKeywords;

    private static final Set<String> prefixOnlyCommands;

    static {
        commandKeywords = new HashMap<>();
        commandKeywords.put(AddCommand.COMMAND_WORD, AddCommand.VALID_PREFIXES);
        commandKeywords.put(ClearCommand.COMMAND_WORD, ClearCommand.VALID_PREFIXES);
        commandKeywords.put(CompleteCommand.COMMAND_WORD, CompleteCommand.VALID_PREFIXES);
        commandKeywords.put(DeleteCommand.COMMAND_WORD, DeleteCommand.VALID_PREFIXES);
        commandKeywords.put(EditCommand.COMMAND_WORD, EditCommand.VALID_PREFIXES);
        commandKeywords.put(ExitCommand.COMMAND_WORD, ExitCommand.VALID_PREFIXES);
        commandKeywords.put(FindCommand.COMMAND_WORD, FindCommand.VALID_PREFIXES);
        commandKeywords.put(HelpCommand.COMMAND_WORD, HelpCommand.VALID_PREFIXES);
        commandKeywords.put(HistoryCommand.COMMAND_WORD, HistoryCommand.VALID_PREFIXES);
        commandKeywords.put(ListCommand.COMMAND_WORD, ListCommand.VALID_PREFIXES);
        commandKeywords.put(RedoCommand.COMMAND_WORD, RedoCommand.VALID_PREFIXES);
        commandKeywords.put(RestoreCommand.COMMAND_WORD, RestoreCommand.VALID_PREFIXES);
        commandKeywords.put(UndoCommand.COMMAND_WORD, UndoCommand.VALID_PREFIXES);

        prefixOnlyCommands = new HashSet<>();
        prefixOnlyCommands.add(ClearCommand.COMMAND_WORD);
        prefixOnlyCommands.add(ExitCommand.COMMAND_WORD);
        prefixOnlyCommands.add(HelpCommand.COMMAND_WORD);
        prefixOnlyCommands.add(HistoryCommand.COMMAND_WORD);
        prefixOnlyCommands.add(ListCommand.COMMAND_WORD);
        prefixOnlyCommands.add(RedoCommand.COMMAND_WORD);
        prefixOnlyCommands.add(UndoCommand.COMMAND_WORD);
    }

    @FXML
    private Region commandBoxRegion;

    @FXML
    private TextField commandTextField;

    private final EventHandler<KeyEvent> tabKeyEventHandler = new EventHandler<KeyEvent>() {
        @Override
        public void handle(KeyEvent event) {
            if (event.getCode() == KeyCode.TAB) {
                event.consume();
                autocomplete();
            }
        }
    };

    public CommandAutocomplete(Region commandBoxRegion, TextField commandTextField) {
        assert commandBoxRegion != null : "commandBoxRegion cannot be null";
        assert commandTextField != null : "commandTextField cannot be null";
        this.commandBoxRegion = commandBoxRegion;
        this.commandTextField = commandTextField;
        this.commandBoxRegion.addEventFilter(KeyEvent.KEY_PRESSED, tabKeyEventHandler);
    }

    private void autocomplete() {
        StringBuilder commandResult = new StringBuilder();
        String[] splitCommand = extractCommandWord(commandTextField.getText().trim());
        String commandMatch = autocompleteCommandWord(splitCommand[COMMAND_WORD_IDX]);
        commandResult.append(commandMatch).append(" ");

        // Managed to autocomplete to a valid command word
        if (Arrays.asList(commandWords).contains(commandMatch)) {
            // We have other words to autocomplete
            if (splitCommand[1].length() > 0) {
                if (prefixOnlyCommands.contains(commandMatch)) {
                    // We can attempt to autocomplete each of the words into prefixes
                    String[] matches = matchPrefixes(commandMatch, separateWords(splitCommand[1]));
                    for (String match : matches) {
                        commandResult.append(match).append(" ");
                    }
                }
            } else {
                // We can only attempt to autocomplete the last word into a prefix
                splitCommand = extractLastWord(splitCommand[1]);
                // The middle portion of the input remains unchanged, append if present
                if (splitCommand[0].trim().length() > 0) {
                    commandResult.append(splitCommand[0]).append(" ");
                }
                String autoCompletedPrefix = autocompletePrefix(splitCommand[LAST_WORD_IDX], commandMatch);
                if (autoCompletedPrefix.length() > 0) {
                    commandResult.append(autoCompletedPrefix).append(" ");
                }
            }
        } else {
            // No information to go on to autocomplete anything else
            return;
        }
        setCommandFieldText(commandResult.toString());
        return;
    }

    private String[] matchPrefixes(String commandWord, String... keywords) {
        String[] results = new String[keywords.length];
        for (int i = 0; i < keywords.length; ++i) {
            results[i] = autocompletePrefix(keywords[i], commandWord);
        }
        return results;
    }

    private String autocompleteCommandWord(String keyword) {
        String match = PowerMatch.match(keyword, commandWords);
        if (match != null) {
            return match;
        } else {
            return keyword;
        }
    }

    private String autocompletePrefix(String keyword, String commandWord) {
        String match = PowerMatch.match(keyword, commandKeywords.get(commandWord));
        if (match != null) {
            return match;
        } else {
            return keyword;
        }
    }

    /**
     * Separates the command word from the rest of the input string.
     * @return an array of strings with two elements. The first element is the extracted command word
     * and the second is the rest of the input string with the command word removed.
     */
    private String[] extractCommandWord(String input) {
        // Command word should be followed by whitespace
        String[] words = input.split("\\s+");
        if (words.length > 0) {
            return new String[] {
                words[COMMAND_WORD_IDX].trim(),
                input.substring(words[COMMAND_WORD_IDX].length()).trim()
            };
        }
        return new String[] { "", "" };
    }

    /**
     * Separates the last word from the rest of the input string.
     * @return an array of strings with two elements. The first element is the input string except for the
     * last word, and the second is the last word.
     */
    private String[] extractLastWord(String input) {
        // Words should be delimited by whitespace
        String[] words = input.split("\\s+");
        if (words.length > 0) {
            return new String[] {
                input.substring(0, input.length() - words[words.length - 1].length()).trim(),
                words[words.length - 1].trim()
            };
        }
        return new String[] { "", "" };
    }

    /**
     * Separates the words from the input string, delimited by whitespace.
     */
    private String[] separateWords(String input) {
        return input.split("\\s+");
    }

    private void setCommandFieldText(String text) {
        commandTextField.setText(text);
        setCursorToCommandTextFieldEnd();
    }

    private void setCursorToCommandTextFieldEnd() {
        // Position cursor at the end for consistency and easy editing
        commandTextField.positionCaret(commandTextField.getText().length());
    }

}
```
###### \java\seedu\multitasky\ui\util\CommandHistory.java
``` java
/**
 * Keeps track of the history of commands entered by the user into a text field.
 */
public class CommandHistory {

    @FXML
    private Region commandBoxRegion;

    @FXML
    private TextField commandTextField;

    private Stack<String> commandTextPastStack;
    private Stack<String> commandTextFutureStack;

    private boolean wasUserTypedCommandSaved;

    private final EventHandler<KeyEvent> arrowKeyEventHandler = new EventHandler<KeyEvent>() {
        @Override
        public void handle(KeyEvent event) {
            if (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.KP_UP) {
                event.consume();
                loadPreviousCommand();
            } else if (event.getCode() == KeyCode.DOWN || event.getCode() == KeyCode.KP_DOWN) {
                event.consume();
                loadNextCommand();
            }
        }
    };

    public CommandHistory(Region commandBoxRegion, TextField commandTextField) {
        assert commandBoxRegion != null : "commandBoxRegion cannot be null";
        assert commandTextField != null : "commandTextField cannot be null";
        this.commandBoxRegion = commandBoxRegion;
        this.commandTextField = commandTextField;
        commandTextPastStack = new Stack<>();
        commandTextFutureStack = new Stack<>();
        wasUserTypedCommandSaved = false;
        this.commandBoxRegion.addEventFilter(KeyEvent.KEY_PRESSED, arrowKeyEventHandler);
    }

    public void saveCommand() {
        String command = commandTextField.getText().trim();
        // First push all commands to the past
        while (!commandTextFutureStack.empty()) {
            commandTextPastStack.push(commandTextFutureStack.pop());
        }
        // Remove the user typed command since it wasn't executed
        if (wasUserTypedCommandSaved) {
            wasUserTypedCommandSaved = false;
            commandTextPastStack.pop();
        }
        // Save this command if it's the first one or if it's different from the last one
        if ((command.length() > 0)
                && (commandTextPastStack.empty() || !commandTextPastStack.peek().equals(command))) {
            commandTextPastStack.push(command);
        }
    }

    private void loadPreviousCommand() {
        // A previous command doesn't exist
        if (commandTextPastStack.empty()) {
            return;
        }
        // This is the first time the user requested the previous command
        if (commandTextFutureStack.empty()) {
            String command = commandTextField.getText().trim();
            // Save whatever the user was typing if it is different from the previous entered command
            if (!command.equals(commandTextPastStack.peek())) {
                commandTextFutureStack.push(command);
                wasUserTypedCommandSaved = true;
            }
        }
        // Load the previous command into the text field
        commandTextFutureStack.push(commandTextPastStack.pop());
        setText();
    }

    private void loadNextCommand() {
        // A newer command doesn't exist
        if (commandTextFutureStack.empty()) {
            return;
        }
        commandTextPastStack.push(commandTextFutureStack.pop());
        // This is the newest command
        if (commandTextFutureStack.empty()) {
            commandTextFutureStack.push(commandTextPastStack.pop());
        }
        setText();
    }

    private void setText() {
        commandTextField.setText(commandTextFutureStack.peek());
        setCursorToCommandTextFieldEnd();
    }

    private void setCursorToCommandTextFieldEnd() {
        // Position cursor at the end for consistency and easy editing
        commandTextField.positionCaret(commandTextField.getText().length());
    }

}
```
###### \resources\view\DarkTheme.css
``` css
.event-card {
    -fx-outer-border: derive(#1d1d1d, 20%);
    -fx-body-color: linear-gradient(to bottom, #4c4c4c, #212121);
    -fx-background-color:
        -fx-outer-border,
        -fx-body-color;
    -fx-background-insets: 0, 4;
}

.event-overdue-card {
    -fx-outer-border: derive(#1d1d1d, 20%);
    -fx-body-color: linear-gradient(to bottom, #ff0000, #4c0000);
    -fx-background-color:
        -fx-outer-border,
        -fx-body-color;
    -fx-background-insets: 0, 4;
}

.deadline-card {
    -fx-outer-border: derive(#1d1d1d, 20%);
    -fx-body-color: linear-gradient(to bottom, #4c4c4c, #212121);
    -fx-background-color:
        -fx-outer-border,
        -fx-body-color;
    -fx-background-insets: 0, 4;
}

.deadline-overdue-card {
    -fx-outer-border: derive(#1d1d1d, 20%);
    -fx-body-color: linear-gradient(to bottom, #ff0000, #4c0000);
    -fx-background-color:
        -fx-outer-border,
        -fx-body-color;
    -fx-background-insets: 0, 4;
}

.floating-task-card {
    -fx-outer-border: derive(#1d1d1d, 20%);
    -fx-body-color: linear-gradient(to bottom, #4c4c4c, #212121);
    -fx-background-color:
        -fx-outer-border,
        -fx-body-color;
    -fx-background-insets: 0, 4;
}
```
###### \resources\view\DeadlineCard.fxml
``` fxml

<HBox id="cardPane" fx:id="cardPane" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <GridPane maxHeight="120.0" minHeight="120.0" prefHeight="120.0" stylesheets="@DarkTheme.css" HBox.hgrow="ALWAYS">
    <columnConstraints>
      <ColumnConstraints hgrow="SOMETIMES" minWidth="10" prefWidth="150" />
    </columnConstraints>
    <VBox alignment="CENTER_LEFT" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" styleClass="deadline-card" GridPane.columnIndex="0">
      <padding>
        <Insets bottom="5" left="15" right="5" top="5" />
      </padding>
      <HBox alignment="CENTER_LEFT" spacing="5">
        <Label fx:id="id" styleClass="cell_big_label">
          <minWidth>
            <!-- Ensures that the label text is never truncated -->
            <Region fx:constant="USE_PREF_SIZE" />
          </minWidth>
        </Label>
        <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
      </HBox>
         <Label fx:id="endDateTime" styleClass="cell_small_label" stylesheets="@DarkTheme.css" text="\$end_date_time" />
         <Label fx:id="additionalInfo" styleClass="cell_small_label" text="\$additional_info" />
      <FlowPane fx:id="tags" />
    </VBox>
      <rowConstraints>
         <RowConstraints />
      </rowConstraints>
  </GridPane>
</HBox>
```
###### \resources\view\DeadlineListPanel.fxml
``` fxml
<VBox xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <ListView fx:id="deadlineListView" maxHeight="1.7976931348623157E308" styleClass="pane-with-border" stylesheets="@DarkTheme.css" VBox.vgrow="ALWAYS" />
</VBox>
```
###### \resources\view\DeadlineOverdueCard.fxml
``` fxml

<HBox id="cardPane" fx:id="cardPane" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <GridPane maxHeight="120.0" minHeight="120.0" prefHeight="120.0" styleClass="event-overdue-pane-with-border" stylesheets="@DarkTheme.css" HBox.hgrow="ALWAYS">
    <columnConstraints>
      <ColumnConstraints hgrow="SOMETIMES" minWidth="10" prefWidth="150" />
    </columnConstraints>
    <VBox alignment="CENTER_LEFT" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" styleClass="deadline-overdue-card" stylesheets="@DarkTheme.css" GridPane.columnIndex="0">
      <padding>
        <Insets bottom="5" left="15" right="5" top="5" />
      </padding>
      <HBox alignment="CENTER_LEFT" spacing="5">
        <Label fx:id="id" styleClass="cell_big_label">
          <minWidth>
            <!-- Ensures that the label text is never truncated -->
            <Region fx:constant="USE_PREF_SIZE" />
          </minWidth>
        </Label>
        <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
      </HBox>
         <Label fx:id="endDateTime" styleClass="cell_small_label" stylesheets="@DarkTheme.css" text="\$end_date_time" />
         <Label fx:id="additionalInfo" styleClass="cell_small_label" text="\$additional_info" />
      <FlowPane fx:id="tags" />
    </VBox>
      <rowConstraints>
         <RowConstraints />
      </rowConstraints>
  </GridPane>
</HBox>
```
###### \resources\view\EventCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" prefWidth="150.0" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <GridPane maxHeight="120.0" minHeight="120.0" styleClass="floating-pane-with-border" stylesheets="@DarkTheme.css" HBox.hgrow="ALWAYS">
    <columnConstraints>
      <ColumnConstraints hgrow="SOMETIMES" minWidth="10" prefWidth="150" />
    </columnConstraints>
    <VBox alignment="CENTER_LEFT" maxHeight="120.0" minHeight="120.0" styleClass="event-card" GridPane.columnIndex="0">
      <padding>
        <Insets bottom="5" left="15" right="5" top="5" />
      </padding>
      <HBox alignment="CENTER_LEFT" spacing="5">
        <Label fx:id="id" styleClass="cell_big_label">
          <minWidth>
            <!-- Ensures that the label text is never truncated -->
            <Region fx:constant="USE_PREF_SIZE" />
          </minWidth>
        </Label>
        <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
      </HBox>
         <GridPane prefWidth="128.0">
           <columnConstraints>
             <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
               <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
           </columnConstraints>
           <rowConstraints>
             <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
           </rowConstraints>
            <children>
               <Label fx:id="startDateTime" styleClass="cell_small_label" stylesheets="@DarkTheme.css" text="\$start_date_time" />
               <Label fx:id="endDateTime" styleClass="cell_small_label" stylesheets="@DarkTheme.css" text="\$end_date_time" GridPane.columnIndex="1" />
            </children>
         </GridPane>
         <Label fx:id="additionalInfo" styleClass="cell_small_label" text="\$additional_info" />
      <FlowPane fx:id="tags" />
    </VBox>
      <rowConstraints>
         <RowConstraints />
      </rowConstraints>
  </GridPane>
</HBox>
```
###### \resources\view\EventListPanel.fxml
``` fxml
<VBox xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <ListView fx:id="eventListView" maxHeight="1.7976931348623157E308" styleClass="pane-with-border" stylesheets="@DarkTheme.css" VBox.vgrow="ALWAYS" />
</VBox>
```
###### \resources\view\EventOverdueCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <GridPane maxHeight="120.0" minHeight="120.0" prefHeight="120.0" HBox.hgrow="ALWAYS">
    <columnConstraints>
      <ColumnConstraints hgrow="SOMETIMES" minWidth="10" prefWidth="150" />
    </columnConstraints>
    <VBox alignment="CENTER_LEFT" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" styleClass="event-overdue-card" stylesheets="@DarkTheme.css" GridPane.columnIndex="0">
      <padding>
        <Insets bottom="5" left="15" right="5" top="5" />
      </padding>
      <HBox alignment="CENTER_LEFT" spacing="5">
        <Label fx:id="id" styleClass="cell_big_label">
          <minWidth>
            <!-- Ensures that the label text is never truncated -->
            <Region fx:constant="USE_PREF_SIZE" />
          </minWidth>
        </Label>
        <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
      </HBox>
         <GridPane>
            <columnConstraints>
               <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
               <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
            </columnConstraints>
            <rowConstraints>
               <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
            </rowConstraints>
            <children>
               <Label fx:id="startDateTime" styleClass="cell_small_label" stylesheets="@DarkTheme.css" text="\$start_date_time" />
               <Label fx:id="endDateTime" styleClass="cell_small_label" stylesheets="@DarkTheme.css" text="\$end_date_time" GridPane.columnIndex="1" />
            </children>
         </GridPane>
         <Label fx:id="additionalInfo" styleClass="cell_small_label" text="\$additional_info" />
      <FlowPane fx:id="tags" />
    </VBox>
      <rowConstraints>
         <RowConstraints />
      </rowConstraints>
  </GridPane>
</HBox>
```
###### \resources\view\FloatingTaskCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <GridPane maxHeight="120.0" minHeight="120.0" prefHeight="120.0" stylesheets="@DarkTheme.css" HBox.hgrow="ALWAYS">
    <columnConstraints>
      <ColumnConstraints hgrow="SOMETIMES" minWidth="10" prefWidth="150" />
    </columnConstraints>
    <VBox alignment="CENTER_LEFT" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" styleClass="floating-task-card" GridPane.columnIndex="0">
      <padding>
        <Insets bottom="5" left="15" right="5" top="5" />
      </padding>
      <HBox alignment="CENTER_LEFT" spacing="5">
        <Label fx:id="id" styleClass="cell_big_label">
          <minWidth>
            <!-- Ensures that the label text is never truncated -->
            <Region fx:constant="USE_PREF_SIZE" />
          </minWidth>
        </Label>
        <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
      </HBox>
      <FlowPane fx:id="tags" />
    </VBox>
      <rowConstraints>
         <RowConstraints />
      </rowConstraints>
  </GridPane>
</HBox>
```
###### \resources\view\FloatingTaskListPanel.fxml
``` fxml
<VBox xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <ListView fx:id="floatingTaskListView" maxHeight="1.7976931348623157E308" styleClass="pane-with-border" stylesheets="@DarkTheme.css" VBox.vgrow="ALWAYS" />
</VBox>
```
###### \resources\view\MainWindow.fxml
``` fxml

<VBox maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" prefHeight="777.0" prefWidth="1015.0" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <stylesheets>
    <URL value="@DarkTheme.css" />
    <URL value="@Extensions.css" />
  </stylesheets>

  <MenuBar VBox.vgrow="NEVER">
    <Menu mnemonicParsing="false" text="File">
      <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
    </Menu>
    <Menu mnemonicParsing="false" text="Help">
      <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
    </Menu>
  </MenuBar>
   <StackPane minHeight="30.0" prefHeight="150.0" prefWidth="200.0" styleClass="pane-with-border">
      <children>
         <Label fx:id="stateCurrentlyShown" alignment="CENTER_RIGHT" contentDisplay="RIGHT" text="\$stateCurrentlyShown" textAlignment="CENTER" />
      </children>
   </StackPane>
   <StackPane maxHeight="50.0" minHeight="50.0" prefHeight="50.0" styleClass="pane-with-border">
      <padding>
         <Insets bottom="5" left="10" right="10" top="5" />
      </padding>
      <children>
         <GridPane alignment="CENTER" StackPane.alignment="CENTER">
           <columnConstraints>
             <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
             <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
               <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
           </columnConstraints>
           <rowConstraints>
             <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
           </rowConstraints>
            <children>
               <Label alignment="CENTER" contentDisplay="CENTER" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="label-header" text="Events" textAlignment="CENTER" />
               <Label alignment="CENTER" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="label-header" text="Deadlines" GridPane.columnIndex="1" />
               <Label alignment="CENTER" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="label-header" text="Floating Tasks" GridPane.columnIndex="2" />
            </children>
         </GridPane>
      </children>
   </StackPane>
   <StackPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="pane-with-border" stylesheets="@DarkTheme.css">
      <padding>
         <Insets bottom="5" left="10" right="10" top="5" />
      </padding>
      <children>
         <GridPane gridLinesVisible="true" minHeight="100.0" prefHeight="1000.0" prefWidth="1000.0" styleClass="pane-with-border" stylesheets="@DarkTheme.css">
           <columnConstraints>
             <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
             <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
               <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
           </columnConstraints>
           <rowConstraints>
             <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
           </rowConstraints>
            <children>
               <StackPane fx:id="eventListPanelPlaceholder" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" prefWidth="331.0" styleClass="pane-with-border" stylesheets="@DarkTheme.css" />
               <StackPane fx:id="deadlineListPanelPlaceholder" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="pane-with-border" stylesheets="@DarkTheme.css" GridPane.columnIndex="1" />
               <StackPane fx:id="floatingTaskListPanelPlaceholder" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="pane-with-border" stylesheets="@DarkTheme.css" GridPane.columnIndex="2" />
            </children>
         </GridPane>
      </children>
   </StackPane>

  <StackPane fx:id="resultDisplayPlaceholder" maxHeight="100" minHeight="100" prefHeight="100" styleClass="pane-with-border" VBox.vgrow="NEVER">
    <padding>
      <Insets bottom="5" left="10" right="10" top="5" />
    </padding>
  </StackPane>

  <StackPane fx:id="commandBoxPlaceholder" styleClass="pane-with-border" VBox.vgrow="NEVER">
    <padding>
      <Insets bottom="5" left="10" right="10" top="5" />
    </padding>
  </StackPane>

  <StackPane fx:id="statusbarPlaceholder" maxHeight="30.0" minHeight="30.0" prefHeight="30.0" styleClass="pane-without-border" VBox.vgrow="NEVER" />
</VBox>
```
