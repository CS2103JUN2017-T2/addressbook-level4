# A0125586X
###### \java\seedu\multitasky\commons\events\ui\ListTypeUpdateEvent.java
``` java
/**
 * Indicates that the entries listed in the UI are now a different type (active/archived/deleted).
 */
public class ListTypeUpdateEvent extends BaseEvent {

    public final String state;

    public ListTypeUpdateEvent(String state) {
        this.state = state;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\multitasky\commons\util\match\AcronymMatch.java
``` java
/**
 * Class that performs acronym matching.
 */
public class AcronymMatch implements Match {

    public String match(final String input, final String... potentialMatches) {
        if (input == null || potentialMatches == null || potentialMatches.length == 0) {
            return null;
        }
        return MatchUtil.getRegexMatch(getRegex(input), potentialMatches);
    }

    public boolean isMatch(final String input, final String potentialMatch) {
        if (input == null || potentialMatch == null) {
            return false;
        }
        return MatchUtil.getRegexMatch(getRegex(input), potentialMatch) != null;
    }

    private static String getRegex(final String input) {
        final ArrayList<String> chars = new ArrayList<>(Arrays.asList(input.split("")));
        final StringBuilder regex = new StringBuilder();
        // Alternate keyword characters and any non whitespace
        regex.append(MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE);
        for (String singleChar : chars) {
            regex.append(singleChar);
            regex.append(MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE);
        }
        return regex.toString();
    }

}
```
###### \java\seedu\multitasky\commons\util\match\Match.java
``` java
/**
 * Interface for different types of objects that perform matching.
 */
public interface Match {

    /**
     * Attempts to find a single potential match for the input.
     * If multiple matches are found, {@code null} is returned.
     */
    public String match(final String input, final String... potentialMatches);

    /**
     * Attempts to match the potential match with the input.
     * @return if the input can be matched to the potential match.
     */
    public boolean isMatch(final String input, final String potentialMatch);

}
```
###### \java\seedu\multitasky\commons\util\match\Matcher.java
``` java
/**
 * Interface for objects that perform different levels of matching.
 */
public interface Matcher {

    public String match(final int level, final String input, final String... potentialMatches);

    public boolean isMatch(final int level, final String input, final String potentialMatch);

}
```
###### \java\seedu\multitasky\commons\util\match\MatchUtil.java
``` java
/**
 * Utility class for performing matches.
 */
public class MatchUtil {

    public static final String REGEX_OPTIONAL_NON_WHITESPACE = "((\\S?)+)";
    public static final String REGEX_PRESENT_NON_WHITESPACE = "(\\S+)";

    /**
     * Attempts each regex in turn until one provides a single match.
     * If none provide a single match, {@code null} is returned.
     */
    public static String getRegexMatch(final List<String> regexes, final String... potentialMatches) {
        String match = null;
        for (String regex : regexes) {
            match = getRegexMatch(regex, potentialMatches);
            if (match != null) {
                return match;
            }
        }
        return null;
    }

    /**
     * Attempts to find a single match for the regex.
     * If multiple matches are found, {@code null} is returned.
     */
    public static String getRegexMatch(final String regex, final String... potentialMatches) {
        ArrayList<String> matches = new ArrayList<>();
        for (String potentialMatch : potentialMatches) {
            if (potentialMatch.matches(regex)) {
                matches.add(potentialMatch);
            }
        }
        return filterMatches(matches);
    }

    /**
     * Filters the matches found into a single match.
     * @return the match, if there is just one. otherwise {@code null} is returned. */
    public static String filterMatches(List<String> matches) {
        if (matches == null || matches.size() != 1) {
            return null;
        }
        return matches.get(0);
    }

    /**
     * Removes whitespace from an input string.
     */
    public static String removeWhitespace(final String input) {
        ArrayList<String> words = new ArrayList<>(Arrays.asList(input.trim().split("\\s+")));
        return buildString(words);
    }

    /**
     * Builds a string from a collection that can be iterated over
     */
    public static String buildString(final Collection<String> chars) {
        if (chars == null || chars.size() == 0) {
            return "";
        }
        StringBuilder builder = new StringBuilder();
        for (String string : chars) {
            builder.append(string);
        }
        return builder.toString();
    }

    public static ArrayList<String> getPermutations(final String keyword) {
        HashSet<String> permutations = new HashSet<>();
        ArrayList<String> chars = new ArrayList<>(Arrays.asList(keyword.split("")));
        generateUniquePermutations(chars, 0, keyword.length() - 1, permutations);
        return new ArrayList<String>(permutations);
    }

    private static void generateUniquePermutations(ArrayList<String> chars, int i, int permutationLength,
                                                   HashSet<String> permutations) {
        // Filled up the permutation to the specified length
        if (i == permutationLength) {
            permutations.add(buildString(chars));
        } else {
            for (int j = i; j <= permutationLength; ++j) {
                Collections.swap(chars, i, j);
                generateUniquePermutations(chars, i + 1, permutationLength, permutations);
                Collections.swap(chars, i, j);
            }
        }
    }

}
```
###### \java\seedu\multitasky\commons\util\match\PermutationMatch.java
``` java
/**
 * Class that performs permutation matching.
 */
public class PermutationMatch implements Match {

    public static final int MAX_LENGTH = 8;

    public String match(final String input, final String... potentialMatches) {
        if (input == null || potentialMatches == null || potentialMatches.length == 0
            || input.length() > MAX_LENGTH) {
            return null;
        }
        return MatchUtil.getRegexMatch(getRegexes(input), potentialMatches);
    }

    public boolean isMatch(final String input, final String potentialMatch) {
        if (input == null || potentialMatch == null
            || input.length() > MAX_LENGTH) {
            return false;
        }
        return MatchUtil.getRegexMatch(getRegexes(input), potentialMatch) != null;
    }

    private static ArrayList<String> getRegexes(final String input) {
        final ArrayList<String> permutations = MatchUtil.getPermutations(input);
        for (int i = 0; i < permutations.size(); ++i) {
            permutations.set(i, MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE + permutations.get(i)
                              + MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE);
        }
        return permutations;
    }

}
```
###### \java\seedu\multitasky\commons\util\match\PowerMatch.java
``` java
/**
 * Checks for matches using a variety of matching criteria. The different levels of matching available are:
 * 0: substring match
 * 1: prefix match
 * 2: acronym match
 * 3: permutation match
 * 4: 1 wrong/extra character match
 * 5: 2 wrong/extra character match
 * 6: 2 wrong/extra character match
 */
public class PowerMatch implements Matcher {

    public static final int UNUSED = -1;
    public static final int MIN_LEVEL = 0;
    public static final int MAX_LEVEL = 6;

    private Match[] matchLevels = {
        new SubstringMatch(),
        new PrefixMatch(),
        new AcronymMatch(),
        new PermutationMatch(),
        new WrongExtra1Match(),
        new WrongExtra2Match(),
        new WrongExtra3Match(),
    };

    /**
     * Attempts to find a match between the input and a single entry in {@code potentialMatches},
     * using the matching level specified.
     *
     * @param level            the level of matching to use.
     * @param input            the input to attempt to find a match for
     * @param potentialMatches the list of potential matches for {@code input}
     * @return the match for {@code input}, if one is found. Otherwise {@code null} is returned.
     *         {@code null} is also returned if there is a null input string, {@code potentialMatches} is null,
     *         or if {@code potentialMatches} is empty.
     */
    public String match(final int level, final String input, final String... potentialMatches) {
        if (level < 0 || level > MAX_LEVEL || input == null || potentialMatches == null
            || potentialMatches.length == 0) {
            return null;
        } else if (input.isEmpty()) {
            if (potentialMatches.length == 1) {
                return potentialMatches[0];
            } else {
                return null;
            }
        }
        return matchLevels[level].match(input, potentialMatches);
    }

    /**
     * Attempts to match the input with the potential match, using the matching level specified.
     *
     * @param level          the level of matching to use.
     * @param input          the input to attempt to find a match for
     * @param potentialMatch the potential match {@code input}
     * @return if {@code input} can be matched to {@code potentialMatch} using the PowerMatch algorithm
     *         at the specified level.
     */
    public boolean isMatch(final int level, final String input, final String potentialMatch) {
        if (level < 0 || level > MAX_LEVEL || input == null || potentialMatch == null
            || potentialMatch.isEmpty()) {
            return false;
        } else if (input.isEmpty()) {
            return true;
        }
        return matchLevels[level].isMatch(input, potentialMatch);
    }

}
```
###### \java\seedu\multitasky\commons\util\match\PrefixMatch.java
``` java
/**
 * Class that performs prefix matching.
 */
public class PrefixMatch implements Match {

    public String match(final String input, final String... potentialMatches) {
        if (input == null || potentialMatches == null || potentialMatches.length == 0) {
            return null;
        }
        return MatchUtil.getRegexMatch(getRegex(input), potentialMatches);
    }

    public boolean isMatch(final String input, final String potentialMatch) {
        if (input == null || potentialMatch == null) {
            return false;
        }
        return MatchUtil.getRegexMatch(getRegex(input), potentialMatch) != null;
    }

    private static String getRegex(final String input) {
        return input + MatchUtil.REGEX_PRESENT_NON_WHITESPACE;
    }

}
```
###### \java\seedu\multitasky\commons\util\match\SubstringMatch.java
``` java
/**
 * Class that performs substring matching.
 */
public class SubstringMatch implements Match {

    public String match(final String input, final String... potentialMatches) {
        if (input == null || potentialMatches == null || potentialMatches.length == 0) {
            return null;
        }
        return MatchUtil.getRegexMatch(getRegex(input), potentialMatches);
    }

    public boolean isMatch(final String input, final String potentialMatch) {
        if (input == null || potentialMatch == null) {
            return false;
        }
        return MatchUtil.getRegexMatch(getRegex(input), potentialMatch) != null;
    }

    private static String getRegex(final String input) {
        return MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE + input + MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE;
    }

}
```
###### \java\seedu\multitasky\commons\util\match\WrongExtra1Match.java
``` java
/**
 * Class that performs matching with 1 wrong or extra character.
 */
public class WrongExtra1Match implements Match {

    public static final int MIN_LENGTH = 4;

    public String match(final String input, final String... potentialMatches) {
        if (input == null || potentialMatches == null
            || input.length() < MIN_LENGTH || potentialMatches.length == 0) {
            return null;
        }
        return MatchUtil.getRegexMatch(getRegexes(input), potentialMatches);
    }

    public boolean isMatch(final String input, final String potentialMatch) {
        if (input == null || potentialMatch == null
            || input.length() < MIN_LENGTH) {
            return false;
        }
        return MatchUtil.getRegexMatch(getRegexes(input), potentialMatch) != null;
    }

    private static ArrayList<String> getRegexes(final String input) {
        final ArrayList<String> regexes = new ArrayList<>();
        final ArrayList<String> chars = new ArrayList<>(Arrays.asList(input.split("")));
        for (int i = 0; i < chars.size(); ++i) {
            String temp = chars.get(i);
            chars.set(i, MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE);
            regexes.add(MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE + MatchUtil.buildString(chars)
                      + MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE);
            chars.set(i, temp);
        }
        return regexes;
    }

}
```
###### \java\seedu\multitasky\commons\util\match\WrongExtra2Match.java
``` java
/**
 * Class that performs matching with 2 wrong or extra characters.
 */
public class WrongExtra2Match implements Match {

    public static final int MIN_LENGTH = 5;
    public static final int MAX_LENGTH = 14;

    public String match(final String input, final String... potentialMatches) {
        if (input == null || potentialMatches == null
            || input.length() < MIN_LENGTH || input.length() > MAX_LENGTH
            || potentialMatches.length == 0) {
            return null;
        }
        return MatchUtil.getRegexMatch(getRegexes(input), potentialMatches);
    }

    public boolean isMatch(final String input, final String potentialMatch) {
        if (input == null || potentialMatch == null
            || input.length() < MIN_LENGTH || input.length() > MAX_LENGTH) {
            return false;
        }
        return MatchUtil.getRegexMatch(getRegexes(input), potentialMatch) != null;
    }

    private static ArrayList<String> getRegexes(final String input) {
        final ArrayList<String> regexes = new ArrayList<>();
        final ArrayList<String> chars = new ArrayList<>(Arrays.asList(input.split("")));
        for (int i = 0; i < chars.size(); ++i) {
            for (int j = i + 1; j < chars.size(); ++j) {
                String iTemp = chars.get(i);
                String jTemp = chars.get(j);
                chars.set(i, MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE);
                chars.set(j, MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE);
                regexes.add(MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE + MatchUtil.buildString(chars)
                        + MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE);
                chars.set(i, iTemp);
                chars.set(j, jTemp);
            }
        }
        return regexes;
    }

}
```
###### \java\seedu\multitasky\commons\util\match\WrongExtra3Match.java
``` java
/**
 * Class that performs matching with 3 wrong or extra characters.
 */
public class WrongExtra3Match implements Match {

    public static final int MIN_LENGTH = 7;
    public static final int MAX_LENGTH = 14;

    public String match(final String input, final String... potentialMatches) {
        if (input == null || potentialMatches == null
            || input.length() < MIN_LENGTH || input.length() > MAX_LENGTH
            || potentialMatches.length == 0) {
            return null;
        }
        return MatchUtil.getRegexMatch(getRegexes(input), potentialMatches);
    }

    public boolean isMatch(final String input, final String potentialMatch) {
        if (input == null || potentialMatch == null
            || input.length() < MIN_LENGTH || input.length() > MAX_LENGTH) {
            return false;
        }
        return MatchUtil.getRegexMatch(getRegexes(input), potentialMatch) != null;
    }

    private static ArrayList<String> getRegexes(final String input) {
        final ArrayList<String> regexes = new ArrayList<>();
        final ArrayList<String> chars = new ArrayList<>(Arrays.asList(input.split("")));
        for (int i = 0; i < chars.size(); ++i) {
            for (int j = i + 1; j < chars.size(); ++j) {
                for (int k = j + 1; k < chars.size(); ++k) {
                    String iTemp = chars.get(i);
                    String jTemp = chars.get(j);
                    String kTemp = chars.get(k);
                    chars.set(i, MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE);
                    chars.set(j, MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE);
                    chars.set(k, MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE);
                    regexes.add(MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE + MatchUtil.buildString(chars)
                            + MatchUtil.REGEX_OPTIONAL_NON_WHITESPACE);
                    chars.set(i, iTemp);
                    chars.set(j, jTemp);
                    chars.set(k, kTemp);
                }
            }
        }
        return regexes;
    }

}
```
###### \java\seedu\multitasky\logic\commands\ListCommand.java
``` java
/**
 * Lists all entries in the entry book to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Lists entries in the active/archive/bin list"
            + ", filtered by an optional starting and ending date. The entries can also be shown in "
            + "different sorted orders." + "\n"
            + "Format: " + COMMAND_WORD
            + " [" + CliSyntax.PREFIX_ARCHIVE + " | " + CliSyntax.PREFIX_BIN + "]"
            + " [" + CliSyntax.PREFIX_UPCOMING + " | " + CliSyntax.PREFIX_REVERSE + "]"
            + " [" + CliSyntax.PREFIX_FROM + " start date]" + " [" + CliSyntax.PREFIX_TO + "end date]" + "\n"
            + "Example: " + COMMAND_WORD + " " + CliSyntax.PREFIX_UPCOMING;

    public static final String MESSAGE_ALL_SUCCESS = "Listed all entries";

    public static final String MESSAGE_ACTIVE_SUCCESS = "Listed all active entries";

    public static final String MESSAGE_ARCHIVE_SUCCESS = "Listed all entries in the archive";

    public static final String MESSAGE_BIN_SUCCESS = "Listed all entries in the bin";

    public static final String MESSAGE_DEFAULT_ORDER = "in default order";

    public static final String MESSAGE_REVERSE_ORDER = "in reverse order";

    public static final String MESSAGE_UPCOMING_ORDER = "in upcoming order";

    public static final String[] VALID_PREFIXES = { CliSyntax.PREFIX_ARCHIVE.toString(),
                                                    CliSyntax.PREFIX_BIN.toString(),
                                                    CliSyntax.PREFIX_ALL.toString(),
                                                    CliSyntax.PREFIX_UPCOMING.toString(),
                                                    CliSyntax.PREFIX_REVERSE.toString(),
                                                    CliSyntax.PREFIX_FROM.toString(),
                                                    CliSyntax.PREFIX_TO.toString() };

    public enum ShowType { ACTIVE, ARCHIVE, BIN, ALL }

    public enum Ordering { DEFAULT, REVERSE, UPCOMING }

    private static final HashSet<String> MATCH_ALL_KEYWORDS = new HashSet<>();

    private ShowType showType;
    private Ordering ordering;

    private Calendar startDate;
    private Calendar endDate;

    public ListCommand() {
        showType = ShowType.ACTIVE;
        ordering = Ordering.DEFAULT;
    }

    public ListCommand(Calendar startDate, Calendar endDate, List<String> prefixes) {
        this.startDate = startDate;
        this.endDate = endDate;

        if (prefixes.contains(CliSyntax.PREFIX_ARCHIVE.toString())) {
            showType = ShowType.ARCHIVE;
        } else if (prefixes.contains(CliSyntax.PREFIX_BIN.toString())) {
            showType = ShowType.BIN;
        } else if (prefixes.contains(CliSyntax.PREFIX_ALL.toString())) {
            showType = ShowType.ALL;
        } else {
            showType = ShowType.ACTIVE;
        }

        if (prefixes.contains(CliSyntax.PREFIX_REVERSE.toString())) {
            ordering = Ordering.REVERSE;
        } else if (prefixes.contains(CliSyntax.PREFIX_UPCOMING.toString())) {
            ordering = Ordering.UPCOMING;
        } else {
            ordering = Ordering.DEFAULT;
        }
    }

    @Override
    public CommandResult execute() {
        StringBuilder commandResultBuilder = new StringBuilder();

        switch (showType) {
        case ARCHIVE:
            commandResultBuilder.append(MESSAGE_ARCHIVE_SUCCESS);
            model.updateAllFilteredLists(MATCH_ALL_KEYWORDS, startDate, endDate, Entry.State.ARCHIVED,
                                         Model.LENIENT_SEARCHES);
            raise(new ListTypeUpdateEvent("archive"));
            history.setPrevSearch(MATCH_ALL_KEYWORDS, startDate, endDate, Entry.State.ARCHIVED,
                                  Model.LENIENT_SEARCHES);
            break;
        case BIN:
            commandResultBuilder.append(MESSAGE_BIN_SUCCESS);
            model.updateAllFilteredLists(MATCH_ALL_KEYWORDS, startDate, endDate, Entry.State.DELETED,
                                         Model.LENIENT_SEARCHES);
            raise(new ListTypeUpdateEvent("bin"));
            history.setPrevSearch(MATCH_ALL_KEYWORDS, startDate, endDate, Entry.State.DELETED,
                                  Model.LENIENT_SEARCHES);
            break;
        case ACTIVE:
            commandResultBuilder.append(MESSAGE_ACTIVE_SUCCESS);
            model.updateAllFilteredLists(MATCH_ALL_KEYWORDS, startDate, endDate, Entry.State.ACTIVE,
                                         Model.LENIENT_SEARCHES);
            raise(new ListTypeUpdateEvent("active"));
            history.setPrevSearch(MATCH_ALL_KEYWORDS, startDate, endDate, Entry.State.ACTIVE,
                                  Model.LENIENT_SEARCHES);
            break;
        case ALL:
            commandResultBuilder.append(MESSAGE_ALL_SUCCESS);
            model.updateAllFilteredLists(MATCH_ALL_KEYWORDS, startDate, endDate, (Entry.State) null,
                                         Model.LENIENT_SEARCHES);
            raise(new ListTypeUpdateEvent("all"));
            history.setPrevSearch(MATCH_ALL_KEYWORDS, startDate, endDate, null,
                                  Model.LENIENT_SEARCHES);
            break;
        default:
            throw new AssertionError("Unknown list show type");
        }

        switch (ordering) {
        case REVERSE:
            model.updateSortingComparators(Comparators.EVENT_REVERSE, Comparators.DEADLINE_REVERSE,
                    Comparators.FLOATING_TASK_REVERSE);
            commandResultBuilder.append(" ").append(MESSAGE_REVERSE_ORDER);
            return new CommandResult(commandResultBuilder.toString());
        case UPCOMING:
            model.updateSortingComparators(Comparators.EVENT_UPCOMING, Comparators.DEADLINE_UPCOMING,
                    Comparators.FLOATING_TASK_UPCOMING);
            commandResultBuilder.append(" ").append(MESSAGE_UPCOMING_ORDER);
            return new CommandResult(commandResultBuilder.toString());
        case DEFAULT:
            model.updateSortingComparators(Comparators.EVENT_DEFAULT, Comparators.DEADLINE_DEFAULT,
                    Comparators.FLOATING_TASK_DEFAULT);
            return new CommandResult(commandResultBuilder.toString());
        default:
            throw new AssertionError("Unknown list command ordering type");
        }
    }

    public boolean equals(ListCommand other) {
        return other != null
            && (this == other
            || (this.showType.equals(other.showType)
                && this.ordering.equals(other.ordering)
                && ((this.startDate != null && this.startDate.equals(other.startDate))
                    || (this.startDate == null && other.startDate == null))
                && ((this.endDate != null && this.endDate.equals(other.endDate))
                    || (this.endDate == null && other.endDate == null))));

    }

    private void raise(BaseEvent event) {
        EventsCenter.getInstance().post(event);
    }

    @Override
    public void setData(Model model, CommandHistory history) {
        requireNonNull(model);
        requireNonNull(history);
        this.model = model;
        this.history = history;
    }

}
```
###### \java\seedu\multitasky\logic\parser\ArgumentMultimap.java
``` java
    /**
     * Method to extract an ArrayList of specified prefixes that are present in the ArgumentMultimap
     */
    public ArrayList<String> getPresentPrefixes(String... prefixes) {
        ArrayList<String> presentPrefixes = new ArrayList<>();
        for (String prefix : prefixes) {
            if (getAllValues(new Prefix(prefix)).size() != 0) {
                presentPrefixes.add(prefix);
            }
        }
        return presentPrefixes;
    }

}
```
###### \java\seedu\multitasky\logic\parser\FindCommandParser.java
``` java
/**
 * Parses input arguments and creates a new FindCommand object
 */
public class FindCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * FindCommand and returns an FindCommand object for execution.
     *
     * @throws ParseException if the user input does not conform the expected format
     */
    public FindCommand parse(String args) throws ParseException {
        String trimmedArgs = args.trim();

        if (args.trim().isEmpty()) {
            throw new ParseException(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT,
                                                   FindCommand.MESSAGE_USAGE));
        }
        ArgumentMultimap argumentMultimap = ArgumentTokenizer.tokenize(trimmedArgs,
                                                                ParserUtil.toPrefixArray(FindCommand.VALID_PREFIXES));
        ArrayList<String> prefixesPresent = argumentMultimap.getPresentPrefixes(FindCommand.VALID_PREFIXES);
        if (!hasValidPrefixCombination(prefixesPresent)) {
            throw new ParseException(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT,
                                                   FindCommand.MESSAGE_USAGE));
        }
        Set<String> keywords;
        Optional<String> optKeywords = argumentMultimap.getPreamble();
        if (optKeywords.isPresent()) {
            keywords = new HashSet<>(Arrays.asList(optKeywords.get().split("\\s+")));
        } else {
            keywords = new HashSet<>();
        }
        Calendar startDate = getStartDate(argumentMultimap);
        Calendar endDate = getEndDate(argumentMultimap);

        return new FindCommand(keywords, startDate, endDate, prefixesPresent);
    }

    private Calendar getStartDate(ArgumentMultimap argumentMultimap) {
        return getDate(argumentMultimap.getValue(CliSyntax.PREFIX_FROM));
    }

    private Calendar getEndDate(ArgumentMultimap argumentMultimap) {
        return getDate(argumentMultimap.getValue(CliSyntax.PREFIX_TO));
    }

    private Calendar getDate(Optional<String> rawDate) {
        try {
            Calendar date = ParserUtil.parseDate(rawDate).get();
            return date;
        } catch (Exception e) {
            return null;
        }
    }

    private boolean hasValidPrefixCombination(ArrayList<String> prefixes) {
        // Cannot have any unknown prefixes
        if (!Arrays.asList(FindCommand.VALID_PREFIXES).containsAll(prefixes)) {
            return false;
        }
        // Check for invalid flag combinations
        if (prefixes.contains(CliSyntax.PREFIX_ARCHIVE.toString())
            && prefixes.contains(CliSyntax.PREFIX_BIN.toString())) {
            return false;
        }
        return true;
    }

}
```
###### \java\seedu\multitasky\logic\parser\ListCommandParser.java
``` java
/**
 * Parses input arguments and creates a new ListCommand object
 */
public class ListCommandParser {

    /** Parses the given arguments in the context of a list command.
     *
     * @param args the arguments for the list command in a single String
     * @return     the ListCommand object for execution
     * @throws ParseException if the user input does not confirm to the expected format
     */
    public ListCommand parse(String args) throws ParseException {
        if (args == null || args.trim().isEmpty()) {
            return new ListCommand();
        }
        String trimmedArgs = args.trim();
        ArgumentMultimap argumentMultimap = ArgumentTokenizer.tokenize(trimmedArgs,
                                                                ParserUtil.toPrefixArray(ListCommand.VALID_PREFIXES));
        ArrayList<String> prefixesPresent = argumentMultimap.getPresentPrefixes(ListCommand.VALID_PREFIXES);
        if (!hasValidPrefixCombination(prefixesPresent)) {
            throw new ParseException(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT,
                                                   ListCommand.MESSAGE_USAGE));
        }
        Calendar startDate = getStartDate(argumentMultimap);
        Calendar endDate = getEndDate(argumentMultimap);

        return new ListCommand(startDate, endDate, prefixesPresent);
    }

    private Calendar getStartDate(ArgumentMultimap argumentMultimap) {
        return getDate(argumentMultimap.getValue(CliSyntax.PREFIX_FROM));
    }

    private Calendar getEndDate(ArgumentMultimap argumentMultimap) {
        return getDate(argumentMultimap.getValue(CliSyntax.PREFIX_TO));
    }

    private Calendar getDate(Optional<String> rawDate) {
        try {
            Calendar date = ParserUtil.parseDate(rawDate).get();
            return date;
        } catch (Exception e) {
            return null;
        }
    }

    private boolean hasValidPrefixCombination(ArrayList<String> prefixes) {
        // Check for invalid flag combinations
        if (prefixes.contains(CliSyntax.PREFIX_ARCHIVE.toString())
            && prefixes.contains(CliSyntax.PREFIX_BIN.toString())) {
            return false;
        } else if (prefixes.contains(CliSyntax.PREFIX_UPCOMING.toString())
                   && prefixes.contains(CliSyntax.PREFIX_REVERSE.toString())) {
            return false;
        }
        return true;
    }

}
```
###### \java\seedu\multitasky\logic\parser\ParserUtil.java
``` java
    /**
     * converts a String array of prefixes into a Prefix array
     */
    public static Prefix[] toPrefixArray(String... stringPrefixes) {
        Prefix[] prefixes = new Prefix[stringPrefixes.length];
        for (int i = 0; i < stringPrefixes.length; ++i) {
            prefixes[i] = new Prefix(stringPrefixes[i]);
        }
        return prefixes;
    }

}
```
###### \java\seedu\multitasky\model\entry\DeadlineList.java
``` java
    public DeadlineList() {
        super();
        comparator = Comparators.DEADLINE_DEFAULT;
    }

```
###### \java\seedu\multitasky\model\entry\DeadlineList.java
``` java
    /**
     * Overrides updateEntry in DeadlineList to sort after updating in case start date was changed.
     *
     * @throws EntryNotFoundException if {@code target} could not be found in the list.
     * @throws DuplicateEntryException if {@code editedEntry} already exists in the list.
     */
    @Override
    public void updateEntry(ReadOnlyEntry target, ReadOnlyEntry editedEntry)
            throws DuplicateEntryException, EntryNotFoundException {
        super.updateEntry(target, editedEntry);
        sortInternalList();
    }

```
###### \java\seedu\multitasky\model\entry\EntryList.java
``` java
    /**
     * Sorts the internal list using the comparator stored inside the class
     */
    protected void sortInternalList() {
        Collections.sort(internalList, comparator);
    }

    // ========== Util Methods ==========

    /**
     * Sets the comparator for this list, and sorts it using the comparator.
     */
    public void setComparator(Comparator<ReadOnlyEntry> comparator) {
        this.comparator = comparator;
        sortInternalList();
    }

```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
    public EventList() {
        super();
        comparator = Comparators.EVENT_DEFAULT;
    }

```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
    /**
     * Updates an existing entry with the data of a given Entry.
     * The list is sorted after updating in case start date was changed.
     *
     * @throws EntryNotFoundException if {@code target} could not be found in the list.
     * @throws DuplicateEntryException if {@code editedEntry} already exists in the list.
     */
    @Override
    public void updateEntry(ReadOnlyEntry target, ReadOnlyEntry editedEntry)
            throws DuplicateEntryException, EntryNotFoundException {
        super.updateEntry(target, editedEntry);
        sortInternalList();
    }

```
###### \java\seedu\multitasky\model\entry\FloatingTaskList.java
``` java
    public FloatingTaskList() {
        super();
        comparator = Comparators.FLOATING_TASK_DEFAULT;
    }

```
###### \java\seedu\multitasky\model\entry\util\Comparators.java
``` java
/**
 * Utility class of different comparators to use when comparing two entries
 */
public class Comparators {

    /**
     * Default ordering in general is to have no change
     */
    public static final Comparator<ReadOnlyEntry> ENTRY_DEFAULT = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            if (!(entry1.getClass().equals(entry2.getClass()))) {
                throw new AssertionError("Both entries to compare must be the same type");
            }
            return 0;
        }
    };

    /**
     * Default ordering for events is by starting date and time, earliest first
     */
    public static final Comparator<ReadOnlyEntry> EVENT_DEFAULT = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            if (!(entry1 instanceof Event)) {
                throw new AssertionError("Event comparator must receive Event object as argument");
            }
            if (!(entry2 instanceof Event)) {
                throw new AssertionError("Event comparator must receive Event object as argument");
            }
            // Order by increasing starting date and time
            return entry1.getStartDateAndTime().compareTo(entry2.getStartDateAndTime());
        }
    };

    /**
     * Default ordering for deadlines is by ending date and time, earliest first
     */
    public static final Comparator<ReadOnlyEntry> DEADLINE_DEFAULT = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            if (!(entry1 instanceof Deadline)) {
                throw new AssertionError("Deadline comparator must receive Deadline object as argument");
            }
            if (!(entry2 instanceof Deadline)) {
                throw new AssertionError("Deadline comparator must receive Deadline object as argument");
            }
            // Order by increasing ending(deadline) date and time
            return entry1.getEndDateAndTime().compareTo(entry2.getEndDateAndTime());
        }
    };

    /**
     * Default ordering for floating tasks is the order in which they were added, earliest first
     */
    public static final Comparator<ReadOnlyEntry> FLOATING_TASK_DEFAULT = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            if (!(entry1 instanceof FloatingTask)) {
                throw new AssertionError("FloatingTask comparator must receive FloatingTask object as argument");
            }
            if (!(entry2 instanceof FloatingTask)) {
                throw new AssertionError("FloatingTask comparator must receive FloatingTask object as argument");
            }
            // No re-ordering of floating tasks
            return 0;
        }
    };

    /**
     * Reverse ordering for events is by starting date and time, latest first
     */
    public static final Comparator<ReadOnlyEntry> EVENT_REVERSE = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            if (!(entry1 instanceof Event)) {
                throw new AssertionError("Event comparator must receive Event object as argument");
            }
            if (!(entry2 instanceof Event)) {
                throw new AssertionError("Event comparator must receive Event object as argument");
            }
            // Order by increasing starting date and time
            return entry2.getStartDateAndTime().compareTo(entry1.getStartDateAndTime());
        }
    };

    /**
     * Reverse ordering for deadlines is by ending date and time, latest first
     */
    public static final Comparator<ReadOnlyEntry> DEADLINE_REVERSE = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            if (!(entry1 instanceof Deadline)) {
                throw new AssertionError("Deadline comparator must receive Deadline object as argument");
            }
            if (!(entry2 instanceof Deadline)) {
                throw new AssertionError("Deadline comparator must receive Deadline object as argument");
            }
            // Order by increasing ending(deadline) date and time
            return entry2.getEndDateAndTime().compareTo(entry1.getEndDateAndTime());
        }
    };

    /**
     * Reverse ordering for floating tasks is the order in which they were added, earliest first
     */
    public static final Comparator<ReadOnlyEntry> FLOATING_TASK_REVERSE = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            if (!(entry1 instanceof FloatingTask)) {
                throw new AssertionError("FloatingTask comparator must receive FloatingTask object as argument");
            }
            if (!(entry2 instanceof FloatingTask)) {
                throw new AssertionError("FloatingTask comparator must receive FloatingTask object as argument");
            }
            // No re-ordering of floating tasks
            return 0;
        }
    };

    /**
     * Upcoming ordering for events is to show events that are not over yet first,
     * followed by events that are over.
     */
    public static final Comparator<ReadOnlyEntry> EVENT_UPCOMING = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            if (!(entry1 instanceof Event)) {
                throw new AssertionError("Event comparator must receive Event object as argument");
            }
            if (!(entry2 instanceof Event)) {
                throw new AssertionError("Event comparator must receive Event object as argument");
            }
            Calendar currentTime = new GregorianCalendar();
            currentTime.setTime(new Date());
            if (entry1.getStartDateAndTime().before(currentTime)) {
                if (entry2.getStartDateAndTime().before(currentTime)) {
                    // Both events are in the past, perform normal sort relative to each other
                    return entry1.getStartDateAndTime().compareTo(entry2.getStartDateAndTime());
                } else {
                    // wrong order: entry1 should be after entry2 since it is in the past and entry2 is not
                    return 1;
                }
            } else if (entry2.getStartDateAndTime().before(currentTime)) {
                // correct order: entry2 should be after entry1 since it is in the past and entry1 is not
                return -1;
            } else {
                // Both events are upcoming, perform normal sort relative to each other
                return entry1.getStartDateAndTime().compareTo(entry2.getStartDateAndTime());
            }
        }
    };

    /**
     * Upcoming ordering for deadlines is to show deadlines that are not over yet first,
     * followed by deadlines that are over.
     */
    public static final Comparator<ReadOnlyEntry> DEADLINE_UPCOMING = new Comparator<ReadOnlyEntry>() {
        @Override
        public int compare(ReadOnlyEntry entry1, ReadOnlyEntry entry2) {
            if (!(entry1 instanceof Deadline)) {
                throw new AssertionError("Deadline comparator must receive Deadline object as argument");
            }
            if (!(entry2 instanceof Deadline)) {
                throw new AssertionError("Deadline comparator must receive Deadline object as argument");
            }
            Calendar currentTime = new GregorianCalendar();
            currentTime.setTime(new Date());
            if (entry1.getEndDateAndTime().before(currentTime)) {
                if (entry2.getEndDateAndTime().before(currentTime)) {
                    // Both deadlines are in the past, perform normal sort relative to each other
                    return entry1.getEndDateAndTime().compareTo(entry2.getEndDateAndTime());
                } else {
                    // wrong order: entry1 should be after entry2 since it is in the past and entry2 is not
                    return 1;
                }
            } else if (entry2.getEndDateAndTime().before(currentTime)) {
                // correct order: entry2 should be after entry1 since it is in the past and entry1 is not
                return -1;
            } else {
                // Both deadlines are upcoming, perform normal sort relative to each other
                return entry1.getEndDateAndTime().compareTo(entry2.getEndDateAndTime());
            }
        }
    };

    /**
     * Upcoming ordering for floating tasks is the order in which they were added
     */
    public static final Comparator<ReadOnlyEntry> FLOATING_TASK_UPCOMING = FLOATING_TASK_DEFAULT;
}
```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
    public void setComparators(Comparator<ReadOnlyEntry> eventComparator,
                               Comparator<ReadOnlyEntry> deadlineComparator,
                               Comparator<ReadOnlyEntry> floatingTaskComparator) {
        eventList.setComparator(eventComparator);
        deadlineList.setComparator(deadlineComparator);
        floatingTaskList.setComparator(floatingTaskComparator);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void updateAllFilteredLists(Set<String> keywords, Calendar startDate, Calendar endDate,
                                       Entry.State state, Search... searches) {
        List<Entry.State> states = new ArrayList<>(Arrays.asList(new Entry.State[] { state, null }));
        updateAllFilteredLists(keywords, startDate, endDate, states, searches);
    }

    @Override
    public void updateAllFilteredLists(Set<String> keywords, Calendar startDate, Calendar endDate,
                                       Entry.State state, Entry.State state2, Search... searches) {
        List<Entry.State> states = new ArrayList<>(Arrays.asList(new Entry.State[] { state, state2 }));
        updateAllFilteredLists(keywords, startDate, endDate, states, searches);
    }

    private void updateAllFilteredLists(Set<String> keywords, Calendar startDate, Calendar endDate,
                                        List<Entry.State> states, Search... searches) {
        NameDateStateQualifier qualifier;
        for (Search search : searches) {
            if (search == Search.POWER_AND || search == Search.POWER_OR) {
                for (int level = PowerMatch.MIN_LEVEL; level <= PowerMatch.MAX_LEVEL; ++level) {
                    qualifier = new NameDateStateQualifier(keywords, startDate, endDate, states, search,
                                                           level);
                    if (filteredResultNonZero(qualifier)) {
                        break; // No need to search further
                    }
                }
            } else {
                qualifier = new NameDateStateQualifier(keywords, startDate, endDate, states, search, -1);
                if (filteredResultNonZero(qualifier)) {
                    break; // No need to search further
                }
            }
        }
    }

    private boolean filteredResultNonZero(NameDateStateQualifier qualifier) {
        updateFilteredEventList(new PredicateExpression(qualifier));
        updateFilteredDeadlineList(new PredicateExpression(qualifier));
        updateFilteredFloatingTaskList(new PredicateExpression(qualifier));
        return ((getFilteredEventList().size()
                 + getFilteredDeadlineList().size()
                 + getFilteredFloatingTaskList().size()) > 0);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void updateFilteredFloatingTaskList(Set<String> keywords, Calendar startDate,
                                               Calendar endDate, Entry.State state, Search search,
                                               int level) {
        updateFilteredFloatingTaskList(new PredicateExpression(new NameDateStateQualifier(keywords,
                                                                                          startDate, endDate,
                                                                                          state, search,
                                                                                          level)));
    }

    /** Updates the sorting comparators used. */
    @Override
    public void updateSortingComparators(Comparator<ReadOnlyEntry> eventComparator,
                                         Comparator<ReadOnlyEntry> deadlineComparator,
                                         Comparator<ReadOnlyEntry> floatingTaskComparator) {
        entryBook.setComparators(eventComparator, deadlineComparator, floatingTaskComparator);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    /**
     * Represents a qualifier can check the presence of all keywords in the name
     * and tags of a ReadOnlyEntry, if a ReadOnlyEntry falls within a given date range,
     * and if a ReadOnlyEntry matches the required state.
     */
    private class NameDateStateQualifier implements Qualifier {

        protected Set<String> nameAndTagKeywords;
        protected Calendar startDate;
        protected Calendar endDate;
        protected List<Entry.State> states;
        protected Search search;
        protected int level;

        /**
         * Constructs the NameDateStateQualifier.
         *
         * @param nameAndTagKeywords the keywords to match against the entry's name and tags. cannot be null.
         * @param startDate the earliest date that will produce a match. if it is null then
         *                  there is no lower limit on the entry's date.
         * @param endDate   the latest date that will produce a match. if it is null then
         *                  there is no upper limit on the entry's date.
         * @param states    the required states to match against the entry's state. if it is null or empty
         *                  then entries of any state will match.
         * @param search    the type of search to use (AND, OR, POWER_AND, POWER_OR). cannot be null.
         */
        public NameDateStateQualifier(Set<String> nameAndTagKeywords,
                Calendar startDate, Calendar endDate,
                List<Entry.State> states, Search search, int level) {
            if (nameAndTagKeywords == null) {
                throw new AssertionError("nameAndTagKeywords for NameDateStateQualifier cannot be null");
            }
            if (search == null) {
                throw new AssertionError("search type for NameDateStateQualifier cannot be null");
            }
            if (states == null) {
                throw new AssertionError("States list cannot be null");
            }
            if (states.size() != 2) {
                throw new AssertionError("Number of state arguments to match must be 2");
            }

            this.nameAndTagKeywords = nameAndTagKeywords;
            this.startDate = startDate;
            this.endDate = endDate;
            this.states = states;
            this.search = search;
            this.level = level;
        }

        /**
         * Alternative constructor for just a single state
         */
        public NameDateStateQualifier(Set<String> nameAndTagKeywords,
                Calendar startDate, Calendar endDate,
                Entry.State state, Search search, int level) {
            this(nameAndTagKeywords, startDate, endDate,
                 new ArrayList<>(Arrays.asList(new Entry.State[] { state, null })), search, level);
        }

        @Override
        public boolean run(ReadOnlyEntry entry) {
            if (matchesState(entry) && matchesNameAndTagKeywords(entry)) {
                if (entry instanceof FloatingTask
                    || entry instanceof Deadline && isWithinRange(entry.getEndDateAndTime())
                    || entry instanceof Event && isWithinRange(entry.getStartDateAndTime())) {
                    return true;
                }
            }
            return false;
        }

        protected boolean matchesState(ReadOnlyEntry entry) {
            return ((states.get(0) == null && states.get(1) == null)
                    || ((states.get(0) != null && entry.getState().equals(states.get(0)))
                        || (states.get(1) != null && entry.getState().equals(states.get(1)))));
        }

        protected boolean matchesNameAndTagKeywords(ReadOnlyEntry entry) {
            String nameAndTags = parseWordsInNameAndTags(entry).trim().toLowerCase();
            switch (search) {
            case AND:
                for (String keyword : nameAndTagKeywords) {
                    if (!nameAndTags.contains(keyword.trim().toLowerCase())) {
                        return false;
                    }
                }
                return true;
            case OR:
                if (nameAndTagKeywords.size() == 0) {
                    return true;
                }
                for (String keyword : nameAndTagKeywords) {
                    if (nameAndTags.contains(keyword.trim().toLowerCase())) {
                        return true;
                    }
                }
                return false;
            case POWER_AND:
                for (String keyword : nameAndTagKeywords) {
                    if (!new PowerMatch().isMatch(level, keyword, nameAndTags)) {
                        return false;
                    }
                }
                return true;
            case POWER_OR:
            default:
                if (nameAndTagKeywords.size() == 0) {
                    return true;
                }
                for (String keyword : nameAndTagKeywords) {
                    if (new PowerMatch().isMatch(level, keyword, nameAndTags)) {
                        return true;
                    }
                }
                return false;
            }
        }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
        /**
         * Checks if the given date to check is within the start and end dates of this Qualifier.
         */
        protected boolean isWithinRange(Calendar checkDate) {
            if (startDate == null) {
                if (endDate == null) {
                    return true;
                } else {
                    return checkDate.compareTo(endDate) <= 0;
                }
            } else if (endDate == null) {
                return checkDate.compareTo(startDate) >= 0;
            } else {
                return (checkDate.compareTo(startDate) >= 0) && (checkDate.compareTo(endDate) <= 0);
            }
        }

    }

```
###### \java\seedu\multitasky\model\util\EntryBuilder.java
``` java
/**
 * A utility class containing methods to construct Event, Deadline or FloatingTask objects.
 */
public class EntryBuilder {

    public static final String DEFAULT_NAME = "defaultName";
    public static final String DEFAULT_TAGS = "defaultTag";

    /**
     * Builds an entry with the class-level default parameters
     */
    public static Entry build() {
        Entry entry;
        try {
            entry = build(DEFAULT_NAME, DEFAULT_TAGS);
            return entry;
        } catch (IllegalValueException e) {
            throw new AssertionError("Sample data cannot be invalid");
        }
    }

    /******************
     * Multi-builders *
     *****************/
    /**
     * Builds the appropriate Event, Deadline or FloatingTask object as a copy of {@code entryToCopy}.
     * @param entryToCopy the entry that data will be read from to create the new object
     * @return            a copy of {@code entryToCopy}
     */
    public static Entry build(final ReadOnlyEntry entryToCopy) {
        Objects.requireNonNull(entryToCopy);
        Entry entry = null;
        if (entryToCopy instanceof Event) {
            entry = new Event(entryToCopy);
        } else if (entryToCopy instanceof Deadline) {
            entry = new Deadline(entryToCopy);
        } else if (entryToCopy instanceof FloatingTask) {
            entry = new FloatingTask(entryToCopy);
        }

        return entry;
    }

    /******************
     * Event builders *
     *****************/
    /**
     * Builds an Event object from the provided arguments.
     * @param name             the name of the event
     * @param startDateAndTime the starting date and time of the event
     * @param endDateAndTime   the ending date and time of the event
     * @param tags             the tags associated with the event
     * @return                 the constructed Event object - returns a Deadline or FloatingTask object if
     *                         there are null Calendar parameters
     * @throws IllegalValueException if any of the arguments are invalid or if there is the combination of
     *                               non-null start date and null end date.
     */
    public static Entry build(String name, Calendar startDateAndTime, Calendar endDateAndTime, String... tags)
            throws IllegalValueException {
        return build(new Name(name), startDateAndTime, endDateAndTime, TagSetBuilder.getTagSet(tags));
    }

    /**
     * Builds an Event object from the provided arguments.
     * @param name             the name of the event
     * @param startDateAndTime the starting date and time of the event
     * @param endDateAndTime   the ending date and time of the event
     * @param tags             the tags associated with the event
     * @return                 the constructed Event object - returns a Deadline or FloatingTask object if
     *                         there are null Calendar parameters
     * @throws IllegalValueException if any of the arguments are invalid or if there is the combination of
     *                               non-null start date and null end date.
     */
    public static Entry build(String name, Calendar startDateAndTime, Calendar endDateAndTime, Set<Tag> tags)
            throws IllegalValueException {
        return build(new Name(name), startDateAndTime, endDateAndTime, tags);
    }

    /**
     * Builds an Event object from the provided arguments.
     * @param name             the name of the event
     * @param startDateAndTime the starting date and time of the event
     * @param endDateAndTime   the ending date and time of the event
     * @param tags             the tags associated with the event
     * @return                 the constructed Event object - returns a Deadline or FloatingTask object if
     *                         there are null Calendar parameters
     * @throws IllegalValueException if any of the arguments are invalid or if there is the combination of
     *                               non-null start date and null end date.
     */
    public static Entry build(Name name, Calendar startDateAndTime, Calendar endDateAndTime, String... tags)
            throws IllegalValueException {
        return build(name, startDateAndTime, endDateAndTime, TagSetBuilder.getTagSet(tags));
    }

    /**
     * Builds an Event object from the provided arguments.
     * @param name             the name of the event
     * @param startDateAndTime the starting date and time of the event
     * @param endDateAndTime   the ending date and time of the event
     * @param tags             the tags associated with the event
     * @return                 the constructed Event object - returns a Deadline or FloatingTask object if
     *                         there are null Calendar parameters
     * @throws IllegalValueException if any of the arguments are invalid or if there is the combination of
     *                               non-null start date and null end date.
     */
    public static Entry build(Name name, Calendar startDateAndTime, Calendar endDateAndTime, Set<Tag> tags)
            throws IllegalValueException {
        if (startDateAndTime == null) {
            if (endDateAndTime == null) {
                Entry entry = build(name, tags);
                return entry;
            } else {
                Entry entry = build(name, endDateAndTime, tags);
                return entry;
            }
        } else if (endDateAndTime != null) {
            Entry entry = new Event(name, startDateAndTime, endDateAndTime, tags);
            return entry;
        } else {
            throw new IllegalValueException("Wrong combination of non-null start date and null end date");
        }
    }

    /*********************
     * Deadline builders *
     ********************/
    /**
     * Builds a Deadline object from the provided arguments.
     * @param name             the name of the deadline
     * @param endDateAndTime   the date and time of the deadline
     * @param tags             the tags associated with the deadline
     * @return                 the constructed Deadline object - returns a FloatingTask object if
     *                         {@code endDateAndTime} is null
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(String name, Calendar endDateAndTime, String... tags)
            throws IllegalValueException {
        return build(new Name(name), endDateAndTime, TagSetBuilder.getTagSet(tags));
    }

    /**
     * Builds a Deadline object from the provided arguments.
     * @param name             the name of the deadline
     * @param endDateAndTime   the date and time of the deadline
     * @param tags             the tags associated with the deadline
     * @return                 the constructed Deadline object - returns a FloatingTask object if
     *                         {@code endDateAndTime} is null
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(String name, Calendar endDateAndTime, Set<Tag> tags)
            throws IllegalValueException {
        return build(new Name(name), endDateAndTime, tags);
    }

    /**
     * Builds a Deadline object from the provided arguments.
     * @param name             the name of the deadline
     * @param endDateAndTime   the date and time of the deadline
     * @param tags             the tags associated with the deadline
     * @return                 the constructed Deadline object - returns a FloatingTask object if
     *                         {@code endDateAndTime} is null
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(Name name, Calendar endDateAndTime, String... tags)
            throws IllegalValueException {
        return build(name, endDateAndTime, TagSetBuilder.getTagSet(tags));
    }

    /**
     * Builds a Deadline object from the provided arguments.
     * @param name             the name of the deadline
     * @param endDateAndTime   the date and time of the deadline
     * @param tags             the tags associated with the deadline
     * @return                 the constructed Deadline object - returns a FloatingTask object if
     *                         {@code endDateAndTime} is null
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(Name name, Calendar endDateAndTime, Set<Tag> tags)
            throws IllegalValueException {
        if (endDateAndTime == null) {
            return build(name, tags);
        } else {
            return new Deadline(name, endDateAndTime, tags);
        }
    }

    /*************************
     * FloatingTask builders *
     ************************/
    /**
     * Builds a FloatingTask object from the provided arguments.
     * @param name             the name of the floating task
     * @return                 the constructed FloatingTask object
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(String name) throws IllegalValueException {
        return build(new Name(name), TagSetBuilder.getTagSet());
    }

    /**
     * Builds a FloatingTask object from the provided arguments.
     * @param name             the name of the floating task
     * @return                 the constructed FloatingTask object
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(Name name) throws IllegalValueException {
        return build(name, TagSetBuilder.getTagSet());
    }

    /**
     * Builds a FloatingTask object from the provided arguments.
     * @param name             the name of the floating task
     * @param tags             the tags associated with the floating task
     * @return                 the constructed FloatingTask object
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(String name, String... tags) throws IllegalValueException {
        return build(new Name(name), TagSetBuilder.getTagSet(tags));
    }

    /**
     * Builds a FloatingTask object from the provided arguments.
     * @param name             the name of the floating task
     * @param tags             the tags associated with the floating task
     * @return                 the constructed FloatingTask object
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(String name, Set<Tag> tags) throws IllegalValueException {
        return build(new Name(name), tags);
    }

    /**
     * Builds a FloatingTask object from the provided arguments.
     * @param name             the name of the floating task
     * @param tags             the tags associated with the floating task
     * @return                 the constructed FloatingTask object
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(Name name, String... tags) throws IllegalValueException {
        return build(name, TagSetBuilder.getTagSet(tags));
    }

    /**
     * Builds a FloatingTask object from the provided arguments.
     * @param name             the name of the floating task
     * @param tags             the tags associated with the floating task
     * @return                 the constructed FloatingTask object
     * @throws IllegalValueException if any of the arguments are invalid
     */
    public static Entry build(Name name, Set<Tag> tags) throws IllegalValueException {
        return new FloatingTask(name, tags);
    }
}
```
###### \java\seedu\multitasky\ui\CommandBox.java
``` java
/**
 * Handles text input from the user into the command box.
 * Keeps a history of previous commands entered by the user to provide
 * Linux-style command history navigation.
 */
public class CommandBox extends UiPart<Region> {

    // Two tab presses in 0.5 second is considered double
    public static final int DOUBLE_TAB_PRESS_INTERVAL_MILLIS = 500;

    public static final String ERROR_STYLE_CLASS = "command-box-error";

    private static final String FXML = "CommandBox.fxml";

    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private final Logic logic;

    private TextAutocomplete autocomplete;
    private TextHistory commandHistory;

    private ResultDisplay resultDisplay;

    @FXML
    private TextField commandTextField;

    private Date tabPressTime;

    public CommandBox(Logic logic, ResultDisplay resultDisplay) {
        super(FXML);
        this.logic = logic;
        this.resultDisplay = resultDisplay;
        autocomplete = new CommandAutocomplete(CommandUtil.COMMAND_WORDS, CommandUtil.COMMAND_KEYWORDS,
                                               CommandUtil.PREFIX_ONLY_COMMANDS);
        commandHistory = new CommandHistory();
        tabPressTime = new Date();
        setCommandTextFieldFocus();
        onlyShowActiveEntries();
        setupCommandAutocompleteShortcut();
        setupCommandHistoryShortcuts();
        registerAsAnEventHandler(this);
    }

    public void setCommand(String command) {
        commandTextField.setText(command);
        commandTextField.positionCaret(commandTextField.getText().length());
    }

    public void requestFocus() {
        commandTextField.requestFocus();
    }

    /**
     * Calls the logic component to execute the command given by the string.
     */
    public void executeCommand(String command) {
        try {
            CommandResult commandResult = logic.execute(command);
            // process result of the command
            setStyleToIndicateCommandSuccess();
            logger.info("Result: " + commandResult.feedbackToUser);
            raise(new NewResultAvailableEvent(commandResult.feedbackToUser));
        } catch (CommandException | ParseException e) {
            // handle command failure
            setStyleToIndicateCommandFailure();
            logger.info("Invalid command: " + command);
            raise(new NewResultAvailableEvent(e.getMessage()));
        } catch (DuplicateEntryException e) {
            setStyleToIndicateCommandFailure();
            logger.info("Unable to add duplicate entry with command: " + command);
            raise(new NewResultAvailableEvent(e.getMessage()));
        }
    }

    @FXML
    private void handleCommandInputChanged() {
        commandHistory.save(getText());
        executeCommand(commandTextField.getText().trim());
        commandTextField.setText("");
    }

    /**
     * Requests focus on the command text field once the main UI window is open,
     * so that the user can immediately begin typing.
     */
    private void setCommandTextFieldFocus() {
        Platform.runLater(new Runnable() {
            public void run() {
                commandTextField.requestFocus();
            }
        });
    }

    /**
     * Executes an initial list command to show all active entries.
     */
    private void onlyShowActiveEntries() {
        try {
            logic.execute(ListCommand.COMMAND_WORD);
        } catch (Exception e) {
            throw new AssertionError("Initial list of active entries cannot throw exceptions");
        }
    }

    /**
     * Sets up the {@code TAB} key as the autocomplete keyboard shortcut.
     */
    private void setupCommandAutocompleteShortcut() {
        getRoot().addEventFilter(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent event) {
                if (event.getCode() == KeyCode.TAB) {
                    event.consume();
                    if (isDoubleTabPress()) {
                        String possibilities = autocomplete.getPossibilities(getText());
                        if (possibilities != null) {
                            raise(new NewResultAvailableEvent(possibilities));
                        }
                    } else {
                        setText(autocomplete.autocomplete(getText()));
                    }
                }
            }
        });
    }

    /**
     * Sets up the {@code UP} and {@code DOWN} arrow keys as shortcuts for the command history.
     */
    private void setupCommandHistoryShortcuts() {
        getRoot().addEventFilter(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent event) {
                if (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.KP_UP) {
                    event.consume();
                    setText(commandHistory.getPrevious(getText()));
                } else if (event.getCode() == KeyCode.DOWN || event.getCode() == KeyCode.KP_DOWN) {
                    event.consume();
                    setText(commandHistory.getNext(getText()));
                }
            }
        });
    }

    /**
     * Checks if this should be considered as a double tab press.
     */
    private boolean isDoubleTabPress() {
        Date now = new Date();
        if (now.getTime() - tabPressTime.getTime() <= DOUBLE_TAB_PRESS_INTERVAL_MILLIS) {
            return true;
        }
        tabPressTime = now;
        return false;
    }

    /**
     * Sets the command box style to indicate a successful command.
     */
    private void setStyleToIndicateCommandSuccess() {
        commandTextField.getStyleClass().remove(ERROR_STYLE_CLASS);
        resultDisplay.setStyleToIndicateCommandSuccess();
    }

    /**
     * Sets the result display style to indicate a failed command.
     */
    private void setStyleToIndicateCommandFailure() {
        ObservableList<String> styleClass = commandTextField.getStyleClass();
        if (!styleClass.contains(ERROR_STYLE_CLASS)) {
            styleClass.add(ERROR_STYLE_CLASS);
        }
        resultDisplay.setStyleToIndicateCommandFailure();
    }

    /**
     * Returns the text currently entered into the command box.
     */
    private String getText() {
        return commandTextField.getText().trim();
    }

    /**
     * Sets the command box text and positions the cursor at the end of the text.
     */
    private void setText(String text) {
        commandTextField.setText(text);
        commandTextField.positionCaret(commandTextField.getText().length());
    }

}
```
###### \java\seedu\multitasky\ui\DeadlineListPanel.java
``` java
/**
 * Panel containing the list of deadlines.
 */
public class DeadlineListPanel extends UiPart<Region> {
    private static final String FXML = "DeadlineListPanel.fxml";

    @FXML
    private ListView<ReadOnlyEntry> deadlineListView;

    public DeadlineListPanel(ObservableList<ReadOnlyEntry> deadlineList) {
        super(FXML);
        setConnections(deadlineList);
    }

    private void setConnections(ObservableList<ReadOnlyEntry> deadlineList) {
        deadlineListView.setItems(deadlineList);
        deadlineListView.setCellFactory(listView -> new DeadlineListViewCell());
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            deadlineListView.scrollTo(index);
            deadlineListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class DeadlineListViewCell extends ListCell<ReadOnlyEntry> {

        @Override
        protected void updateItem(ReadOnlyEntry entry, boolean empty) {
            super.updateItem(entry, empty);

            if (empty || entry == null) {
                setGraphic(null);
                setText(null);
            } else {
                int index = getIndex() + 1;
                assert index > 0 : "getIndex returned invalid index";

                Calendar current = new GregorianCalendar();
                // Deadline is over
                if (current.compareTo(entry.getEndDateAndTime()) > 0) {
                    setGraphic(new DeadlineOverdueCard(entry, index).getRoot());
                } else {
                    setGraphic(new DeadlineCard(entry, index).getRoot());
                }
            }
        }
    }

}
```
###### \java\seedu\multitasky\ui\EntryCard.java
``` java
/**
 * EntryCard implements a superclass for the different types of entry cards to inherit from.
 * This class is declared as abstract as the classes for each type of entry card
 * should be instantiated instead of a generic entry card.
 */
public abstract class EntryCard extends UiPart<Region> {

    /**
     * Note: Certain keywords such as "location" and "resources" are reserved keywords in JavaFX.
     * As a consequence, UI elements' variable names cannot be set to such keywords
     * or an exception will be thrown by JavaFX during runtime.
     *
     * @see <a href="https://github.com/se-edu/addressbook-level4/issues/336">The issue on AddressBook level 4</a>
     */

    @FXML
    protected HBox cardPane;
    @FXML
    protected Label name;
    @FXML
    protected Label id;
    @FXML
    protected Label startDateTime;
    @FXML
    protected Label endDateTime;
    @FXML
    protected Label additionalInfo;
    @FXML
    protected FlowPane tags;

    protected PrettyTime prettyTime;

    public EntryCard(String fxml, ReadOnlyEntry entry, int displayedIndex) {
        super(fxml);
        initAll(entry, displayedIndex);
        prettyTime = new PrettyTime();
    }

    protected void initAll(ReadOnlyEntry entry, int displayedIndex) {
        initNameId(entry, displayedIndex);
        initTags(entry);
    }

    protected void initNameId(ReadOnlyEntry entry, int displayedIndex) {
        name.setText(entry.getName().toString());
        id.setText(displayedIndex + ". ");
    }

    protected void initTags(ReadOnlyEntry entry) {
        entry.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }

    protected String prettyTimeFormatDate(Date date) {
        return prettyTime.format(date);
    }
}
```
###### \java\seedu\multitasky\ui\EventListPanel.java
``` java
/**
 * Panel containing the list of events.
 */
public class EventListPanel extends UiPart<Region> {
    private static final String FXML = "EventListPanel.fxml";

    @FXML
    private ListView<ReadOnlyEntry> eventListView;

    public EventListPanel(ObservableList<ReadOnlyEntry> eventList) {
        super(FXML);
        setConnections(eventList);
    }

    private void setConnections(ObservableList<ReadOnlyEntry> eventList) {
        eventListView.setItems(eventList);
        eventListView.setCellFactory(listView -> new EventListViewCell());
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            eventListView.scrollTo(index);
            eventListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class EventListViewCell extends ListCell<ReadOnlyEntry> {

        @Override
        protected void updateItem(ReadOnlyEntry entry, boolean empty) {
            super.updateItem(entry, empty);

            if (empty || entry == null) {
                setGraphic(null);
                setText(null);
            } else {
                int index = getIndex() + 1;
                assert index > 0 : "getIndex returned invalid index";

                Calendar current = new GregorianCalendar();
                // Event has already started
                if (current.compareTo(entry.getStartDateAndTime()) > 0) {
                    setGraphic(new EventOverdueCard(entry, index).getRoot());
                } else {
                    setGraphic(new EventCard(entry, index).getRoot());
                }
            }
        }
    }

}
```
###### \java\seedu\multitasky\ui\FloatingTaskListPanel.java
``` java
/**
 * Panel containing the list of floating tasks.
 */
public class FloatingTaskListPanel extends UiPart<Region> {
    private static final String FXML = "FloatingTaskListPanel.fxml";

    @FXML
    private ListView<ReadOnlyEntry> floatingTaskListView;

    public FloatingTaskListPanel(ObservableList<ReadOnlyEntry> floatingTaskList) {
        super(FXML);
        setConnections(floatingTaskList);
    }

    private void setConnections(ObservableList<ReadOnlyEntry> floatingTaskList) {
        floatingTaskListView.setItems(floatingTaskList);
        floatingTaskListView.setCellFactory(listView -> new FloatingTaskListViewCell());
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            floatingTaskListView.scrollTo(index);
            floatingTaskListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class FloatingTaskListViewCell extends ListCell<ReadOnlyEntry> {

        @Override
        protected void updateItem(ReadOnlyEntry entry, boolean empty) {
            super.updateItem(entry, empty);

            if (empty || entry == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(new FloatingTaskCard(entry, getIndex() + 1).getRoot());
            }
        }
    }

}
```
###### \java\seedu\multitasky\ui\MainWindow.java
``` java
/**
 * The Main Window. Provides the basic application layout containing
 * a menu bar and space where other JavaFX elements can be placed.
 */
public class MainWindow extends UiPart<Region> {

    private static final String ICON = "/images/calendar.png";
    private static final String FXML = "MainWindow.fxml";
    private static final int MIN_HEIGHT = 600;
    private static final int MIN_WIDTH = 450;

    private Stage primaryStage;
    private Logic logic;

    // Independent Ui parts residing in this Ui container
    private UserPrefs prefs;

    @FXML
    private MenuItem helpMenuItem;

    @FXML
    private Label stateCurrentlyShown;

    @FXML
    private StackPane eventListPanelPlaceholder;

    @FXML
    private StackPane deadlineListPanelPlaceholder;

    @FXML
    private StackPane floatingTaskListPanelPlaceholder;

    @FXML
    private StackPane resultDisplayPlaceholder;

    @FXML
    private StackPane commandBoxPlaceholder;
    private CommandBox commandBox;

    @FXML
    private StackPane statusbarPlaceholder;

    public MainWindow(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {
        super(FXML);

        // Set dependencies
        this.primaryStage = primaryStage;
        this.logic = logic;
        this.prefs = prefs;

        // Configure the UI
        setTitle(config.getAppTitle());
        setIcon(ICON);
        setWindowMinSize();
        setWindowDefaultSize(prefs);
        Scene scene = new Scene(getRoot());
        primaryStage.setScene(scene);

        setAccelerators();
        setCommandShortcuts();

        registerAsAnEventHandler(this);
    }

    public Stage getPrimaryStage() {
        return primaryStage;
    }

    private void setAccelerators() {
        setAccelerator(helpMenuItem, KeyCombination.valueOf("F1"));
    }

    private void setCommandShortcuts() {
        setCommandExecuteShortcut(UndoCommand.COMMAND_WORD,
                                  new KeyCodeCombination(KeyCode.Z, KeyCombination.CONTROL_DOWN));
        setCommandExecuteShortcut(RedoCommand.COMMAND_WORD,
                                  new KeyCodeCombination(KeyCode.Y, KeyCombination.CONTROL_DOWN));

        setCommandShortcut(EditCommand.COMMAND_WORD + " ", new KeyCodeCombination(KeyCode.F2));
        setCommandShortcut(FindCommand.COMMAND_WORD + " ", new KeyCodeCombination(KeyCode.F3));
        setCommandShortcut(ExitCommand.COMMAND_WORD + " ", new KeyCodeCombination(KeyCode.F4));
        setCommandShortcut(ListCommand.COMMAND_WORD + " ", new KeyCodeCombination(KeyCode.F5));
        setCommandShortcut(SaveCommand.COMMAND_WORD + " ",
                           new KeyCodeCombination(KeyCode.S, KeyCombination.CONTROL_DOWN));
        setCommandShortcut(OpenCommand.COMMAND_WORD + " ",
                           new KeyCodeCombination(KeyCode.O, KeyCombination.CONTROL_DOWN));

        setCommandBoxFocusShortcut(new KeyCodeCombination(KeyCode.F6));
    }

    /**
     * Sets the accelerator of a MenuItem.
     * @param keyCombination the KeyCombination value of the accelerator
     */
    private void setAccelerator(MenuItem menuItem, KeyCombination keyCombination) {
        menuItem.setAccelerator(keyCombination);
        getRoot().addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            if (event.getTarget() instanceof TextInputControl && keyCombination.match(event)) {
                menuItem.getOnAction().handle(new ActionEvent());
                event.consume();
            }
        });
    }

    /**
     * Sets up a command execute shortcut.
     * When the shortcut key combination is pressed, the command string is executed.
     */
    private void setCommandExecuteShortcut(String command, KeyCodeCombination keyCodeCombination) {
        getRoot().addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            if (keyCodeCombination.match(event)) {
                commandBox.executeCommand(command);
                event.consume();
            }
        });
    }

    /**
     * Sets up a command shortcut.
     * When the shortcut key combination is pressed, the command string is entered into the command box,
     * but not executed.
     */
    private void setCommandShortcut(String command, KeyCodeCombination keyCodeCombination) {
        getRoot().addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            if (keyCodeCombination.match(event)) {
                commandBox.setCommand(command);
                event.consume();
            }
        });
    }

    /**
     * Sets up the shortcut to bring the command box into focus
     */
    private void setCommandBoxFocusShortcut(KeyCodeCombination keyCodeCombination) {
        getRoot().addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            if (keyCodeCombination.match(event)) {
                commandBox.requestFocus();
                event.consume();
            }
        });
    }

    public void fillInnerParts() {
        stateCurrentlyShown.setText(String.format(Messages.MESSAGE_CURRENTLY_DISPLAYING, "active"));

        EventListPanel eventListPanel = new EventListPanel(logic.getFilteredEventList());
        eventListPanelPlaceholder.getChildren().add(eventListPanel.getRoot());

        DeadlineListPanel deadlineListPanel = new DeadlineListPanel(logic.getFilteredDeadlineList());
        deadlineListPanelPlaceholder.getChildren().add(deadlineListPanel.getRoot());

        FloatingTaskListPanel floatingTaskListPanel = new FloatingTaskListPanel(logic.getFilteredFloatingTaskList());
        floatingTaskListPanelPlaceholder.getChildren().add(floatingTaskListPanel.getRoot());

        ResultDisplay resultDisplay = new ResultDisplay();
        resultDisplayPlaceholder.getChildren().add(resultDisplay.getRoot());

        StatusBarFooter statusBarFooter = new StatusBarFooter(prefs.getEntryBookFilePath());
        statusbarPlaceholder.getChildren().add(statusBarFooter.getRoot());

        commandBox = new CommandBox(logic, resultDisplay);
        commandBoxPlaceholder.getChildren().add(commandBox.getRoot());

    }

    public void hide() {
        primaryStage.hide();
    }

    private void setTitle(String appTitle) {
        primaryStage.setTitle(appTitle);
    }

    /**
     * Sets the given image as the icon of the main window.
     * @param iconSource e.g. {@code "/images/help_icon.png"}
     */
    private void setIcon(String iconSource) {
        FxViewUtil.setStageIcon(primaryStage, iconSource);
    }

    /**
     * Sets the default size based on user preferences.
     */
    private void setWindowDefaultSize(UserPrefs prefs) {
        primaryStage.setHeight(prefs.getGuiSettings().getWindowHeight());
        primaryStage.setWidth(prefs.getGuiSettings().getWindowWidth());
        if (prefs.getGuiSettings().getWindowCoordinates() != null) {
            primaryStage.setX(prefs.getGuiSettings().getWindowCoordinates().getX());
            primaryStage.setY(prefs.getGuiSettings().getWindowCoordinates().getY());
        }
    }

    private void setWindowMinSize() {
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }

    /**
     * Returns the current size and the position of the main Window.
     */
    public GuiSettings getCurrentGuiSetting() {
        return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(),
                (int) primaryStage.getX(), (int) primaryStage.getY());
    }

    @FXML
    public void handleHelp() {
        HelpWindow helpWindow = new HelpWindow();
        helpWindow.show();
    }

    public void show() {
        primaryStage.show();
    }

    /**
     * Closes the application.
     */
    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }

    @Subscribe
    private void handleListTypeUpdateEvent(ListTypeUpdateEvent event) {
        stateCurrentlyShown.setText(String.format(Messages.MESSAGE_CURRENTLY_DISPLAYING, event.state));
    }

}
```
###### \java\seedu\multitasky\ui\util\CommandAutocomplete.java
``` java
/**
 * Provides autocomplete functionality for commands, using {@code PowerMatch} from
 * {@code seedu.multitasky.commons.util} to come up with matches.
 */
public class CommandAutocomplete implements TextAutocomplete {

    private TextAutocomplete commandWordAutocomplete;

    private List<String> commandWords;
    private Map<String, String[]> commandKeywords;
    private List<String> prefixOnlyCommands;

    private class SplitCommand {
        private String commandWord;
        private String remainder;

        public SplitCommand(String commandWord, String remainder) {
            this.commandWord = commandWord;
            this.remainder = remainder;
        }

        public String getCommandWord() {
            return commandWord;
        }

        public String getRemainder() {
            return remainder;
        }
    }

    public CommandAutocomplete(String[] commandWords, Map<String, String[]> commandKeywords,
                               String[] prefixOnlyCommands) {
        if (commandWords == null) {
            throw new AssertionError("commandWords cannot be null");
        }
        if (commandKeywords == null) {
            throw new AssertionError("commandKeywords cannot be null");
        }
        if (prefixOnlyCommands == null) {
            throw new AssertionError("prefixOnlyCommands cannot be null");
        }
        this.commandKeywords = commandKeywords;
        this.commandWords = Arrays.asList(commandWords);
        this.prefixOnlyCommands = Arrays.asList(prefixOnlyCommands);
        commandWordAutocomplete = new CommandWordAutocomplete(commandWords);
    }

    public String autocomplete(String input) {
        StringBuilder commandResult = new StringBuilder();
        SplitCommand splitCommand = split(input);
        String commandWordMatch = commandWordAutocomplete.autocomplete(splitCommand.getCommandWord());
        commandResult.append(commandWordMatch);

        // Managed to autocomplete to a valid command word
        if (commandWords.contains(commandWordMatch)) {
            commandResult.append(" ")
                         .append(autocompleteKeywords(commandWordMatch, splitCommand.getRemainder()));
        } else {
            if (!splitCommand.getRemainder().isEmpty()) {
                commandResult.append(" ").append(splitCommand.getRemainder());
            }
        }

        return commandResult.toString();
    }

    public String getPossibilities(String input) {
        StringBuilder possibilities = new StringBuilder();
        SplitCommand splitCommand = split(input);
        String commandWordPossibilities = commandWordAutocomplete.getPossibilities(splitCommand.getCommandWord());
        if (commandWordPossibilities != null) {
            possibilities.append(splitCommand.getCommandWord()).append(":  ").append(commandWordPossibilities);
            return possibilities.toString();
        }
        return null;
    }

    private String autocompleteKeywords(String commandWord, String remainder) {
        StringBuilder keywordsResult = new StringBuilder();
        if (remainder.isEmpty()) {
            return keywordsResult.toString();
        }
        // Keywords are separated by whitespace
        String[] keywords = remainder.split("\\s+");
        if (prefixOnlyCommands.contains(commandWord)) {
            for (int i = 0; i < keywords.length; ++i) {
                keywordsResult.append(new CommandKeywordAutocomplete(commandKeywords.get(commandWord))
                                            .autocomplete(keywords[i]))
                              .append(" ");
            }
        } else {
            for (int i = 0; i < keywords.length - 1; ++i) {
                keywordsResult.append(keywords[i]).append(" ");
            }
            keywordsResult.append(new CommandKeywordAutocomplete(commandKeywords.get(commandWord))
                                            .autocomplete(keywords[keywords.length - 1]))
                          .append(" ");
        }
        return keywordsResult.toString();
    }

    /**
     * Splits a command word from the rest of the input string.
     */
    private SplitCommand split(String command) {
        if (command.isEmpty()) {
            return new SplitCommand("", "");
        }
        // Command word should be followed by whitespace
        String[] words = command.split("\\s+");
        return new SplitCommand(words[0].trim(), command.substring(words[0].length()).trim());
    }

}
```
###### \java\seedu\multitasky\ui\util\CommandHistory.java
``` java
/**
 * Keeps track of the history of commands entered by the user into a text field.
 */
public class CommandHistory implements TextHistory {

    private Stack<String> commandPastStack;
    private Stack<String> commandFutureStack;

    private boolean isUserPreviouslyTypedCommandSaved;

    public CommandHistory() {
        commandPastStack = new Stack<>();
        commandFutureStack = new Stack<>();
        isUserPreviouslyTypedCommandSaved = false;
    }

    public void save(String text) {
        // First push all commands to the past
        while (!commandFutureStack.empty()) {
            commandPastStack.push(commandFutureStack.pop());
        }
        // Remove the previously saved user typed command if it wasn't executed
        if (isUserPreviouslyTypedCommandSaved) {
            isUserPreviouslyTypedCommandSaved = false;
            commandPastStack.pop();
        }
        // Save this command to the stack if it's the first, or if it's different from the last command
        if (text.length() > 0
            && (commandPastStack.empty() || !commandPastStack.peek().equals(text))) {
            commandPastStack.push(text);
        }
    }

    public String getPrevious(String current) {
        // A previous command doesn't exist
        if (commandPastStack.empty()) {
            return current;
        }
        // This is the first time in this run that the user requested the previous command,
        // Save previously typed command first if it is different from the previous entered command
        if (commandFutureStack.empty() && !commandPastStack.peek().equals(current)) {
            commandFutureStack.push(current);
            isUserPreviouslyTypedCommandSaved = true;
        }
        // Retrieve the previous command
        commandFutureStack.push(commandPastStack.pop());
        return commandFutureStack.peek();
    }

    public String getNext(String current) {
        // A newer command doesn't exist
        if (commandFutureStack.empty()) {
            return current;
        }
        commandPastStack.push(commandFutureStack.pop());
        // This is the newest command
        if (commandFutureStack.empty()) {
            commandFutureStack.push(commandPastStack.pop());
        }
        return commandFutureStack.peek();
    }

}
```
###### \java\seedu\multitasky\ui\util\CommandKeywordAutocomplete.java
``` java
/**
 * Provides autocomplete functionality for command keywords, using {@code PowerMatch} from
 * {@code seedu.multitasky.commons.util} to come up with matches.
 */
public class CommandKeywordAutocomplete implements TextAutocomplete {

    private List<String> commandKeywords;
    private int numCommandKeywords;

    private Matcher matcher = new PowerMatch();

    public CommandKeywordAutocomplete(String[] commandKeywords) {
        if (commandKeywords == null) {
            throw new AssertionError("commandKeywords cannot be null");
        }
        this.commandKeywords = Arrays.asList(commandKeywords);
        numCommandKeywords = commandKeywords.length;
    }

    public String autocomplete(String input) {
        String match = null;
        for (int level = PowerMatch.MIN_LEVEL; level <= PowerMatch.MAX_LEVEL; ++level) {
            match = matcher.match(level, input, commandKeywords.toArray(new String[numCommandKeywords]));
            if (match != null) {
                return match;
            }
        }
        return input;
    }

    @Override
    public String getPossibilities(String input) {
        return null;
    }

}
```
###### \java\seedu\multitasky\ui\util\CommandWordAutocomplete.java
``` java
/**
 * Provides autocomplete functionality for command words, using {@code PowerMatch} from
 * {@code seedu.multitasky.commons.util} to come up with matches.
 */
public class CommandWordAutocomplete implements TextAutocomplete {

    private List<String> commandWords;
    private int numCommandWords;

    private Matcher matcher = new PowerMatch();

    public CommandWordAutocomplete(String[] commandWords) {
        if (commandWords == null) {
            throw new AssertionError("commandWords cannot be null");
        }
        this.commandWords = Arrays.asList(commandWords);
        numCommandWords = commandWords.length;
    }

    public String autocomplete(String input) {
        String match = null;
        for (int level = PowerMatch.MIN_LEVEL; level <= PowerMatch.MAX_LEVEL; ++level) {
            match = matcher.match(level, input, commandWords.toArray(new String[numCommandWords]));
            if (match != null) {
                return match;
            }
        }
        return input;
    }

    @Override
    public String getPossibilities(String input) {
        StringBuilder possibilities = new StringBuilder();
        for (int level = PowerMatch.MIN_LEVEL; level <= PowerMatch.MAX_LEVEL; ++level) {
            for (String commandWord : commandWords) {
                if (matcher.isMatch(level, input, commandWord)) {
                    possibilities.append(commandWord).append("        ");
                }
            }
            if (!possibilities.toString().isEmpty() && possibilities.toString().split(" ").length > 1) {
                // Multiple possibilities
                return possibilities.toString();
            } else if (!possibilities.toString().isEmpty() && possibilities.toString().trim().indexOf(" ") == -1) {
                // Only one possibility, not relevant
                return null;
            }
            possibilities = new StringBuilder();
        }
        return null;
    }

}
```
###### \java\seedu\multitasky\ui\util\TextAutocomplete.java
``` java
/**
 * Interface class for a general text autocomplete class
 */
public interface TextAutocomplete {

    public String autocomplete(String input);

    public String getPossibilities(String input);

}
```
###### \java\seedu\multitasky\ui\util\TextHistory.java
``` java
/**
 * Interface class for a general text history class
 */
public interface TextHistory {

    public void save(String text);

    public String getPrevious(String current);

    public String getNext(String current);

}
```
###### \resources\view\DarkTheme.css
``` css
.event-card {
    -fx-outer-border: derive(#1d1d1d, 20%);
    -fx-body-color: linear-gradient(to bottom, #4c4c4c, #212121);
    -fx-background-color:
        -fx-outer-border,
        -fx-body-color;
    -fx-background-insets: 0, 4;
}

.event-overdue-card {
    -fx-outer-border: derive(#1d1d1d, 20%);
    -fx-body-color: linear-gradient(to bottom, #ff0000, #4c0000);
    -fx-background-color:
        -fx-outer-border,
        -fx-body-color;
    -fx-background-insets: 0, 4;
}

.deadline-card {
    -fx-outer-border: derive(#1d1d1d, 20%);
    -fx-body-color: linear-gradient(to bottom, #4c4c4c, #212121);
    -fx-background-color:
        -fx-outer-border,
        -fx-body-color;
    -fx-background-insets: 0, 4;
}

.deadline-overdue-card {
    -fx-outer-border: derive(#1d1d1d, 20%);
    -fx-body-color: linear-gradient(to bottom, #ff0000, #4c0000);
    -fx-background-color:
        -fx-outer-border,
        -fx-body-color;
    -fx-background-insets: 0, 4;
}

.floating-task-card {
    -fx-outer-border: derive(#1d1d1d, 20%);
    -fx-body-color: linear-gradient(to bottom, #4c4c4c, #212121);
    -fx-background-color:
        -fx-outer-border,
        -fx-body-color;
    -fx-background-insets: 0, 4;
}
```
###### \resources\view\DeadlineCard.fxml
``` fxml

<HBox id="cardPane" fx:id="cardPane" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <GridPane maxHeight="120.0" minHeight="120.0" prefHeight="120.0" stylesheets="@DarkTheme.css" HBox.hgrow="ALWAYS">
    <columnConstraints>
      <ColumnConstraints hgrow="SOMETIMES" minWidth="10" prefWidth="150" />
    </columnConstraints>
    <VBox alignment="CENTER_LEFT" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" styleClass="deadline-card" GridPane.columnIndex="0">
      <padding>
        <Insets bottom="5" left="15" right="5" top="5" />
      </padding>
      <HBox alignment="CENTER_LEFT" spacing="5">
        <Label fx:id="id" styleClass="cell_big_label">
          <minWidth>
            <!-- Ensures that the label text is never truncated -->
            <Region fx:constant="USE_PREF_SIZE" />
          </minWidth>
        </Label>
        <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
      </HBox>
         <Label fx:id="endDateTime" styleClass="cell_small_label" stylesheets="@DarkTheme.css" text="\$end_date_time" />
         <Label fx:id="additionalInfo" styleClass="cell_small_label" text="\$additional_info" />
      <FlowPane fx:id="tags" />
    </VBox>
      <rowConstraints>
         <RowConstraints />
      </rowConstraints>
  </GridPane>
</HBox>
```
###### \resources\view\DeadlineListPanel.fxml
``` fxml
<VBox xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <ListView fx:id="deadlineListView" maxHeight="1.7976931348623157E308" styleClass="pane-with-border" stylesheets="@DarkTheme.css" VBox.vgrow="ALWAYS" />
</VBox>
```
###### \resources\view\DeadlineOverdueCard.fxml
``` fxml

<HBox id="cardPane" fx:id="cardPane" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <GridPane maxHeight="120.0" minHeight="120.0" prefHeight="120.0" styleClass="event-overdue-pane-with-border" stylesheets="@DarkTheme.css" HBox.hgrow="ALWAYS">
    <columnConstraints>
      <ColumnConstraints hgrow="SOMETIMES" minWidth="10" prefWidth="150" />
    </columnConstraints>
    <VBox alignment="CENTER_LEFT" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" styleClass="deadline-overdue-card" stylesheets="@DarkTheme.css" GridPane.columnIndex="0">
      <padding>
        <Insets bottom="5" left="15" right="5" top="5" />
      </padding>
      <HBox alignment="CENTER_LEFT" spacing="5">
        <Label fx:id="id" styleClass="cell_big_label">
          <minWidth>
            <!-- Ensures that the label text is never truncated -->
            <Region fx:constant="USE_PREF_SIZE" />
          </minWidth>
        </Label>
        <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
      </HBox>
         <Label fx:id="endDateTime" styleClass="cell_small_label" stylesheets="@DarkTheme.css" text="\$end_date_time" />
         <Label fx:id="additionalInfo" styleClass="cell_small_label" text="\$additional_info" />
      <FlowPane fx:id="tags" />
    </VBox>
      <rowConstraints>
         <RowConstraints />
      </rowConstraints>
  </GridPane>
</HBox>
```
###### \resources\view\EventCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" prefWidth="150.0" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <GridPane maxHeight="120.0" minHeight="120.0" styleClass="floating-pane-with-border" stylesheets="@DarkTheme.css" HBox.hgrow="ALWAYS">
    <columnConstraints>
      <ColumnConstraints hgrow="SOMETIMES" minWidth="10" prefWidth="150" />
    </columnConstraints>
    <VBox alignment="CENTER_LEFT" maxHeight="120.0" minHeight="120.0" styleClass="event-card" GridPane.columnIndex="0">
      <padding>
        <Insets bottom="5" left="15" right="5" top="5" />
      </padding>
      <HBox alignment="CENTER_LEFT" spacing="5">
        <Label fx:id="id" styleClass="cell_big_label">
          <minWidth>
            <!-- Ensures that the label text is never truncated -->
            <Region fx:constant="USE_PREF_SIZE" />
          </minWidth>
        </Label>
        <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
      </HBox>
         <GridPane prefWidth="128.0">
           <columnConstraints>
             <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
               <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
           </columnConstraints>
           <rowConstraints>
             <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
           </rowConstraints>
            <children>
               <Label fx:id="startDateTime" styleClass="cell_small_label" stylesheets="@DarkTheme.css" text="\$start_date_time" />
               <Label fx:id="endDateTime" styleClass="cell_small_label" stylesheets="@DarkTheme.css" text="\$end_date_time" GridPane.columnIndex="1" />
            </children>
         </GridPane>
         <Label fx:id="additionalInfo" styleClass="cell_small_label" text="\$additional_info" />
      <FlowPane fx:id="tags" />
    </VBox>
      <rowConstraints>
         <RowConstraints />
      </rowConstraints>
  </GridPane>
</HBox>
```
###### \resources\view\EventListPanel.fxml
``` fxml
<VBox xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <ListView fx:id="eventListView" maxHeight="1.7976931348623157E308" styleClass="pane-with-border" stylesheets="@DarkTheme.css" VBox.vgrow="ALWAYS" />
</VBox>
```
###### \resources\view\EventOverdueCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <GridPane maxHeight="120.0" minHeight="120.0" prefHeight="120.0" HBox.hgrow="ALWAYS">
    <columnConstraints>
      <ColumnConstraints hgrow="SOMETIMES" minWidth="10" prefWidth="150" />
    </columnConstraints>
    <VBox alignment="CENTER_LEFT" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" styleClass="event-overdue-card" stylesheets="@DarkTheme.css" GridPane.columnIndex="0">
      <padding>
        <Insets bottom="5" left="15" right="5" top="5" />
      </padding>
      <HBox alignment="CENTER_LEFT" spacing="5">
        <Label fx:id="id" styleClass="cell_big_label">
          <minWidth>
            <!-- Ensures that the label text is never truncated -->
            <Region fx:constant="USE_PREF_SIZE" />
          </minWidth>
        </Label>
        <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
      </HBox>
         <GridPane>
            <columnConstraints>
               <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
               <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
            </columnConstraints>
            <rowConstraints>
               <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
            </rowConstraints>
            <children>
               <Label fx:id="startDateTime" styleClass="cell_small_label" stylesheets="@DarkTheme.css" text="\$start_date_time" />
               <Label fx:id="endDateTime" styleClass="cell_small_label" stylesheets="@DarkTheme.css" text="\$end_date_time" GridPane.columnIndex="1" />
            </children>
         </GridPane>
         <Label fx:id="additionalInfo" styleClass="cell_small_label" text="\$additional_info" />
      <FlowPane fx:id="tags" />
    </VBox>
      <rowConstraints>
         <RowConstraints />
      </rowConstraints>
  </GridPane>
</HBox>
```
###### \resources\view\FloatingTaskCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <GridPane maxHeight="120.0" minHeight="120.0" prefHeight="120.0" stylesheets="@DarkTheme.css" HBox.hgrow="ALWAYS">
    <columnConstraints>
      <ColumnConstraints hgrow="SOMETIMES" minWidth="10" prefWidth="150" />
    </columnConstraints>
    <VBox alignment="CENTER_LEFT" maxHeight="120.0" minHeight="120.0" prefHeight="120.0" styleClass="floating-task-card" GridPane.columnIndex="0">
      <padding>
        <Insets bottom="5" left="15" right="5" top="5" />
      </padding>
      <HBox alignment="CENTER_LEFT" spacing="5">
        <Label fx:id="id" styleClass="cell_big_label">
          <minWidth>
            <!-- Ensures that the label text is never truncated -->
            <Region fx:constant="USE_PREF_SIZE" />
          </minWidth>
        </Label>
        <Label fx:id="name" styleClass="cell_big_label" text="\$name" />
      </HBox>
      <FlowPane fx:id="tags" />
    </VBox>
      <rowConstraints>
         <RowConstraints />
      </rowConstraints>
  </GridPane>
</HBox>
```
###### \resources\view\FloatingTaskListPanel.fxml
``` fxml
<VBox xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <ListView fx:id="floatingTaskListView" maxHeight="1.7976931348623157E308" styleClass="pane-with-border" stylesheets="@DarkTheme.css" VBox.vgrow="ALWAYS" />
</VBox>
```
###### \resources\view\MainWindow.fxml
``` fxml

<VBox maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" prefHeight="777.0" prefWidth="1015.0" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
  <stylesheets>
    <URL value="@DarkTheme.css" />
    <URL value="@Extensions.css" />
  </stylesheets>

  <MenuBar VBox.vgrow="NEVER">
    <Menu mnemonicParsing="false" text="File">
      <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
    </Menu>
    <Menu mnemonicParsing="false" text="Help">
      <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
    </Menu>
  </MenuBar>
   <StackPane minHeight="30.0" prefHeight="150.0" prefWidth="200.0" styleClass="pane-with-border">
      <children>
         <Label fx:id="stateCurrentlyShown" alignment="CENTER_RIGHT" contentDisplay="RIGHT" text="\$stateCurrentlyShown" textAlignment="CENTER" />
      </children>
   </StackPane>
   <StackPane maxHeight="50.0" minHeight="50.0" prefHeight="50.0" styleClass="pane-with-border">
      <padding>
         <Insets bottom="5" left="10" right="10" top="5" />
      </padding>
      <children>
         <GridPane alignment="CENTER" StackPane.alignment="CENTER">
           <columnConstraints>
             <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
             <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
               <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
           </columnConstraints>
           <rowConstraints>
             <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
           </rowConstraints>
            <children>
               <Label alignment="CENTER" contentDisplay="CENTER" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="label-header" text="Events" textAlignment="CENTER" />
               <Label alignment="CENTER" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="label-header" text="Deadlines" GridPane.columnIndex="1" />
               <Label alignment="CENTER" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="label-header" text="Floating Tasks" GridPane.columnIndex="2" />
            </children>
         </GridPane>
      </children>
   </StackPane>
   <StackPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="pane-with-border" stylesheets="@DarkTheme.css">
      <padding>
         <Insets bottom="5" left="10" right="10" top="5" />
      </padding>
      <children>
         <GridPane gridLinesVisible="true" minHeight="100.0" prefHeight="1000.0" prefWidth="1000.0" styleClass="pane-with-border" stylesheets="@DarkTheme.css">
           <columnConstraints>
             <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
             <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
               <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
           </columnConstraints>
           <rowConstraints>
             <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
           </rowConstraints>
            <children>
               <StackPane fx:id="eventListPanelPlaceholder" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" prefWidth="331.0" styleClass="pane-with-border" stylesheets="@DarkTheme.css" />
               <StackPane fx:id="deadlineListPanelPlaceholder" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="pane-with-border" stylesheets="@DarkTheme.css" GridPane.columnIndex="1" />
               <StackPane fx:id="floatingTaskListPanelPlaceholder" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" styleClass="pane-with-border" stylesheets="@DarkTheme.css" GridPane.columnIndex="2" />
            </children>
         </GridPane>
      </children>
   </StackPane>

  <StackPane fx:id="resultDisplayPlaceholder" maxHeight="100" minHeight="100" prefHeight="100" styleClass="pane-with-border" VBox.vgrow="NEVER">
    <padding>
      <Insets bottom="5" left="10" right="10" top="5" />
    </padding>
  </StackPane>

  <StackPane fx:id="commandBoxPlaceholder" styleClass="pane-with-border" VBox.vgrow="NEVER">
    <padding>
      <Insets bottom="5" left="10" right="10" top="5" />
    </padding>
  </StackPane>

  <StackPane fx:id="statusbarPlaceholder" maxHeight="30.0" minHeight="30.0" prefHeight="30.0" styleClass="pane-without-border" VBox.vgrow="NEVER" />
</VBox>
```
