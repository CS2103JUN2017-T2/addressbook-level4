# A0126623L
###### \java\seedu\multitasky\logic\commands\ClearCommand.java
``` java
/**
 * Clears the entry book.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Clear entries in the entry book. " + "\n"
                                               + "Format: " + COMMAND_WORD
                                               + " [" + CliSyntax.PREFIX_ARCHIVE + " | "
                                               + CliSyntax.PREFIX_BIN + " | "
                                               + CliSyntax.PREFIX_ALL + "]" + "\n"
                                               + "Example: " + COMMAND_WORD + " " + CliSyntax.PREFIX_BIN;

    public static final String MESSAGE_ALL_SUCCESS = "Entry book has been cleared!";

    public static final String MESSAGE_ACTIVE_SUCCESS = "Active entries have been cleared!";

    public static final String MESSAGE_ARCHIVE_SUCCESS = "Archive has been cleared!";

    public static final String MESSAGE_BIN_SUCCESS = "Bin has been cleared!";

    public static final int NUMBER_ALLOWABLE_PREFIX = 1;

    public static final String[] VALID_PREFIXES = { CliSyntax.PREFIX_ACTIVE.toString(),
        CliSyntax.PREFIX_ARCHIVE.toString(),
        CliSyntax.PREFIX_BIN.toString(),
        CliSyntax.PREFIX_ALL.toString() };

    public enum ClearType {
        ACTIVE, ARCHIVE, BIN, ALL
    }

    private ClearType clearType;

    public ClearCommand() {
        clearType = ClearType.ACTIVE;
    }

```
###### \java\seedu\multitasky\logic\commands\ClearCommand.java
``` java
    public ClearCommand(String prefix) {
        /*
         * TODO: Consider better ways than using multiple if-else?
         */
        if (prefix.equals(CliSyntax.PREFIX_ALL.toString())) {
            clearType = ClearType.ALL;
        } else if (prefix.equals(CliSyntax.PREFIX_ARCHIVE.toString())) {
            clearType = ClearType.ARCHIVE;
        } else if (prefix.equals(CliSyntax.PREFIX_BIN.toString())) {
            clearType = ClearType.BIN;
        } else if (prefix.equals(CliSyntax.PREFIX_ACTIVE.toString())) {
            clearType = ClearType.ACTIVE;
        } else {
            throw new AssertionError("ClearCommand constructor shouldn't reach this point.");
        }
    }
```
###### \java\seedu\multitasky\logic\commands\ClearCommand.java
``` java
    @Override
    public CommandResult execute() {
        requireNonNull(model);

        switch (clearType) {
        case ALL:
            model.resetData(new EntryBook());
            return new CommandResult(MESSAGE_ALL_SUCCESS);
        case ACTIVE:
            model.clearStateSpecificEntries(Entry.State.ACTIVE);
            return new CommandResult(MESSAGE_ACTIVE_SUCCESS);
        case ARCHIVE:
            model.clearStateSpecificEntries(Entry.State.ARCHIVED);
            return new CommandResult(MESSAGE_ARCHIVE_SUCCESS);
        case BIN:
            model.clearStateSpecificEntries(Entry.State.DELETED);
            return new CommandResult(MESSAGE_BIN_SUCCESS);
        default:
            throw new AssertionError("Unknown clear command option given.");
        }
    }
```
###### \java\seedu\multitasky\logic\commands\RestoreByFindCommand.java
``` java
    /**
     * Collates all archived and deleted entries that matches search keywords.
     * @return List of matched entries
     */
    private List<ReadOnlyEntry> collateArchivedAndDeletedEntries() {

        List<ReadOnlyEntry> allList = new ArrayList<>();
        List<Entry.State> states = new ArrayList<>();
        states.add(Entry.State.ARCHIVED);
        states.add(Entry.State.DELETED);

        // Filter and collate archived and deleted entries that matches keywords
        model.updateAllFilteredLists(keywords, null, null, states, Model.STRICT_SEARCHES);
        allList.addAll(model.getFilteredDeadlineList());
        allList.addAll(model.getFilteredEventList());
        allList.addAll(model.getFilteredFloatingTaskList());

        return allList;
    }
```
###### \java\seedu\multitasky\logic\parser\ClearCommandParser.java
``` java
/**
 * Parses input arguments and creates an appropriate ClearCommand object.
 */
public class ClearCommandParser {

```
###### \java\seedu\multitasky\logic\parser\ClearCommandParser.java
``` java
    /** Parses the given arguments in the context of a clear command.
     *
     * @param args the arguments for the clear command in a single String
     * @return     the ClearCommand object for execution
     * @throws ParseException if the user input does not conform to the expected format
     */
    public ClearCommand parse(String args) throws ParseException {

        String trimmedArgs = args.trim();

        if (trimmedArgs.isEmpty()) {
            return new ClearCommand();
        }

        /*
         * TODO modify ArgumentTokenizer to be able to detect without needing a whitespace in front of
         * trimmedArgs
         */
        ArgumentMultimap argumentMultimap = ArgumentTokenizer.tokenize(" " + trimmedArgs,
                                                                       toPrefixArray(ClearCommand.VALID_PREFIXES));

        ArrayList<String> prefixesPresent = argumentMultimap.getPresentPrefixes(ClearCommand.VALID_PREFIXES);
        if (!hasValidPrefixNumber(prefixesPresent)) {
            throw new ParseException(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT,
                                                   ClearCommand.MESSAGE_USAGE));
        }

        return new ClearCommand(prefixesPresent.get(0));
    }
```
###### \java\seedu\multitasky\logic\parser\ClearCommandParser.java
``` java
    private boolean hasValidPrefixNumber(ArrayList<String> prefixes) {
        return (prefixes.size() == ClearCommand.NUMBER_ALLOWABLE_PREFIX);
    }
```
###### \java\seedu\multitasky\model\entry\Deadline.java
``` java
public class Deadline extends Entry implements OverdueCapable {

    private Calendar _startDateAndTime;
    private Calendar _endDateAndTime;

    /**
     * Every field must be present and not null.
     */
    public Deadline(Name name, Calendar endDateAndTime, Set<Tag> tags) {
        super(name, tags);
        requireAllNonNull(endDateAndTime);
        _startDateAndTime = null;
        this.setEndDateAndTime(endDateAndTime);
    }

    /**
     * Creates a copy of the given ReadOnlyEntry.
     * @param source must be type Deadline.
     */
    public Deadline(ReadOnlyEntry source) {
        super(source.getName(), source.getTags());

        // Checks if source has an end time.
        assert (source instanceof Deadline) : "Deadline construction failed.";
        requireAllNonNull(source.getEndDateAndTime());
        setEndDateAndTime(source.getEndDateAndTime());
    }

    /**
     * Updates this entry with the details of {@code replacement}.
     * @param replacement must be of type Deadline.
     */
    @Override
    public void resetData(ReadOnlyEntry replacement) {
        super.resetData(replacement);

        assert (replacement instanceof Deadline);
        setEndDateAndTime(replacement.getEndDateAndTime());
    }

    public String getStartDateAndTimeString() {
        return null; // Deadlines has no start time.
    }

    @Override
    public Calendar getStartDateAndTime() {
        return _startDateAndTime; // Deadlines has no start time.
    }

    public void setEndDateAndTime(Calendar endDateAndTime) {
        _endDateAndTime = endDateAndTime;

        // Ignore difference in millisecond and seconds
        _endDateAndTime.set(Calendar.MILLISECOND, 0);
        _endDateAndTime.set(Calendar.SECOND, 0);
    }

    public String getEndDateAndTimeString() {
        return dateFormatter.format(getEndDateAndTime().getTime());
    }

    @Override
    public Calendar getEndDateAndTime() {
        return _endDateAndTime;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
               || this.isSameStateAs((ReadOnlyEntry) other);
    }

```
###### \java\seedu\multitasky\model\entry\Deadline.java
``` java
    @Override
    public boolean isSameStateAs(ReadOnlyEntry other) {
        return (other instanceof Deadline
                && this.getName().equals(other.getName()) // instanceof handles nulls
                && this.getEndDateAndTime().equals(other.getEndDateAndTime())
                && this.getState().equals(other.getState())
                && this.getTags().equals(other.getTags()));
    }
```
###### \java\seedu\multitasky\model\entry\Deadline.java
``` java
    @Override
    public boolean isOverdue() {
        if (!(this.isActive())) {
            return false;
        }

        Calendar currentCalendar = Calendar.getInstance();
        return ((this.getEndDateAndTime().compareTo(currentCalendar)) < 0);
    }
```
###### \java\seedu\multitasky\model\entry\Deadline.java
``` java
    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();

        // TODO: Include state in string?
        builder.append(getName())
               .append(" Deadline: ")
               .append(dateFormatter.format(getEndDateAndTime().getTime()))
               .append(" Tags: ");
        getTags().forEach(builder::append);
        return builder.toString();
    }
```
###### \java\seedu\multitasky\model\entry\DeadlineList.java
``` java
/**
 * A list of Deadline objects that does not allow nulls.
 */
public class DeadlineList extends EntryList {

```
###### \java\seedu\multitasky\model\entry\DeadlineList.java
``` java
    /**
     * Adds a deadline reference to the list.
     * Pre-condition: toAdd is not null and is of type Deadline.
     *
     * @throws DuplicateEntryException if {@code toAdd} already exists in the list.
     */
    @Override
    public void add(ReadOnlyEntry toAdd) throws DuplicateEntryException {
        super.add(toAdd);
        if (!(toAdd instanceof Deadline)) {
            throw new AssertionError("Non-Deadline type cannot be added to an DeadlineList.");
        }

        internalList.add((Deadline) toAdd);
        sortInternalList();
    }

```
###### \java\seedu\multitasky\model\entry\DeadlineList.java
``` java
    /**
     * Clears the current list of deadlines and add all elements from the list of entries given.
     *
     * @param entries must be a list of deadlines.
     */
    public void setEntries(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        final DeadlineList replacement = new DeadlineList();
        for (final ReadOnlyEntry entry : entries) {
            replacement.add(entry);     // Type check is done within add().
        }
        super.setEntries(replacement);
    }
```
###### \java\seedu\multitasky\model\entry\Entry.java
``` java
    /**
     * Date formatter for subclasses that need to format Date objects.
     */
    protected static DateFormat dateFormatter = DateFormat.getDateTimeInstance(DateFormat.MEDIUM,
                                                                               DateFormat.SHORT);
```
###### \java\seedu\multitasky\model\entry\EntryList.java
``` java
    /**
     * Adds an entry to the list.
     *
     * @throws DuplicateEntryException if {@code toAdd} already exists in the list.
     */
    public void add(ReadOnlyEntry toAdd) throws DuplicateEntryException {
        requireNonNull(toAdd);
        if (contains(toAdd)) {
            if (!isArchivedOrDeletedFloatingTask(toAdd)) {
                throw new DuplicateEntryException();
            }
        }
    };
```
###### \java\seedu\multitasky\model\entry\EntryList.java
``` java
    /**
     * Changes the state (i.e. ACTIVE, ARCHIVED, DELETED) of an existing entry to {@code newState}.
     * @param entryToChange
     * @param newState
     * @throws DuplicateEntryException, EntryNotFoundException
     */
    public void changeEntryState(ReadOnlyEntry entryToChange, Entry.State newState)
            throws DuplicateEntryException, EntryNotFoundException {
        Entry editedEntry = EntryBuilder.build(entryToChange);
        editedEntry.setState(newState);
        this.updateEntry(entryToChange, editedEntry);
    }

    /**
     * Clears the current list of entries and add all elements from replacement.
     * The updated list of entries will contain the references to the elements in {@code replacement}.
     * @param replacement
     */
    public void setEntries(EntryList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    /**
     * Resets the data of the entry {@code target} in the list with that of the {@code editedEntry}.
     *
     * @throws EntryNotFoundException if {@code target} could not be found in the list.
     * @throws DuplicateEntryException if {@code editedEntry} already exists in the list.
     */
    public void updateEntry(ReadOnlyEntry target, ReadOnlyEntry editedEntry)
            throws DuplicateEntryException, EntryNotFoundException {
        requireNonNull(editedEntry);

        int index = internalList.indexOf(target);
        if (index == -1) {
            throw new EntryNotFoundException();
        }

        Entry entryToUpdate = internalList.get(index);

        if (internalList.contains(editedEntry)) {
            if (!isArchivedOrDeletedFloatingTask(editedEntry)) {
                throw new DuplicateEntryException();
            }
        }

        entryToUpdate.resetData(editedEntry);
        // TODO: The code below is just a workaround to notify observers of the
        // updated entry.
        // The right way is to implement observable properties in the Entry class.
        // Then, EntryCard should then bind its text labels to those observable properties.
        internalList.set(index, entryToUpdate);
    }

```
###### \java\seedu\multitasky\model\entry\EntryList.java
``` java
    /**
     * Checks if the given entry is a floating task with the "archived" or "deleted" status, which is allowed in model.
     *
     * @param entry must not be null.
     * @return boolean
     */
    public static boolean isArchivedOrDeletedFloatingTask(ReadOnlyEntry entry) {
        Objects.requireNonNull(entry);
        return (entry instanceof FloatingTask
                && (entry.getState().equals(Entry.State.ARCHIVED)
                    || entry.getState().equals(Entry.State.DELETED)));
    }
```
###### \java\seedu\multitasky\model\entry\EntryList.java
``` java

```
###### \java\seedu\multitasky\model\entry\Event.java
``` java
public class Event extends Entry implements OverdueCapable {

    private Calendar _startDateAndTime;
    private Calendar _endDateAndTime;

    /**
     * Every field must be present and not null.
     * Events are instantiated to be active events by default.
     * @param name
     * @param startDateAndTime
     * @param endDateAndTime
     * @param state
     * @param tags
     */
    public Event(Name name, Calendar startDateAndTime, Calendar endDateAndTime, Set<Tag> tags) {
        super(name, tags);
        requireAllNonNull(startDateAndTime, endDateAndTime);
        this.setStartDateAndTime(startDateAndTime);
        this.setEndDateAndTime(endDateAndTime);
    }

    /**
     * Creates a copy of the given ReadOnlyEntry.
     * @param source must be of type Event.
     */
    public Event(ReadOnlyEntry source) {
        super(source.getName(), source.getTags());

        // Checks if source has start and end time.
        requireAllNonNull(source.getStartDateAndTime(), source.getEndDateAndTime());

        setStartDateAndTime(source.getStartDateAndTime());
        setEndDateAndTime(source.getEndDateAndTime());
    }

    /**
     * Updates this entry with the details of {@code replacement}.
     * Pre-condition: ReadOnlyEntry must be type Event.
     */
    @Override
    public void resetData(ReadOnlyEntry replacement) {
        super.resetData(replacement);

        assert (replacement instanceof Event);
        setStartDateAndTime(replacement.getStartDateAndTime());
        setEndDateAndTime(replacement.getEndDateAndTime());
    }

    private void setStartDateAndTime(Calendar startDateAndTime) {
        _startDateAndTime = startDateAndTime;

        // Ignore difference in millisecond and seconds
        _startDateAndTime.set(Calendar.MILLISECOND, 0);
        _startDateAndTime.set(Calendar.SECOND, 0);
    }

    public String getStartDateAndTimeString() {
        return dateFormatter.format(getStartDateAndTime().getTime());
    }

    @Override
    public Calendar getStartDateAndTime() {
        return _startDateAndTime;
    }

    public void setEndDateAndTime(Calendar endDateAndTime) {
        _endDateAndTime = endDateAndTime;

        // Ignore difference in millisecond and seconds
        _endDateAndTime.set(Calendar.MILLISECOND, 0);
        _endDateAndTime.set(Calendar.SECOND, 0);
    }

    public String getEndDateAndTimeString() {
        return dateFormatter.format(getEndDateAndTime().getTime());
    }

    @Override
    public Calendar getEndDateAndTime() {
        return _endDateAndTime;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
               || this.isSameStateAs((ReadOnlyEntry) other);
    }

    @Override
    public boolean isSameStateAs(ReadOnlyEntry other) {
        return (other instanceof Event && this.getName().equals(other.getName()) // instanceof handles nulls
                && this.getStartDateAndTime().equals(other.getStartDateAndTime())
                && this.getEndDateAndTime().equals(other.getEndDateAndTime())
                && this.getState().equals(other.getState())
                && this.getTags().equals(other.getTags()));
    }

```
###### \java\seedu\multitasky\model\entry\Event.java
``` java
    /**
     * Checks whether a given {@code event}'s time overlaps with this {@code event}'s.
     * @param {@code entry} must be an event.
     * @return boolean
     */
    public boolean hasOverlappingTime(ReadOnlyEntry other) {
        if (!(other instanceof Event)) {
            throw new AssertionError("Non-event object is given to Event.hasOverlappingTime().");
        }

        if (!(this.isActive())) {
            return false;
        }

        return !(other.getEndDateAndTime().compareTo(this.getStartDateAndTime()) < 0
                 || other.getStartDateAndTime().compareTo(this.getEndDateAndTime()) > 0);
    }
```
###### \java\seedu\multitasky\model\entry\Event.java
``` java
    @Override
    public boolean isOverdue() {
        if (!(this.isActive())) {
            return false;
        }

        Calendar currentCalendar = Calendar.getInstance();
        return ((this.getEndDateAndTime().compareTo(currentCalendar)) < 0
                || (this.getStartDateAndTime().compareTo(currentCalendar) < 0));

    }
```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
/**
 * A list of Event objects that does not allow nulls.
 */
public class EventList extends EntryList {

```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
    /**
     * Adds an event's reference to the list.
     *
     * @param toAdd is of type Event and must not be null.
     * @throws DuplicateEntryException if {@code toAdd} already exists in the list.
     */
    @Override
    public void add(ReadOnlyEntry toAdd) throws DuplicateEntryException {
        super.add(toAdd);

        if (!(toAdd instanceof Event)) {
            throw new AssertionError("Non-Event type cannot be added to an EventList.");
        }

        internalList.add((Event) toAdd);
        sortInternalList();
    }
```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
    /**
     * Checks if a given event has overlapping time with any existing active events in the event list.
     */
    public boolean hasOverlappingEvent(ReadOnlyEntry other) {
        for (Entry existingEntry : internalList) {
            assert (existingEntry instanceof Event) : "Non-event should not exist in an event list.";
            Event existingEvent = (Event) existingEntry;

            if (existingEvent.isActive()
                && existingEvent.hasOverlappingTime(other)) {
                return true;
            }
        }
        return false;
    }
```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
    /**
     * Checks if a given event will have overlapping time with any existing active events in the
     * event list after being updated.
     */
    public boolean hasOverlappingEventAfterUpdate(ReadOnlyEntry target, ReadOnlyEntry prospectiveEntry) {
        for (Entry existingEntry : internalList) {
            assert (existingEntry instanceof Event) : "Non-event should not exist in an event list.";
            Event existingEvent = (Event) existingEntry;

            if (existingEvent.isActive()
                && existingEvent.hasOverlappingTime(prospectiveEntry)
                && !(existingEvent.equals(target))) {
                return true;
            }
        }
        return false;
    }
```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
    /**
     * Clears the current list of events and add all elements from the list of entries given.
     *
     * @param entries must be a list of events.
     */
    public void setEntries(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        final EventList replacement = new EventList();
        for (final ReadOnlyEntry entry : entries) {
            replacement.add(entry);     // Type check is done within add().
        }
        super.setEntries(replacement);
    }
```
###### \java\seedu\multitasky\model\entry\exceptions\OverlappingEventException.java
``` java
/**
 * Signals that the operation results in overlapping events.
 */
public class OverlappingEventException extends Exception {
}
```
###### \java\seedu\multitasky\model\entry\FloatingTask.java
``` java
    /**
     * Compares the state with another Floating Task.
     */
    @Override
    public boolean isSameStateAs(ReadOnlyEntry other) {
        return (other instanceof FloatingTask // instanceof handles nulls
                && this.getName().equals(other.getName())
                && this.getState().equals(other.getState())
                && this.getTags().equals(other.getTags()));
    }
```
###### \java\seedu\multitasky\model\entry\FloatingTask.java
``` java
    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();

        // TODO: Include state in string?
        builder.append(getName()).append(" Tags: ");
        getTags().forEach(builder::append);
        return builder.toString();
    }
```
###### \java\seedu\multitasky\model\entry\FloatingTaskList.java
``` java
    /**
     * Adds a floating task reference to the list.
     * Pre-conditions: toAdd is not null and is of type FloatingTask.
     *
     * @throws DuplicateEntryException if {@code toAdd} already exists in the list.
     */
    @Override
    public void add(ReadOnlyEntry toAdd) throws DuplicateEntryException {
        super.add(toAdd);
        if (!(toAdd instanceof FloatingTask)) {
            throw new AssertionError("Non-FloatingTask type cannot be added to an FloatingTaskList.");
        }

        internalList.add((FloatingTask) toAdd);
    }
```
###### \java\seedu\multitasky\model\entry\FloatingTaskList.java
``` java
    /**
     * Clears the current list of floating tasks and add all elements from the list of entries given.
     *
     * @param entries must be a list of floating tasks.
     */
    public void setEntries(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        final FloatingTaskList replacement = new FloatingTaskList();
        for (final ReadOnlyEntry entry : entries) {
            replacement.add(entry);   // Type check is done within add().
        }
        super.setEntries(replacement);
    }
```
###### \java\seedu\multitasky\model\entry\MiscEntryList.java
``` java
/**
 * A list of active entries (not marked as 'done') that does not allow nulls.
 */
public class MiscEntryList extends EntryList {

```
###### \java\seedu\multitasky\model\entry\MiscEntryList.java
``` java
    /**
     * Adds the reference to an entry to the list. It does not create new entry objects.
     *
     * @param toAdd is a subclass of Entry and must not be null.
     */
    @Override
    public void add(ReadOnlyEntry toAdd) throws DuplicateEntryException {
        super.add(toAdd);
        assert (toAdd instanceof Entry);
        internalList.add((Entry) toAdd);
    }

```
###### \java\seedu\multitasky\model\entry\MiscEntryList.java
``` java
    /**
     * Sets EventList to contain the reference to the entries in the given list.
     */
    public void setEntries(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        final MiscEntryList replacement = new MiscEntryList();
        for (final ReadOnlyEntry entry : entries) {
            replacement.add(entry);
        }
        super.setEntries(replacement);
    }

}
```
###### \java\seedu\multitasky\model\entry\OverdueCapable.java
``` java
/**
 * Interface for overdue behavior.
 * @author ChuaPingChan
 */
public interface OverdueCapable {

    public boolean isOverdue();
}
```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
    private void setAllEntriesList() throws DuplicateEntryException {
        /*
         * The reset of list of all entries is different from the others because here we want to add the
         * references to
         * existing entries, not making new copies.
         */
        this._allEntriesList.setEntries(new MiscEntryList());
        for (ReadOnlyEntry entry : _eventList) {
            this._allEntriesList.add(entry);
        }
        for (ReadOnlyEntry entry : _deadlineList) {
            this._allEntriesList.add(entry);
        }
        for (ReadOnlyEntry entry : _floatingTaskList) {
            this._allEntriesList.add(entry);
        }
    }

    public void setEventList(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        this._eventList.setEntries(entries);
    }

    public void setDeadlineList(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        this._deadlineList.setEntries(entries);
    }

    public void setFloatingTaskList(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        this._floatingTaskList.setEntries(entries);
    }

    public void setTags(Collection<Tag> tags) throws UniqueTagList.DuplicateTagException {
        this._tags.setTags(tags);
    }

```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
    public void resetData(ReadOnlyEntryBook newData) {
        requireNonNull(newData);

        try {
            setEventList(newData.getEventList());
            setDeadlineList(newData.getDeadlineList());
            setFloatingTaskList(newData.getFloatingTaskList());

            setAllEntriesList();
        } catch (DuplicateEntryException e) {
            assert false : "EntryBooks should not have duplicate entries";
        }

        try {
            setTags(newData.getTagList());
        } catch (UniqueTagList.DuplicateTagException e) {
            assert false : "EntryBooks should not have duplicate tags";
        }
        syncMasterTagListWith(_allEntriesList);
    }
```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
    /**
     * Adds an entry to the entry book.
     * Creates the appropriate sub-type of the new entry and adds its reference to the active entry list, as
     * well as one of event/deadline/floating task list.
     * Also checks the new entry's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the entry to point to those in {@link #tags}.
     * @throws EntryOverdueException
     * @throws OverlappingAndOverdueEventException
     */
    public void addEntry(ReadOnlyEntry e)
            throws DuplicateEntryException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        try {
            addToEntrySubtypeList(e);
        } finally {

            Entry newEntry = convertToEntry(e);
            syncMasterTagListWith(newEntry);

            // TODO: Decide later if it's still necessary to keep an internal list of all entries

            // Adds reference of newEntry to allEntriesList, not creating a copy.
            _allEntriesList.add(newEntry);
        }
    }
```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
    /**
     * Add a given ReadOnlyEntry to one of either active, deadline or floating task list.
     * @throws OverlappingAndOverdueEventException
     * @throws EntryOverdueException
     */
    private void addToEntrySubtypeList(ReadOnlyEntry newEntry)
            throws DuplicateEntryException, OverlappingEventException, OverlappingAndOverdueEventException,
            EntryOverdueException {
        if (newEntry instanceof Event) {
            boolean overlappingEventPresent = _eventList.hasOverlappingEvent(newEntry);
            boolean eventIsDue = ((Event) newEntry).isOverdue();

            _eventList.add(newEntry);

            if (overlappingEventPresent && eventIsDue) {
                throw new OverlappingAndOverdueEventException();
            } else if (overlappingEventPresent) {
                throw new OverlappingEventException();
            } else if (eventIsDue) {
                throw new EntryOverdueException();
            }
        } else if (newEntry instanceof Deadline) {
            boolean deadlineIsDue = ((Deadline) newEntry).isOverdue();

            _deadlineList.add(newEntry);

            if (deadlineIsDue) {
                throw new EntryOverdueException();
            }
        } else {
            assert (newEntry instanceof FloatingTask);
            _floatingTaskList.add(newEntry);
        }
    }
```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
    /**
     * Replaces the given entry {@code target} in the list with {@code editedReadOnlyEntry}.
     * {@code EntryBook}'s tag list will be updated with the tags of {@code editedReadOnlyEntry}.
     *
     * {@code editedReadOnlyEntry} must be of the same entry sub-type as {@code target}.
     *
     * @throws EntryNotFoundException if {@code target} could not be found in the list.
     * @throws OverlappingEventException if {@code target} is an event and would overlap with existing active events
     * after being updated.
     * @throws EntryOverdueException if {@code editedReadOnlyEntry} is overdue.
     * @throws OverlappingAndOverdueEventException is an event which overlaps with
     *              existing event(s) and is overdue.
     * @see #syncMasterTagListWith(Entry)
     */
    public void updateEntry(ReadOnlyEntry target, ReadOnlyEntry editedReadOnlyEntry)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        requireNonNull(target);
        requireNonNull(editedReadOnlyEntry);
        try {
            updateEntryInSubtypeList(target, editedReadOnlyEntry);
            /*
             * this._allEntriesList does not need updating because it's pointing to the same entries contained
             * in the appropriate sub-type lists.
             */
        } finally {
            Entry editedEntry = convertToEntry(editedReadOnlyEntry);
            syncMasterTagListWith(editedEntry);
        }
    }
```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
    /**
     * Replaces the given entry {@code target} in the appropriate sub-type list with {@code editedReadOnlyEntry}.
     *
     * @throws EntryNotFoundException if {@code target} could not be found in the list.
     * @throws OverlappingEventException  if {@code target} is an event and would overlap with existing active events
     *              after being updated.
     * @throws OverlappingAndOverdueEventException if {@code editedReadOnlyEntry} is an event which overlaps with
     *              existing event(s) and is overdue.
     * @throws EntryOverdueException if {@code editedReadOnlyEntry} is overdue.
     * @see #syncMasterTagListWith(Entry)
     */
    private void updateEntryInSubtypeList(ReadOnlyEntry target, ReadOnlyEntry editedReadOnlyEntry)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        if (target instanceof Event) {
            boolean overlappingEventPresent = editedReadOnlyEntry.isActive()
                                              && _eventList.hasOverlappingEventAfterUpdate(target,
                                                                                           editedReadOnlyEntry);
            Event editedEvent = (Event) editedReadOnlyEntry;
            boolean editedEventIsDue = editedEvent.isOverdue();

            _eventList.updateEntry(target, editedReadOnlyEntry);

            if (overlappingEventPresent && editedEventIsDue) {
                throw new OverlappingAndOverdueEventException();
            } else if (editedEventIsDue) {
                throw new EntryOverdueException();
            } else if (overlappingEventPresent) {
                throw new OverlappingEventException();
            }
        } else if (target instanceof Deadline) {
            Deadline editedDeadline = (Deadline) editedReadOnlyEntry;
            boolean editedDeadlineIsDue = editedDeadline.isOverdue();

            _deadlineList.updateEntry(target, editedReadOnlyEntry);

            if (editedDeadlineIsDue) {
                throw new EntryOverdueException();
            }
        } else {
            assert (target instanceof FloatingTask);
            _floatingTaskList.updateEntry(target, editedReadOnlyEntry);
        }
    }
```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
    /**
     * Type-cast a given ReadOnlyEntry object to an editable Entry object (i.e. event, deadline or floating
     * task).
     */
    private Entry convertToEntry(ReadOnlyEntry editedReadOnlyEntry) {
        Entry newEntry;
        if (editedReadOnlyEntry instanceof Event) {
            newEntry = (Event) editedReadOnlyEntry;
        } else if (editedReadOnlyEntry instanceof Deadline) {
            newEntry = (Deadline) editedReadOnlyEntry;
        } else {
            assert (editedReadOnlyEntry instanceof FloatingTask);
            newEntry = (FloatingTask) editedReadOnlyEntry;
        }
        return newEntry;
    }
```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
    /**
     * Clears all entries of a specific state within this {@code EntryBook}.
     * @param state of entries to be cleared.
     */
    public void clearStateSpecificEntries(Entry.State state) {

        ArrayList<ReadOnlyEntry> entriesToRemove = new ArrayList<>();

        for (ReadOnlyEntry readOnlyEntry : _allEntriesList) {
            if (readOnlyEntry.getState() == state) {
                entriesToRemove.add(readOnlyEntry);
            }
        }

        try {
            for (ReadOnlyEntry entryToRemove : entriesToRemove) {
                this.removeEntry(entryToRemove);
            }
        } catch (EntryNotFoundException enfe) {
            throw new AssertionError("If things are going as expected, "
                                     + " EntryNotFoundException shouldn't be arising here.");
        }
    }
```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
    /**
     * Marks an entry from the appropriate lists (i.e. active, event, deadline, floating task lists) as deleted.
     * Pre-condition: After the entry state is updated, it cannot be an exact match to an existing entry.
     *
     * @param entryToMark
     * @param newState      cannot be null
     * @return boolean
     * @throws DuplicateEntryException
     * @throws EntryNotFoundException
     * @throws OverlappingEventException if entryToChange overlaps with existing active events after being restored.
     * @throws OverlappingAndOverdueEventException
     * @throws EntryOverdueException
     */
    public void changeEntryState(ReadOnlyEntry entryToChange, Entry.State newState)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        if (entryToChange instanceof Event) {
            // Checks if there will be overlapping entry after entryToChange is set to active.
            Entry prospectiveEntry = EntryBuilder.build(entryToChange);
            prospectiveEntry.setState(newState);
            boolean overlappingEventPresent = newState.equals(Entry.State.ACTIVE)
                                              && _eventList.hasOverlappingEventAfterUpdate(entryToChange,
                                                                                           prospectiveEntry);
            boolean eventIsDue = newState.equals(Entry.State.ACTIVE)
                                 && ((Event) prospectiveEntry).isOverdue();

            _eventList.changeEntryState(entryToChange, newState);

            if (overlappingEventPresent && eventIsDue) {
                throw new OverlappingAndOverdueEventException();
            } else if (overlappingEventPresent) {
                throw new OverlappingEventException();
            } else if (eventIsDue) {
                throw new EntryOverdueException();
            }

        } else if (entryToChange instanceof Deadline) {
            _deadlineList.changeEntryState(entryToChange, newState);
        } else {
            assert (entryToChange instanceof FloatingTask);
            _floatingTaskList.changeEntryState(entryToChange, newState);
        }
    }
```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
/**
 * Represents the in-memory model of the entry book data. All changes to any
 * model should be synchronized.
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private final EntryBook _entryBook;
    private final FilteredList<ReadOnlyEntry> _filteredEventList;
    private final FilteredList<ReadOnlyEntry> _filteredDeadlineList;
    private final FilteredList<ReadOnlyEntry> _filteredFloatingTaskList;

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    /**
     * Initializes a ModelManager with the given entryBook and userPrefs.
     * Note that the reference of the entries in the given {@code entryBook}
     * will be copied. Entries themselves will not be copied.
     */
    public ModelManager(ReadOnlyEntryBook entryBook, UserPrefs userPrefs) {
        super();
        requireAllNonNull(entryBook, userPrefs);

        logger.fine("Initializing with entry book: " + entryBook + " and user prefs " + userPrefs);

        this._entryBook = new EntryBook(entryBook);
        _filteredEventList = new FilteredList<>(this._entryBook.getEventList());
        _filteredDeadlineList = new FilteredList<>(this._entryBook.getDeadlineList());
        _filteredFloatingTaskList = new FilteredList<>(this._entryBook.getFloatingTaskList());
    }
```
###### \java\seedu\multitasky\model\ModelManager.java
``` java

    @Override
    public void clearStateSpecificEntries(Entry.State state) {
        _entryBook.clearStateSpecificEntries(state);
        indicateEntryBookChanged();
    }
```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public synchronized void addEntry(ReadOnlyEntry entry)
            throws DuplicateEntryException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        try {
            _entryBook.addEntry(entry);
        } finally {
            indicateEntryBookChanged();
        }
    }
```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void changeEntryState(ReadOnlyEntry entryToChange, Entry.State newState)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        try {
            _entryBook.changeEntryState(entryToChange, newState);
        } finally {
            indicateEntryBookChanged();
        }
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void updateEntry(ReadOnlyEntry target, ReadOnlyEntry editedEntry)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        requireAllNonNull(target, editedEntry);
        try {
            if (target.getClass().equals(editedEntry.getClass())) { // updating to same instance of entry
                _entryBook.updateEntry(target, editedEntry);
            } else { // updating entry between lists
                _entryBook.removeEntry(target);
                _entryBook.addEntry(editedEntry);
            }
        } finally {
            indicateEntryBookChanged();
        }
    }
```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    /**
     * Return a list of {@code ReadOnlyEntry} backed by the internal event list of
     * {@code entryBook}
     */
    @Override
    public UnmodifiableObservableList<ReadOnlyEntry> getFilteredEventList() {
        return new UnmodifiableObservableList<>(_filteredEventList);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    /**
     * Return a list of {@code ReadOnlyEntry} backed by the internal deadline list of
     * {@code entryBook}
     */
    @Override
    public UnmodifiableObservableList<ReadOnlyEntry> getFilteredDeadlineList() {
        return new UnmodifiableObservableList<>(_filteredDeadlineList);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    /**
     * Return a list of {@code ReadOnlyEntry} backed by the internal floating task list of
     * {@code entryBook}
     */
    @Override
    public UnmodifiableObservableList<ReadOnlyEntry> getFilteredFloatingTaskList() {
        return new UnmodifiableObservableList<>(_filteredFloatingTaskList);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyEntry> getActiveList() {
        return new UnmodifiableObservableList<>(_entryBook.getAllEntries());
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void updateFilteredEventListToShowAll() {
        _filteredEventList.setPredicate(null);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void updateFilteredDeadlineListToShowAll() {
        _filteredDeadlineList.setPredicate(null);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void updateFilteredFloatingTaskListToShowAll() {
        _filteredFloatingTaskList.setPredicate(null);
    }
```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    /**
     * Updates all filtered list to show all entries.
     */
    @Override
    public void updateAllFilteredListToShowAll() {
        updateFilteredEventListToShowAll();
        updateFilteredDeadlineListToShowAll();
        updateFilteredFloatingTaskListToShowAll();
    }
```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void updateAllFilteredListToShowAllActiveEntries() {
        this.updateAllFilteredLists(new HashSet<>(), null, null, Entry.State.ACTIVE, Search.AND);
    }
```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void updateAllFilteredListToShowAllArchivedEntries() {
        this.updateAllFilteredLists(new HashSet<>(), null, null, Entry.State.ARCHIVED, Search.AND);
    }
```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public void updateAllFilteredListToShowAllDeletedEntries() {
        this.updateAllFilteredLists(new HashSet<>(), null, null, Entry.State.DELETED, Search.AND);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    private void updateFilteredEventList(Expression expression) {
        _filteredEventList.setPredicate(expression::satisfies);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    private void updateFilteredDeadlineList(Expression expression) {
        _filteredDeadlineList.setPredicate(expression::satisfies);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    private void updateFilteredFloatingTaskList(Expression expression) {
        _filteredFloatingTaskList.setPredicate(expression::satisfies);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public boolean equals(Object obj) {
        // short circuit if same object
        if (obj == this) {
            return true;
        }

        // instanceof handles nulls
        if (!(obj instanceof ModelManager)) {
            return false;
        }

        // state check
        ModelManager other = (ModelManager) obj;
        return _entryBook.equals(other._entryBook) && _filteredEventList.equals(other._filteredEventList)
               && _filteredDeadlineList.equals(other._filteredDeadlineList)
               && _filteredFloatingTaskList.equals(other._filteredFloatingTaskList);
    }
```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
        /**
         * Parses and concatenates all words in an entry's name and tags.
         *
         * @param entry
         * @return String
         */
        protected String parseWordsInNameAndTags(ReadOnlyEntry entry) {
            StringBuilder builder = new StringBuilder();
            builder.append(entry.getName().fullName.replaceAll("\\s+", ""));
            for (Tag t : entry.getTags()) {
                builder.append(t.tagName);
            }
            return builder.toString();
        }

```
