# A0126623L
###### \java\seedu\multitasky\logic\commands\ClearCommand.java
``` java
/**
 * Clears the entry book.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Clear entries in the entry book. " + "\n"
                                               + "Format: " + COMMAND_WORD
                                               + " [" + CliSyntax.PREFIX_ARCHIVE + " | "
                                               + CliSyntax.PREFIX_BIN + " | "
                                               + CliSyntax.PREFIX_ALL + "]" + "\n"
                                               + "Example: " + COMMAND_WORD + " " + CliSyntax.PREFIX_BIN;
    public static final String MESSAGE_ALL_SUCCESS = "Entry book has been cleared!";
    public static final String MESSAGE_ACTIVE_SUCCESS = "Active entries have been cleared!";
    public static final String MESSAGE_ARCHIVE_SUCCESS = "Archive has been cleared!";
    public static final String MESSAGE_BIN_SUCCESS = "Bin has been cleared!";

    public static final int NUMBER_ALLOWABLE_PREFIX = 1;

    public static final String[] VALID_PREFIXES = { CliSyntax.PREFIX_ACTIVE.toString(),
        CliSyntax.PREFIX_ARCHIVE.toString(),
        CliSyntax.PREFIX_BIN.toString(),
        CliSyntax.PREFIX_ALL.toString() };

    public enum ClearType {
        ACTIVE, ARCHIVE, BIN, ALL
    }

    private ClearType clearType;

    public ClearCommand() {
        clearType = ClearType.ACTIVE;
    }

```
###### \java\seedu\multitasky\logic\commands\ClearCommand.java
``` java
    public ClearCommand(String prefix) {
        if (prefix.equals(CliSyntax.PREFIX_ALL.toString())) {
            clearType = ClearType.ALL;
        } else if (prefix.equals(CliSyntax.PREFIX_ARCHIVE.toString())) {
            clearType = ClearType.ARCHIVE;
        } else if (prefix.equals(CliSyntax.PREFIX_BIN.toString())) {
            clearType = ClearType.BIN;
        } else if (prefix.equals(CliSyntax.PREFIX_ACTIVE.toString())) {
            clearType = ClearType.ACTIVE;
        } else {
            throw new AssertionError("ClearCommand constructor shouldn't reach this point.");
        }
    }
```
###### \java\seedu\multitasky\logic\commands\ClearCommand.java
``` java
    @Override
    public CommandResult execute() {
        requireNonNull(model);

        switch (clearType) {
        case ALL:
            model.resetData(new EntryBook());
            return new CommandResult(MESSAGE_ALL_SUCCESS);
        case ACTIVE:
            model.clearStateSpecificEntries(Entry.State.ACTIVE);
            return new CommandResult(MESSAGE_ACTIVE_SUCCESS);
        case ARCHIVE:
            model.clearStateSpecificEntries(Entry.State.ARCHIVED);
            return new CommandResult(MESSAGE_ARCHIVE_SUCCESS);
        case BIN:
            model.clearStateSpecificEntries(Entry.State.DELETED);
            return new CommandResult(MESSAGE_BIN_SUCCESS);
        default:
            throw new AssertionError("Unknown clear command option given.");
        }
    }
```
###### \java\seedu\multitasky\logic\commands\RestoreByFindCommand.java
``` java
/**
 * Finds entries from given keywords and restores entry if it is the only one found.
 */
public class RestoreByFindCommand extends RestoreCommand {

    public static final String MESSAGE_NO_ENTRIES = "No entries found! Please try again with different keywords";

    public static final String MESSAGE_MULTIPLE_ENTRIES = "More than one entry found! \n"
                                                          + "Use " + COMMAND_WORD + " ["
                                                          + String.join(" | ",
                                                                        CliSyntax.PREFIX_EVENT.toString(),
                                                                        CliSyntax.PREFIX_DEADLINE.toString(),
                                                                        CliSyntax.PREFIX_FLOATINGTASK.toString())
                                                          + "]"
                                                          + " INDEX to specify which entry to restore.";

    private Set<String> keywords;

    public RestoreByFindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() throws CommandException, DuplicateEntryException {

        List<ReadOnlyEntry> allList = collateArchivedAndDeletedEntries();

        if (allList.size() == 1) { // proceed to restore
            entryToRestore = allList.get(0);

            if (entryToRestore.isActive()) {
                throw new CommandException(RestoreCommand.MESSAGE_ENTRY_ALREADY_ACTIVE);
            }

            CommandResult commandResult = null;

            try {
                model.changeEntryState(entryToRestore, Entry.State.ACTIVE);
                commandResult = new CommandResult(String.format(MESSAGE_SUCCESS, entryToRestore));
            } catch (EntryNotFoundException e) {
                assert false : "The target entry cannot be missing";
            } catch (OverlappingEventException oee) {
                commandResult = new CommandResult(String.format(MESSAGE_SUCCESS_WITH_OVERLAP_ALERT,
                                                                entryToRestore.getName()));
            } catch (EntryOverdueException e) {
                commandResult = new CommandResult(String.format(MESSAGE_SUCCESS_WITH_OVERDUE_ALERT,
                                                                entryToRestore.getName()));
            } catch (OverlappingAndOverdueEventException e) {
                commandResult = new CommandResult(String.format(MESSAGE_SUCCESS_WITH_OVERLAP_AND_OVERDUE_ALERT,
                                                                entryToRestore.getName()));
            }

            // refresh list view after updating.
            model.updateAllFilteredLists(history.getPrevKeywords(), history.getPrevStartDate(),
                                         history.getPrevEndDate(), history.getPrevState(),
                                         history.getPrevSearches());
            if (commandResult == null) {
                throw new AssertionError("commandResult in RestoreByFindCommand shouldn't be null here.");
            }
            return commandResult;

        } else {
            history.setPrevSearch(keywords, null, null, history.getPrevState());

            if (allList.size() >= 2) { // multiple entries found
                throw new CommandException(MESSAGE_MULTIPLE_ENTRIES);
            } else {
                assert (allList.size() == 0); // no entries found
                throw new CommandException(MESSAGE_NO_ENTRIES);
            }
        }
    }

    /**
     * Collates all archived and deleted entries that matches search keywords.
     * @return List of matched entries
     */
    private List<ReadOnlyEntry> collateArchivedAndDeletedEntries() {
        List<ReadOnlyEntry> allList = new ArrayList<>();

        // Filter and collate archived and deleted entries that matches keywords
        model.updateAllFilteredLists(keywords, null, null, Entry.State.ARCHIVED, Entry.State.DELETED,
                                     Model.STRICT_SEARCHES);
        raise(new ListTypeUpdateEvent("archive and bin"));
        allList.addAll(model.getFilteredDeadlineList());
        allList.addAll(model.getFilteredEventList());
        allList.addAll(model.getFilteredFloatingTaskList());

        return allList;
    }

    private void raise(BaseEvent event) {
        EventsCenter.getInstance().post(event);
    }
}
```
###### \java\seedu\multitasky\logic\commands\RestoreByIndexCommand.java
``` java
/**
 * Restores an entry identified using the type of entry followed by displayed index.
 */
public class RestoreByIndexCommand extends RestoreCommand {

    private Index targetIndex;
    private Prefix listIndicatorPrefix;

    public RestoreByIndexCommand(Index targetIndex, Prefix listIndicatorPrefix) {
        this.targetIndex = targetIndex;
        this.listIndicatorPrefix = listIndicatorPrefix;
    }

    @Override
    public CommandResult execute() throws CommandException, DuplicateEntryException {
        UnmodifiableObservableList<ReadOnlyEntry> listToRestoreFrom = ParserUtil
                .getListIndicatedByPrefix(model, listIndicatorPrefix);
        Objects.requireNonNull(listToRestoreFrom);

        if (targetIndex.getZeroBased() >= listToRestoreFrom.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_ENTRY_DISPLAYED_INDEX);
        }

        entryToRestore = listToRestoreFrom.get(targetIndex.getZeroBased());

        if (entryToRestore.isActive()) {
            throw new CommandException(RestoreCommand.MESSAGE_ENTRY_ALREADY_ACTIVE);
        }

        try {
            model.changeEntryState(entryToRestore, Entry.State.ACTIVE);;
        } catch (EntryNotFoundException enfe) {
            throw new AssertionError("The target entry cannot be missing");
        } catch (OverlappingEventException oee) {
            return new CommandResult(String.format(MESSAGE_SUCCESS_WITH_OVERLAP_ALERT,
                                                   entryToRestore.getName()));
        } catch (EntryOverdueException e) {
            return new CommandResult(String.format(MESSAGE_SUCCESS_WITH_OVERDUE_ALERT,
                                                   entryToRestore.getName()));
        } catch (OverlappingAndOverdueEventException e) {
            return new CommandResult(String.format(MESSAGE_SUCCESS_WITH_OVERLAP_AND_OVERDUE_ALERT,
                                                   entryToRestore.getName()));
        }

        refreshListView();
        return new CommandResult(String.format(MESSAGE_SUCCESS, entryToRestore));
    }

    /**
     * refresh inner lists by using previous command history
     */
    private void refreshListView() {
        model.updateAllFilteredLists(history.getPrevKeywords(), history.getPrevStartDate(),
                                     history.getPrevEndDate(), history.getPrevState(),
                                     history.getPrevSearches());
    }

}
```
###### \java\seedu\multitasky\logic\parser\ClearCommandParser.java
``` java
/**
 * Parses input arguments and creates an appropriate ClearCommand object.
 */
public class ClearCommandParser {

```
###### \java\seedu\multitasky\logic\parser\ClearCommandParser.java
``` java
    /** Parses the given arguments in the context of a clear command.
     *
     * @param args the arguments for the clear command in a single String
     * @return     the ClearCommand object for execution
     * @throws ParseException if the user input does not conform to the expected format
     */
    public ClearCommand parse(String args) throws ParseException {

        String trimmedArgs = args.trim();

        if (trimmedArgs.isEmpty()) {
            return new ClearCommand();
        }

        ArgumentMultimap argumentMultimap = ArgumentTokenizer.tokenize(trimmedArgs,
                                                                       toPrefixArray(ClearCommand.VALID_PREFIXES));

        ArrayList<String> prefixesPresent = argumentMultimap.getPresentPrefixes(ClearCommand.VALID_PREFIXES);
        if (!hasValidPrefixNumber(prefixesPresent)) {
            throw new ParseException(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT,
                                                   ClearCommand.MESSAGE_USAGE));
        }

        return new ClearCommand(prefixesPresent.get(0));
    }
```
###### \java\seedu\multitasky\logic\parser\ClearCommandParser.java
``` java
    private boolean hasValidPrefixNumber(ArrayList<String> prefixes) {
        return (prefixes.size() == ClearCommand.NUMBER_ALLOWABLE_PREFIX);
    }
```
###### \java\seedu\multitasky\model\entry\Deadline.java
``` java
public class Deadline extends Entry implements OverdueCapable {

    private Calendar startDateAndTime;
    private Calendar endDateAndTime;

    /**
     * Every field must be present and not null.
     */
    public Deadline(Name name, Calendar endDateAndTime, Set<Tag> tags) {
        super(name, tags);
        requireAllNonNull(endDateAndTime);
        startDateAndTime = null;
        this.setEndDateAndTime(endDateAndTime);
    }

    /**
     * Creates a copy of the given ReadOnlyEntry.
     * @param source must be type Deadline.
     */
    public Deadline(ReadOnlyEntry source) {
        super(source.getName(), source.getTags());

        if (!(source instanceof Deadline)) {
            throw new AssertionError("Deadline construction failed.");
        }

        requireAllNonNull(source.getEndDateAndTime());
        setEndDateAndTime(source.getEndDateAndTime());
    }

    /**
     * Updates this entry with the details of {@code replacement}.
     * @param replacement must be of type Deadline.
     */
    @Override
    public void resetData(ReadOnlyEntry replacement) {
        super.resetData(replacement);

        if (!(replacement instanceof Deadline)) {
            throw new AssertionError("Argument must be a deadline.");
        }

        setEndDateAndTime(replacement.getEndDateAndTime());
    }

    public String getStartDateAndTimeString() {
        return null; // Deadlines has no start time.
    }

    @Override
    public Calendar getStartDateAndTime() {
        return startDateAndTime; // Deadlines has no start time.
    }

    public void setEndDateAndTime(Calendar endDateAndTime) {
        this.endDateAndTime = endDateAndTime;

        // Ignore differences in milliseconds or seconds and seconds
        this.endDateAndTime.set(Calendar.MILLISECOND, 0);
        this.endDateAndTime.set(Calendar.SECOND, 0);
    }

    public String getEndDateAndTimeString() {
        return dateFormatter.format(getEndDateAndTime().getTime());
    }

    @Override
    public Calendar getEndDateAndTime() {
        return this.endDateAndTime;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
               || this.isSameStateAs((ReadOnlyEntry) other);
    }

    @Override
    public boolean isSameStateAs(ReadOnlyEntry other) {
        return (other instanceof Deadline
                && this.getName().equals(other.getName()) // instanceof handles nulls
                && this.getEndDateAndTime().equals(other.getEndDateAndTime())
                && this.getState().equals(other.getState()));
    }

    @Override
    public boolean isOverdue() {
        if (!(this.isActive())) {
            return false;
        }

        Calendar currentCalendar = Calendar.getInstance();
        return ((this.getEndDateAndTime().compareTo(currentCalendar)) < 0);
    }

    @Override
    public int hashCode() {
        return Objects.hash(getName(), getEndDateAndTime(), getState(), getTags());
    }

    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();

        builder.append(getName())
               .append(", Deadline: ")
               .append(dateFormatter.format(getEndDateAndTime().getTime()))
               .append(", Tags: ");
        getTags().forEach(builder::append);
        return builder.toString();
    }

}
```
###### \java\seedu\multitasky\model\entry\DeadlineList.java
``` java
/**
 * A list of Deadline objects that does not allow nulls.
 */
public class DeadlineList extends EntryList {

```
###### \java\seedu\multitasky\model\entry\DeadlineList.java
``` java
    /**
     * Adds a deadline reference to the list.
     * Pre-condition: toAdd is not null and is of type Deadline.
     *
     * @throws DuplicateEntryException if {@code toAdd} already exists in the list.
     */
    @Override
    public void add(ReadOnlyEntry toAdd) throws DuplicateEntryException {
        super.add(toAdd);
        if (!(toAdd instanceof Deadline)) {
            throw new AssertionError("Non-Deadline type cannot be added to an DeadlineList.");
        }

        internalList.add((Deadline) toAdd);
        sortInternalList();
    }

```
###### \java\seedu\multitasky\model\entry\DeadlineList.java
``` java
    /**
     * Clears the current list of deadlines and add all elements from the list of entries given.
     *
     * @param entries must be a list of deadlines.
     */
    public void setEntries(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        final DeadlineList replacement = new DeadlineList();
        for (final ReadOnlyEntry entry : entries) {
            replacement.add(entry);     // Type check is done within add().
        }
        super.setEntries(replacement);
    }
```
###### \java\seedu\multitasky\model\entry\EntryList.java
``` java
/**
 * A list of entries that does not allow nulls.
 * Supports a minimal set of list operations.
 *
 * @see Entry#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public abstract class EntryList implements Iterable<Entry> {

    protected final ObservableList<Entry> internalList = FXCollections.observableArrayList();

    protected Comparator<ReadOnlyEntry> comparator = Comparators.ENTRY_DEFAULT;

    /**
     * Clears the current list of entries and add all elements from replacement.
     * The updated list of entries will contain the references to the elements in {@code replacement}.
     * @param replacement
     */
    public void setEntries(EntryList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    // ========== Entry Level Operations ==========
    /**
     * Adds an entry to the list.
     *
     * @throws DuplicateEntryException if {@code toAdd} already exists in the list.
     */
    public void add(ReadOnlyEntry toAdd) throws DuplicateEntryException {
        requireNonNull(toAdd);
        if (contains(toAdd)) {
            if (!isArchivedOrDeletedFloatingTask(toAdd)) {
                throw new DuplicateEntryException();
            }
        }
    }

    /**
     * Removes the equivalent entry from the list.
     *
     * @throws EntryNotFoundException if no such entry could be found in the list.
     */
    public boolean remove(ReadOnlyEntry toRemove) throws EntryNotFoundException {
        requireNonNull(toRemove);
        final boolean entryFoundAndDeleted = internalList.remove(toRemove);
        if (!entryFoundAndDeleted) {
            throw new EntryNotFoundException();
        }
        return entryFoundAndDeleted;
    }

    /**
     * Returns true if the list contains an equivalent entry as the given
     * argument.
     */
    public boolean contains(ReadOnlyEntry toCheck) {
        requireNonNull(toCheck);
        return internalList.contains(toCheck);
    }

    /**
     * Changes the state (i.e. ACTIVE, ARCHIVED, DELETED) of an existing entry to {@code newState}.
     * @param entryToChange
     * @param newState
     * @throws DuplicateEntryException, EntryNotFoundException
     */
    public void changeEntryState(ReadOnlyEntry entryToChange, Entry.State newState)
            throws DuplicateEntryException, EntryNotFoundException {
        Entry editedEntry = EntryBuilder.build(entryToChange);
        editedEntry.setState(newState);
        this.updateEntry(entryToChange, editedEntry);
    }

    /**
     * Resets the data of the entry {@code target} in the list with that of the {@code editedEntry}.
     *
     * @throws EntryNotFoundException if {@code target} could not be found in the list.
     * @throws DuplicateEntryException if {@code editedEntry} already exists in the list.
     */
    public void updateEntry(ReadOnlyEntry target, ReadOnlyEntry editedEntry)
            throws DuplicateEntryException, EntryNotFoundException {
        requireNonNull(editedEntry);

        int index = internalList.indexOf(target);
        if (index == -1) {
            throw new EntryNotFoundException();
        }

        Entry entryToUpdate = internalList.get(index);

        if (duplicatesPresentAfterEditing(entryToUpdate, editedEntry)) {
            if (!isArchivedOrDeletedFloatingTask(editedEntry)) {
                throw new DuplicateEntryException();
            }
        }

        entryToUpdate.resetData(editedEntry);
        internalList.set(index, entryToUpdate);
    }

    /**
     * Checks if duplicate entries are present after editing an entry. The entry to be edited
     * is excluded from the duplicates-check.
     * @param target        entry to edit
     * @param editedEntry
     * @return boolean
     */
    private boolean duplicatesPresentAfterEditing(ReadOnlyEntry target, ReadOnlyEntry editedEntry) {
        ArrayList<Entry> prospectiveInternalList = createInternalListCopyWithoutTarget(target);
        return prospectiveInternalList.contains(editedEntry);
    }

    /**
     * Checks if the given entry is a floating task with the "archived" or "deleted" status, which is allowed in model.
     *
     * @param entry must not be null.
     * @return boolean
     */
    public static boolean isArchivedOrDeletedFloatingTask(ReadOnlyEntry entry) {
        Objects.requireNonNull(entry);
        return (entry instanceof FloatingTask
                && (entry.getState().equals(Entry.State.ARCHIVED)
                    || entry.getState().equals(Entry.State.DELETED)));
    }

    // ========== List-Related Operations ==========

    /**
     * Returns an unmodifiable copy of the ObservableList.
     */
    public UnmodifiableObservableList<Entry> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    private ArrayList<Entry> createInternalListCopyWithoutTarget(ReadOnlyEntry target) {
        ArrayList<Entry> copiedInternalList = new ArrayList<Entry>();
        for (Entry e : internalList) {
            if (e != target) {
                copiedInternalList.add(e);
            }
        }
        return copiedInternalList;
    }

```
###### \java\seedu\multitasky\model\entry\Event.java
``` java
public class Event extends Entry implements OverdueCapable, OverlapCapable {

    private Calendar startDateAndTime;
    private Calendar endDateAndTime;

    /**
     * Every field must be present and not null.
     * Events are instantiated to be active events by default.
     * @param name
     * @param startDateAndTime
     * @param endDateAndTime
     * @param state
     * @param tags
     */
    public Event(Name name, Calendar startDateAndTime, Calendar endDateAndTime, Set<Tag> tags) {
        super(name, tags);
        requireAllNonNull(startDateAndTime, endDateAndTime);
        this.setStartDateAndTime(startDateAndTime);
        this.setEndDateAndTime(endDateAndTime);
    }

    /**
     * Creates a copy of the given ReadOnlyEntry.
     * @param source must be of type Event.
     */
    public Event(ReadOnlyEntry source) {
        super(source.getName(), source.getTags());

        // Checks if source has start and end time.
        requireAllNonNull(source.getStartDateAndTime(), source.getEndDateAndTime());

        setStartDateAndTime(source.getStartDateAndTime());
        setEndDateAndTime(source.getEndDateAndTime());
    }

    /**
     * Checks whether a given {@code event}'s time overlaps with this {@code event}'s.
     * @param {@code entry} must be an event.
     * @return boolean
     */
    @Override
    public boolean overlapsWith(OverlapCapable other) {
        if (!(other instanceof Event)) {
            throw new AssertionError("Non-event object is given to Event.hasOverlappingTime().");
        }

        Event otherEvent = (Event) other;

        if (!(this.isActive())) {
            return false;
        }

        return !(otherEvent.getEndDateAndTime().compareTo(this.getStartDateAndTime()) < 0
                 || otherEvent.getStartDateAndTime().compareTo(this.getEndDateAndTime()) > 0);
    }

    /**
     * Check whether an {@code Event} is overdue. Events with a start time from the past
     * are considered overdue, no matter the end time.
     */
    @Override
    public boolean isOverdue() {
        if (!(this.isActive())) {
            return false;
        }

        Calendar currentCalendar = Calendar.getInstance();
        return ((this.getEndDateAndTime().compareTo(currentCalendar)) < 0
                || (this.getStartDateAndTime().compareTo(currentCalendar) < 0));

    }

    /**
     * Updates this entry with the details of {@code replacement}.
     * Pre-condition: ReadOnlyEntry must be type Event.
     */
    @Override
    public void resetData(ReadOnlyEntry replacement) {
        super.resetData(replacement);

        if (!(replacement instanceof Event)) {
            throw new AssertionError("Argument must be an event.");
        }

        setStartDateAndTime(replacement.getStartDateAndTime());
        setEndDateAndTime(replacement.getEndDateAndTime());
    }

    private void setStartDateAndTime(Calendar startDateAndTime) {
        this.startDateAndTime = startDateAndTime;

        // Ignore difference in millisecond and seconds
        this.startDateAndTime.set(Calendar.MILLISECOND, 0);
        this.startDateAndTime.set(Calendar.SECOND, 0);
    }

    public String getStartDateAndTimeString() {
        return dateFormatter.format(getStartDateAndTime().getTime());
    }

    @Override
    public Calendar getStartDateAndTime() {
        return this.startDateAndTime;
    }

    public void setEndDateAndTime(Calendar endDateAndTime) {
        this.endDateAndTime = endDateAndTime;

        // Ignore differences in milliseconds or seconds
        this.endDateAndTime.set(Calendar.MILLISECOND, 0);
        this.endDateAndTime.set(Calendar.SECOND, 0);
    }

    public String getEndDateAndTimeString() {
        return dateFormatter.format(getEndDateAndTime().getTime());
    }

    @Override
    public Calendar getEndDateAndTime() {
        return this.endDateAndTime;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
               || this.isSameStateAs((ReadOnlyEntry) other);
    }

    @Override
    public boolean isSameStateAs(ReadOnlyEntry other) {
        return (other instanceof Event && this.getName().equals(other.getName()) // instanceof handles nulls
                && this.getStartDateAndTime().equals(other.getStartDateAndTime())
                && this.getEndDateAndTime().equals(other.getEndDateAndTime())
                && this.getState().equals(other.getState()));
    }

    @Override
    public int hashCode() {
        return Objects.hash(getName(), getStartDateAndTime(), getEndDateAndTime(), getState(), getTags());
    }

    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();

        builder.append(getName())
               .append(", Start: ")
               .append(dateFormatter.format(getStartDateAndTime().getTime()))
               .append(", End: ")
               .append(dateFormatter.format(getEndDateAndTime().getTime()))
               .append(", Tags: ");
        getTags().forEach(builder::append);
        return builder.toString();
    }
}
```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
/**
 * A list of Event objects that does not allow nulls.
 */
public class EventList extends EntryList {

```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
    /**
     * Adds an event's reference to the list.
     *
     * @param toAdd is of type Event and must not be null.
     * @throws DuplicateEntryException if {@code toAdd} already exists in the list.
     */
    @Override
    public void add(ReadOnlyEntry toAdd) throws DuplicateEntryException {
        super.add(toAdd);

        if (!(toAdd instanceof Event)) {
            throw new AssertionError("Non-Event type cannot be added to an EventList.");
        }

        internalList.add((Event) toAdd);
        sortInternalList();
    }

```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
    /**
     * Checks if a given event has overlapping time with any existing active events in the event list.
     */
    public boolean hasOverlappingEvent(ReadOnlyEntry other) {
        for (Entry existingEntry : internalList) {
            assert (existingEntry instanceof Event) : "Non-event should not exist in an event list.";
            if (!(other instanceof OverlapCapable)) {
                return false;
            }
            Event otherEvent = (Event) other;
            Event existingEvent = (Event) existingEntry;

            if (existingEvent.isActive()
                && existingEvent.overlapsWith(otherEvent)) {
                return true;
            }
        }
        return false;
    }

```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
    /**
     * Checks if a given event will have overlapping time with any existing active events in the
     * event list after being updated.
     */
    public boolean hasOverlappingEventAfterUpdate(ReadOnlyEntry target, ReadOnlyEntry prospectiveEntry) {
        for (Entry existingEntry : internalList) {
            assert (existingEntry instanceof Event) : "Non-event should not exist in an event list.";
            if (!(prospectiveEntry instanceof OverlapCapable)) {
                return false;
            }
            Event prospectiveEvent = (Event) prospectiveEntry;
            Event existingEvent = (Event) existingEntry;

            if (existingEvent.isActive()
                && existingEvent.overlapsWith(prospectiveEvent)
                && !(existingEvent.equals(target))) {
                return true;
            }
        }
        return false;
    }

```
###### \java\seedu\multitasky\model\entry\EventList.java
``` java
    /**
     * Clears the current list of events and add all elements from the list of entries given.
     *
     * @param entries must be a list of events.
     */
    public void setEntries(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        final EventList replacement = new EventList();
        for (final ReadOnlyEntry entry : entries) {
            replacement.add(entry);     // Type check is done within add().
        }
        super.setEntries(replacement);
    }

}
```
###### \java\seedu\multitasky\model\entry\exceptions\EntryOverdueException.java
``` java
/**
* Signals that an operation results in an overdue entry.
*/
public class EntryOverdueException extends Exception {
}
```
###### \java\seedu\multitasky\model\entry\exceptions\OverlappingAndOverdueEventException.java
``` java
/**
* Signals an operation results in an overdue event that also overlaps with
* existing active event.
*/
public class OverlappingAndOverdueEventException extends Exception {
}
```
###### \java\seedu\multitasky\model\entry\exceptions\OverlappingEventException.java
``` java
/**
 * Signals that an operation results in an event that overlaps with an
 * existing active event.
 */
public class OverlappingEventException extends Exception {
}
```
###### \java\seedu\multitasky\model\entry\FloatingTask.java
``` java
public class FloatingTask extends Entry {

    private Calendar startDateAndTime;
    private Calendar endDateAndTime;

    /**
     * Every field must be present and not null.
     */
    public FloatingTask(Name name, Set<Tag> tags) {
        super(name, tags);
        startDateAndTime = null;
        endDateAndTime = null;
    }

    /**
     * Creates a copy of the given ReadOnlyEntry.
     * Pre-condition: source must be of type FloatingTask.
     */
    public FloatingTask(ReadOnlyEntry source) {
        super(source.getName(), source.getTags());
    }

    public String getStartDateAndTimeString() {
        return null; // Floating tasks have no start time.
    }

    @Override
    public Calendar getStartDateAndTime() {
        return startDateAndTime;
    }

    public String getEndDateAndTimeString() {
        return null; // Floating tasks have no end time.
    }

    @Override
    public Calendar getEndDateAndTime() {
        return endDateAndTime;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
               || this.isSameStateAs((ReadOnlyEntry) other);
    }

    /**
     * Compares the state with another Floating Task.
     */
    @Override
    public boolean isSameStateAs(ReadOnlyEntry other) {
        return (other instanceof FloatingTask // instanceof handles nulls
                && this.getName().equals(other.getName())
                && this.getState().equals(other.getState()));
    }

```
###### \java\seedu\multitasky\model\entry\FloatingTaskList.java
``` java
    /**
     * Adds a floating task reference to the list.
     * Pre-conditions: toAdd is not null and is of type FloatingTask.
     *
     * @throws DuplicateEntryException if {@code toAdd} already exists in the list.
     */
    @Override
    public void add(ReadOnlyEntry toAdd) throws DuplicateEntryException {
        super.add(toAdd);
        if (!(toAdd instanceof FloatingTask)) {
            throw new AssertionError("Non-FloatingTask type cannot be added to an FloatingTaskList.");
        }

        internalList.add((FloatingTask) toAdd);
    }

```
###### \java\seedu\multitasky\model\entry\FloatingTaskList.java
``` java
    /**
     * Clears the current list of floating tasks and add all elements from the list of entries given.
     *
     * @param entries must be a list of floating tasks.
     */
    public void setEntries(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        final FloatingTaskList replacement = new FloatingTaskList();
        for (final ReadOnlyEntry entry : entries) {
            replacement.add(entry);   // Type check is done within add().
        }
        super.setEntries(replacement);
    }
}
```
###### \java\seedu\multitasky\model\entry\MiscEntryList.java
``` java
/**
 * A list of active entries (not marked as 'done') that does not allow nulls.
 */
public class MiscEntryList extends EntryList {

    /**
     * Adds the reference to an entry to the list. It does not create new entry objects.
     *
     * @param toAdd is a subclass of Entry and must not be null.
     */
    @Override
    public void add(ReadOnlyEntry toAdd) throws DuplicateEntryException {
        super.add(toAdd);
        assert (toAdd instanceof Entry);
        internalList.add((Entry) toAdd);
    }

    /**
     * Sets MiscEntryList to contain the reference to the entries in the given list.
     */
    public void setEntries(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        final MiscEntryList replacement = new MiscEntryList();
        for (final ReadOnlyEntry entry : entries) {
            replacement.add(entry);
        }
        super.setEntries(replacement);
    }

}
```
###### \java\seedu\multitasky\model\entry\Name.java
``` java
/**
 * Represents an Entry's name in the entry book.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String MESSAGE_NAME_CONSTRAINTS = "Entry names should only start with "
                                                          + "alphanumeric characters and it should "
                                                          + "not be blank, subsequent spaces and "
                                                          + "non-alphanumeric characters are allowed.";

    /*
     * The first character of the entry must not be a whitespace, otherwise " " (a blank string)
     * becomes a valid input.
     */
    public static final String NAME_VALIDATION_REGEX = "[\\p{Alnum}][\\p{Alnum}\\p{S}\\p{P} ]*";

    public final String fullName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        requireNonNull(name);
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullName = trimmedName;
    }

```
###### \java\seedu\multitasky\model\entry\OverdueCapable.java
``` java
/**
 * Interface for overdue behavior.
 */
public interface OverdueCapable {

    public boolean isOverdue();
}
```
###### \java\seedu\multitasky\model\entry\OverlapCapable.java
``` java
/**
* Interface for overlapping behavior.
*/
public interface OverlapCapable {

    public boolean overlapsWith(OverlapCapable other);

}
```
###### \java\seedu\multitasky\model\entry\ReadOnlyEntry.java
``` java
/**
 * A read-only immutable interface for a Entry in the entrybook.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyEntry {

    Name getName();

    Calendar getStartDateAndTime();

    Calendar getEndDateAndTime();

    String getStartDateAndTimeString();

    String getEndDateAndTimeString();

    Entry.State getState();

    Set<Tag> getTags();

    boolean isActive();

    boolean isArchived();

    boolean isDeleted();

    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    boolean isSameStateAs(ReadOnlyEntry other);

}
```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
/**
 * Wraps all data at the entry-book level
 */
public class EntryBook implements ReadOnlyEntryBook {
    private static final Logger logger = LogsCenter.getLogger(EntryBook.class);

    private final MiscEntryList allEntriesList;
    private final EventList eventList;
    private final DeadlineList deadlineList;
    private final FloatingTaskList floatingTaskList;
    private final UniqueTagList tags;

    public EntryBook() {
        allEntriesList = new MiscEntryList();
        eventList = new EventList();
        deadlineList = new DeadlineList();
        floatingTaskList = new FloatingTaskList();
        tags = new UniqueTagList();
    }

    /**
     * Creates an EntryBook using the Entries and Tags in the {@code toBeCopied}
     */
    public EntryBook(ReadOnlyEntryBook toBeCopied) {
        this();
        resetData(toBeCopied);
    }

    public void resetData(ReadOnlyEntryBook newData) {
        requireNonNull(newData);

        try {
            setEventList(newData.getEventList());
            setDeadlineList(newData.getDeadlineList());
            setFloatingTaskList(newData.getFloatingTaskList());

            setAllEntriesList();
        } catch (DuplicateEntryException e) {
            assert false : "EntryBooks should not have duplicate entries";
        }

        try {
            setTags(newData.getTagList());
        } catch (UniqueTagList.DuplicateTagException e) {
            assert false : "EntryBooks should not have duplicate tags";
        }
        syncMasterTagListWith(allEntriesList);
    }

    // ================= List Overwrite Operations =================

    /**
     * Fills up {@code allEntriesList} with existing events, deadlines
     * and floating tasks in the {@code EntryBook}'s.
     * @throws DuplicateEntryException
     */
    private void setAllEntriesList() throws DuplicateEntryException {
        this.allEntriesList.setEntries(new MiscEntryList());
        for (ReadOnlyEntry entry : eventList) {
            this.allEntriesList.add(entry);
        }
        for (ReadOnlyEntry entry : deadlineList) {
            this.allEntriesList.add(entry);
        }
        for (ReadOnlyEntry entry : floatingTaskList) {
            this.allEntriesList.add(entry);
        }
    }

    private void setEventList(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        this.eventList.setEntries(entries);
    }

    private void setDeadlineList(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        this.deadlineList.setEntries(entries);
    }

    private void setFloatingTaskList(List<? extends ReadOnlyEntry> entries) throws DuplicateEntryException {
        this.floatingTaskList.setEntries(entries);
    }

    private void setTags(Collection<Tag> tags) throws UniqueTagList.DuplicateTagException {
        this.tags.setTags(tags);
    }

    // ================= Entry-Level Operations =================

    /**
     * Adds an entry to the entry book.
     * Creates the appropriate sub-type of the new entry and adds its reference to the active entry list, as
     * well as one of event/deadline/floating task list.
     * Also checks the new entry's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the entry to point to those in {@link #tags}.
     * @throws EntryOverdueException
     * @throws OverlappingAndOverdueEventException
     */
    public void addEntry(ReadOnlyEntry entryToAdd)
            throws DuplicateEntryException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        try {
            addToEntrySubtypeList(entryToAdd);
        } catch (OverlappingEventException | OverlappingAndOverdueEventException | EntryOverdueException e) {
            syncMasterTagListWith(entryToAdd);
            allEntriesList.add(entryToAdd);
            throw e;
        }
        syncMasterTagListWith(entryToAdd);
        allEntriesList.add(entryToAdd);
        logger.fine("EntryBook added: " + entryToAdd);
    }

    /**
     * Add a given ReadOnlyEntry to one of either active, deadline or floating task list.
     * @param newEntry to add
     * @throws DuplicateEntryException
     * @throws OverlappingEventException
     * @throws OverlappingAndOverdueEventException
     * @throws EntryOverdueException
     */
    private void addToEntrySubtypeList(ReadOnlyEntry newEntry)
            throws DuplicateEntryException, OverlappingEventException, OverlappingAndOverdueEventException,
            EntryOverdueException {
        if (newEntry instanceof Event) {
            addToEventListWithOverlapAndOverdueCheck(newEntry);
        } else if (newEntry instanceof Deadline) {
            addToDeadlineListWithOverdueCheck(newEntry);
        } else {
            assert (newEntry instanceof FloatingTask);
            floatingTaskList.add(newEntry);
        }
    }

    private void addToEventListWithOverlapAndOverdueCheck(ReadOnlyEntry newEntry)
            throws DuplicateEntryException, OverlappingAndOverdueEventException, OverlappingEventException,
            EntryOverdueException {
        boolean overlappingEventPresent = eventList.hasOverlappingEvent(newEntry);
        boolean eventIsDue = ((Event) newEntry).isOverdue();

        eventList.add(newEntry);

        overlappingOrOverdueEventAlarm(overlappingEventPresent, eventIsDue);
    }

    private void addToDeadlineListWithOverdueCheck(ReadOnlyEntry newEntry)
            throws DuplicateEntryException, EntryOverdueException {
        boolean deadlineIsDue = ((Deadline) newEntry).isOverdue();

        deadlineList.add(newEntry);

        if (deadlineIsDue) {
            throw new EntryOverdueException();
        }
    }

    /**
     * Replaces the given entry {@code target} in the list with {@code editedReadOnlyEntry}.
     * {@code EntryBook}'s tag list will be updated with the tags of {@code editedReadOnlyEntry}.
     *
     * {@code editedReadOnlyEntry} must be of the same entry sub-type as {@code target}.
     *
     * @throws EntryNotFoundException if {@code target} could not be found in the list.
     * @throws OverlappingEventException if {@code target} is an event and would overlap with existing active events
     * after being updated.
     * @throws EntryOverdueException if {@code editedReadOnlyEntry} is overdue.
     * @throws OverlappingAndOverdueEventException is an event which overlaps with
     *              existing event(s) and is overdue.
     * @see #syncMasterTagListWith(Entry)
     */
    public void updateEntry(ReadOnlyEntry target, ReadOnlyEntry editedReadOnlyEntry)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        requireNonNull(target);
        requireNonNull(editedReadOnlyEntry);

        try {
            updateEntryInSubtypeList(target, editedReadOnlyEntry);
            /**
             * this.allEntriesList does not need updating because it's pointing to the same entries contained
             * in the appropriate sub-type lists.
             */
        } catch (EntryNotFoundException | OverlappingEventException
                 | OverlappingAndOverdueEventException | EntryOverdueException e) {
            syncMasterTagListWith(editedReadOnlyEntry);
            throw e;
        }
        syncMasterTagListWith(editedReadOnlyEntry);
        logger.fine("EntryBook updated: " + editedReadOnlyEntry);
    }

    /**
     * Replaces the given entry {@code target} in the appropriate sub-type list with {@code editedReadOnlyEntry}.
     *
     * @throws EntryNotFoundException if {@code target} could not be found in the list.
     * @throws OverlappingEventException  if {@code target} is an event and would overlap with existing active events
     *              after being updated.
     * @throws OverlappingAndOverdueEventException if {@code editedReadOnlyEntry} is an event which overlaps with
     *              existing event(s) and is overdue.
     * @throws EntryOverdueException if {@code editedReadOnlyEntry} is overdue.
     * @see #syncMasterTagListWith(Entry)
     */
    private void updateEntryInSubtypeList(ReadOnlyEntry target, ReadOnlyEntry editedReadOnlyEntry)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        if (target instanceof Event) {
            editEventWithOverlappingAndOverdueCheck(target, editedReadOnlyEntry);
        } else if (target instanceof Deadline) {
            editDeadlineWithOverdueCheck(target, editedReadOnlyEntry);
        } else {
            assert (target instanceof FloatingTask);
            floatingTaskList.updateEntry(target, editedReadOnlyEntry);
        }
    }

    private void editEventWithOverlappingAndOverdueCheck(ReadOnlyEntry target,
                                                         ReadOnlyEntry editedReadOnlyEntry)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingAndOverdueEventException,
            EntryOverdueException, OverlappingEventException {
        boolean overlappingEventPresent = editedReadOnlyEntry.isActive()
                                          && eventList.hasOverlappingEventAfterUpdate(target,
                                                                                      editedReadOnlyEntry);
        Event editedEvent = (Event) editedReadOnlyEntry;
        boolean editedEventIsDue = editedEvent.isOverdue();

        eventList.updateEntry(target, editedReadOnlyEntry);

        overlappingOrOverdueEventAlarm(overlappingEventPresent, editedEventIsDue);
    }

    private void editDeadlineWithOverdueCheck(ReadOnlyEntry target, ReadOnlyEntry editedReadOnlyEntry)
            throws DuplicateEntryException, EntryNotFoundException, EntryOverdueException {
        Deadline editedDeadline = (Deadline) editedReadOnlyEntry;
        boolean editedDeadlineIsDue = editedDeadline.isOverdue();

        deadlineList.updateEntry(target, editedReadOnlyEntry);

        if (editedDeadlineIsDue) {
            throw new EntryOverdueException();
        }
    }

    /**
     * Type-cast a given ReadOnlyEntry object to an editable Entry object (i.e. event, deadline or floating
     * task).
     */
    private Entry convertToEntry(ReadOnlyEntry editedReadOnlyEntry) {
        Entry newEntry;
        if (editedReadOnlyEntry instanceof Event) {
            newEntry = (Event) editedReadOnlyEntry;
        } else if (editedReadOnlyEntry instanceof Deadline) {
            newEntry = (Deadline) editedReadOnlyEntry;
        } else {
            assert (editedReadOnlyEntry instanceof FloatingTask);
            newEntry = (FloatingTask) editedReadOnlyEntry;
        }
        return newEntry;
    }

    /**
     * Removes entry from the appropriate lists (i.e. active, event, deadline, floating task lists).
     *
     * @param entryToRemove
     * @return boolean
     * @throws EntryNotFoundException
     */
    public boolean removeEntry(ReadOnlyEntry entryToRemove) throws EntryNotFoundException {
        logger.fine("EntryBook attempting to remove: " + entryToRemove);
        return (allEntriesList.remove(entryToRemove) && removeFromEntrySubtypeList(entryToRemove));
    }

    /**
     * Removes an entry from the appropriate list (i.e. event list, deadline list, floating task list).
     *
     * @param entryToRemove is of type Event, Deadline or FloatingTask
     * @return boolean
     */
    private boolean removeFromEntrySubtypeList(ReadOnlyEntry entryToRemove) throws EntryNotFoundException {
        if (entryToRemove instanceof Event) {
            return eventList.remove(entryToRemove);
        } else if (entryToRemove instanceof Deadline) {
            return deadlineList.remove(entryToRemove);
        } else {
            assert (entryToRemove instanceof FloatingTask);
            return floatingTaskList.remove(entryToRemove);
        }
    }

    /**
     * Clears all entries of a specific state within this {@code EntryBook}.
     * @param state of entries to be cleared.
     */
    public void clearStateSpecificEntries(Entry.State state) {

        ArrayList<ReadOnlyEntry> entriesToRemove = new ArrayList<>();
        collectStateSpecificEntriesToRemove(state, entriesToRemove);
        removeEntriesInList(entriesToRemove);
        logger.fine("EntryBook cleared entries of type: " + state.toString());
    }

    private void collectStateSpecificEntriesToRemove(Entry.State state,
                                                     ArrayList<ReadOnlyEntry> entriesToRemove) {
        for (ReadOnlyEntry readOnlyEntry : allEntriesList) {
            if (readOnlyEntry.getState() == state) {
                entriesToRemove.add(readOnlyEntry);
            }
        }
    }

    private void removeEntriesInList(List<ReadOnlyEntry> entriesToRemove) throws AssertionError {
        try {
            for (ReadOnlyEntry entryToRemove : entriesToRemove) {
                this.removeEntry(entryToRemove);
            }
        } catch (EntryNotFoundException enfe) {
            throw new AssertionError("If things are going as expected, "
                                     + " EntryNotFoundException shouldn't be arising here.");
        }
    }

    /**
     * Marks an entry from the appropriate lists (i.e. active, event, deadline, floating task lists)
     * as {@code deleted} or {@code archived}.
     * Pre-condition: After the entry state is updated, it cannot result in a duplicate with an existing
     * active entry.
     *
     * @param entryToMark
     * @param newState      cannot be null
     * @return boolean
     * @throws DuplicateEntryException
     * @throws EntryNotFoundException
     * @throws OverlappingEventException if entryToChange overlaps with existing active events after being restored.
     * @throws OverlappingAndOverdueEventException
     * @throws EntryOverdueException
     */
    public void changeEntryState(ReadOnlyEntry entryToChange, Entry.State newState)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        if (entryToChange instanceof Event) {
            changeEventStateWithOverlapAndOverdueCheck(entryToChange, newState);
        } else if (entryToChange instanceof Deadline) {
            changeDeadlineStateWithOverdueCheck(entryToChange, newState);
        } else {
            assert (entryToChange instanceof FloatingTask);
            floatingTaskList.changeEntryState(entryToChange, newState);
        }

        logger.fine("EntryBook changed state of: " + entryToChange.getName() + " to " + newState.toString());
    }

    /**
     * Checks if a change of the {@code State} of a given {@code Event} will result in an overdue
     * event or an event that overlaps with existing active events. If these do not happen, the
     * state change will be made.
     * Pre-condition: {@code entryToChange} must be an Event.
     * @param entryToChange
     * @param newState
     * @throws DuplicateEntryException
     * @throws EntryNotFoundException
     * @throws OverlappingAndOverdueEventException
     * @throws OverlappingEventException
     * @throws EntryOverdueException
     */
    private void changeEventStateWithOverlapAndOverdueCheck(ReadOnlyEntry entryToChange, Entry.State newState)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingAndOverdueEventException,
            OverlappingEventException, EntryOverdueException {
        if (!(entryToChange instanceof Event)) {
            throw new AssertionError("entryToChange must be of type Event.");
        }
        Entry prospectiveEntry = EntryBuilder.build(entryToChange);
        prospectiveEntry.setState(newState);
        boolean overlappingEventPresent = newState.equals(Entry.State.ACTIVE)
                                          && eventList.hasOverlappingEventAfterUpdate(entryToChange,
                                                                                      prospectiveEntry);
        boolean eventIsDue = newState.equals(Entry.State.ACTIVE)
                             && ((Event) prospectiveEntry).isOverdue();

        eventList.changeEntryState(entryToChange, newState);

        overlappingOrOverdueEventAlarm(overlappingEventPresent, eventIsDue);
    }

    /**
     * Checks if a change of the {@code State} of a given {@code Deadline} will result in an overdue
     * deadline. If this do not happen, the state change will be made.
     * Pre-condition: {@code entryToChange} must be a Deadline.
     * @param entryToChange
     * @param newState
     * @throws DuplicateEntryException
     * @throws EntryNotFoundException
     * @throws EntryOverdueException
     */
    private void changeDeadlineStateWithOverdueCheck(ReadOnlyEntry entryToChange, Entry.State newState)
            throws DuplicateEntryException, EntryNotFoundException, EntryOverdueException {
        if (!(entryToChange instanceof Deadline)) {
            throw new AssertionError("entryToChange must be of type Deadline.");
        }
        Entry prospectiveEntry = EntryBuilder.build(entryToChange);
        prospectiveEntry.setState(newState);
        boolean deadlineIsDue = newState.equals(Entry.State.ACTIVE)
                                && ((Deadline) prospectiveEntry).isOverdue();

        deadlineList.changeEntryState(entryToChange, newState);

        if (deadlineIsDue) {
            throw new EntryOverdueException();
        }
    }

    /**
     * Throws the appropriate exceptions if overlapping and overdue event exists.
     * @param overlappingEventPresent
     * @param eventIsDue
     * @throws OverlappingAndOverdueEventException
     * @throws OverlappingEventException
     * @throws EntryOverdueException
     */
    private void overlappingOrOverdueEventAlarm(boolean overlappingEventPresent, boolean eventIsDue)
            throws OverlappingAndOverdueEventException, OverlappingEventException, EntryOverdueException {
        if (overlappingEventPresent && eventIsDue) {
            throw new OverlappingAndOverdueEventException();
        } else if (overlappingEventPresent) {
            throw new OverlappingEventException();
        } else if (eventIsDue) {
            throw new EntryOverdueException();
        }
    }

    // ================= Tag-Level Operations =================

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);

        logger.fine("EntryBook added tag: " + t.tagName);
    }

```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
    /**
     * Ensures that every tag in this entry:
     * - exists in the master list {@link #tags}
     * - points to a Tag object in the master list
     */
    private void syncMasterTagListWith(ReadOnlyEntry readOnlyEntry) {
        Entry entry = convertToEntry(readOnlyEntry);
        final UniqueTagList entryTags = new UniqueTagList(entry.getTags());
        tags.mergeFrom(entryTags);

        // Create map with values = tag object references in the master list
        // used for checking entry tag references
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        tags.forEach(tag -> masterTagObjects.put(tag, tag));

        // Rebuild the list of entry tags to point to the relevant tags in the master tag list.
        final Set<Tag> correctTagReferences = new HashSet<>();
        entryTags.forEach(tag -> correctTagReferences.add(masterTagObjects.get(tag)));
        entry.setTags(correctTagReferences);
    }

```
###### \java\seedu\multitasky\model\EntryBook.java
``` java
    /**
     * @return String Information of the number of active entries and tags present.
     */
    @Override
    public String toString() {
        return allEntriesList.asObservableList().size() + " entries, " + tags.asObservableList().size()
               + " tags";
    }

    @Override
    public ObservableList<ReadOnlyEntry> getAllEntries() {
        return new UnmodifiableObservableList<>(allEntriesList.asObservableList());
    }

    @Override
    public ObservableList<ReadOnlyEntry> getEventList() {
        return new UnmodifiableObservableList<>(eventList.asObservableList());
    }

    @Override
    public ObservableList<ReadOnlyEntry> getDeadlineList() {
        return new UnmodifiableObservableList<>(deadlineList.asObservableList());
    }

    @Override
    public ObservableList<ReadOnlyEntry> getFloatingTaskList() {
        return new UnmodifiableObservableList<>(floatingTaskList.asObservableList());
    }

    @Override
    public ObservableList<Tag> getTagList() {
        return new UnmodifiableObservableList<>(tags.asObservableList());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
               || (other instanceof EntryBook // instanceof handles nulls
                   && this.getAllEntries().equals(((EntryBook) other).getAllEntries())
                   && this.getEventList().equals(((EntryBook) other).getEventList())
                   && this.getDeadlineList().equals(((EntryBook) other).getDeadlineList())
                   && this.getFloatingTaskList().equals(((EntryBook) other).getFloatingTaskList())
                   && this.tags.equalsOrderInsensitive(((EntryBook) other).tags));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(getAllEntries(), getEventList(), getDeadlineList(),
                            getFloatingTaskList(), getTagList());
    }
}
```
###### \java\seedu\multitasky\model\Model.java
``` java
/**
 * The API of the Model component.
 */
public interface Model {

    public enum Search {
        AND, OR, POWER_AND, POWER_OR
    };

    public static final Search[] STRICT_SEARCHES = { Search.AND, Search.POWER_AND };
    public static final Search[] LENIENT_SEARCHES = { Search.AND, Search.OR, Search.POWER_AND,
        Search.POWER_OR };

    // =========== EntryBook-level Operations ===========

    /** Returns the EntryBook */
    ReadOnlyEntryBook getEntryBook();

    /** Clears existing backing model and replaces with the provided new data. */
    void resetData(ReadOnlyEntryBook newData);

    // =========== Entry Level Operations ===========

    /** Adds the given entry
     * @throws EntryOverdueException
     * @throws OverlappingAndOverdueEventException
     */
    void addEntry(ReadOnlyEntry entry) throws DuplicateEntryException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException;

    /** Deletes the given entry. */
    void deleteEntry(ReadOnlyEntry target) throws DuplicateEntryException, EntryNotFoundException;

    /**
     * Replaces the given entry {@code target} with {@code editedEntry}.
     * Entry can be changed from one type to another, e.g. from an event to a deadline.
     *
     * @throws EntryNotFoundException if {@code target} could not be found in the list.
     * @throws EntryOverdueException if {@code editedReadOnlyEntry} is overdue.
     * @throws OverlappingAndOverdueEventException is an event which overlaps with
     *              existing event(s) and is overdue.
     */
    void updateEntry(ReadOnlyEntry target, ReadOnlyEntry editedEntry)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException;

    /** Updates the state of a given entry.
     * @throws EntryOverdueException
     * @throws OverlappingAndOverdueEventException
     */
    void changeEntryState(ReadOnlyEntry entryToChange, Entry.State newState)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException;

    /** Clears all entries of a specific state. */
    public void clearStateSpecificEntries(Entry.State state);

    // =========== Filtered Entry List Accessors ===========

    /** Returns the filtered event list as an {@code UnmodifiableObservableList<ReadOnlyEntry>} */
    UnmodifiableObservableList<ReadOnlyEntry> getFilteredEventList();

    /** Returns the filtered deadline list as an {@code UnmodifiableObservableList<ReadOnlyEntry>} */
    UnmodifiableObservableList<ReadOnlyEntry> getFilteredDeadlineList();

    /** Returns the filtered floating task list as an {@code UnmodifiableObservableList<ReadOnlyEntry>} */
    UnmodifiableObservableList<ReadOnlyEntry> getFilteredFloatingTaskList();

    /** Updates the filter of all filtered lists to show all active entries */
    public void updateAllFilteredListToShowAllActiveEntries();

    /**
     * Updates the filter of all entry lists to filter by the given keywords,
     * date range and state. Attempts all the different searches in order until it has at least 1 result.
     */
    void updateAllFilteredLists(Set<String> keywords, Calendar startDate, Calendar endDate,
                                Entry.State state, Search... searches);

    /**
     * Updates the filter of all entry lists to filter by the given keywords,
     * date range and state. Attempts all the different searches in order until it has at least 1 result.
     * Allows for two states to be shown at the same time.
     */
    void updateAllFilteredLists(Set<String> keywords, Calendar startDate, Calendar endDate,
                                Entry.State state, Entry.State state2, Search... searches);

    /**
     * Updates the filter of the filtered floating task list to filter by the given keywords,
     * date range and state using the specified search type.
     */
    void updateFilteredFloatingTaskList(Set<String> keywords, Calendar startDate, Calendar endDate,
                                        Entry.State state, Search search, int level);

    /** Updates the sorting comparators used. */
    void updateSortingComparators(Comparator<ReadOnlyEntry> eventComparator,
                                  Comparator<ReadOnlyEntry> deadlineComparator,
                                  Comparator<ReadOnlyEntry> floatingTaskComparator);

    // =========== Storage-Related Operations ===========

    /** Undo the previous data-changing action */
    void undoPreviousAction() throws NothingToUndoException;

    /** Redo the previous undo action */
    void redoPreviousAction() throws NothingToRedoException;

    /** Change the file path for storage */
    void changeFilePath(String newFilePath);

    /**
     * Load data at the given file path
     *
     * @throws IllegalValueException
     */
    void openFilePath(String newFilePath) throws IllegalValueException;

}
```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
/**
 * Represents the in-memory model of the entry book data. All changes to any
 * model should be synchronized.
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private final EntryBook entryBook;
    private final FilteredList<ReadOnlyEntry> filteredEventList;
    private final FilteredList<ReadOnlyEntry> filteredDeadlineList;
    private final FilteredList<ReadOnlyEntry> filteredFloatingTaskList;

    /**
     * Initializes a ModelManager with the given entryBook and userPrefs.
     * Note that the reference of the entries in the given {@code entryBook}
     * will be copied. Entries themselves will not be copied.
     */
    public ModelManager(ReadOnlyEntryBook entryBook, UserPrefs userPrefs) {
        super();
        requireAllNonNull(entryBook, userPrefs);

        logger.fine("Initializing with entry book: " + entryBook + " and user prefs " + userPrefs);

        this.entryBook = new EntryBook(entryBook);
        filteredEventList = new FilteredList<>(this.entryBook.getEventList());
        filteredDeadlineList = new FilteredList<>(this.entryBook.getDeadlineList());
        filteredFloatingTaskList = new FilteredList<>(this.entryBook.getFloatingTaskList());
    }

    public ModelManager() {
        this(new EntryBook(), new UserPrefs());
    }

    // =========== EntryBook-level Operations ===========

    @Override
    public void resetData(ReadOnlyEntryBook newData) {
        entryBook.resetData(newData);
        indicateEntryBookChanged();
    }

    @Override
    public ReadOnlyEntryBook getEntryBook() {
        return entryBook;
    }

    // =========== Entry Level Operations ===========

    @Override
    public synchronized void addEntry(ReadOnlyEntry entry)
            throws DuplicateEntryException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        try {
            entryBook.addEntry(entry);
        } catch (OverlappingEventException | OverlappingAndOverdueEventException
                 | EntryOverdueException e) {
            indicateEntryBookChanged();
            throw e;
        }
        indicateEntryBookChanged();
    }

    @Override
    public synchronized void deleteEntry(ReadOnlyEntry target)
            throws EntryNotFoundException {
        entryBook.removeEntry(target);

        indicateEntryBookChanged();
    }

    @Override
    public void updateEntry(ReadOnlyEntry target, ReadOnlyEntry editedEntry)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        requireAllNonNull(target, editedEntry);
        try {
            if (target.getClass().equals(editedEntry.getClass())) { // updating to same type of entry
                entryBook.updateEntry(target, editedEntry);
            } else { // updating to a different type of entry
                changeEntryType(target, editedEntry);
            }
        } catch (EntryNotFoundException | OverlappingEventException
                 | OverlappingAndOverdueEventException | EntryOverdueException e) {
            indicateEntryBookChanged();
            throw e;
        }
        indicateEntryBookChanged();
    }

    /**
     * Change a given entry {@code target} to a different entry type {@code editedEntry} by
     * first removing the {@code target} entry from the EntryBook followed by adding {@code editedEntry}.
     * @param target
     * @param editedEntry
     * @throws DuplicateEntryException
     * @throws OverlappingEventException
     * @throws OverlappingAndOverdueEventException
     * @throws EntryOverdueException
     * @throws EntryNotFoundException
     */
    private void changeEntryType(ReadOnlyEntry target, ReadOnlyEntry editedEntry)
            throws DuplicateEntryException, OverlappingEventException, OverlappingAndOverdueEventException,
            EntryOverdueException, EntryNotFoundException {
        entryBook.removeEntry(target);
        try {
            entryBook.addEntry(editedEntry);
        } catch (DuplicateEntryException dee) {
            // revert back to initial state
            try {
                entryBook.addEntry(target);
            } catch (OverlappingEventException | OverlappingAndOverdueEventException
                     | EntryOverdueException e) {
                // Do nothing. Users do not need to be alerted of overlaps and overdue for reverting
            }
            throw dee;
        }
    }

    @Override
    public void changeEntryState(ReadOnlyEntry entryToChange, Entry.State newState)
            throws DuplicateEntryException, EntryNotFoundException, OverlappingEventException,
            OverlappingAndOverdueEventException, EntryOverdueException {
        try {
            entryBook.changeEntryState(entryToChange, newState);
        } catch (EntryNotFoundException | OverlappingEventException
                 | OverlappingAndOverdueEventException | EntryOverdueException e) {
            indicateEntryBookChanged();
            throw e;
        }
        indicateEntryBookChanged();
    }

    @Override
    public void clearStateSpecificEntries(Entry.State state) {
        entryBook.clearStateSpecificEntries(state);
        indicateEntryBookChanged();
    }

    // =========== Filtered Entry List Accessors ===========

    /**
     * Return a list of {@code ReadOnlyEntry} backed by the internal event list of
     * {@code entryBook}
     */
    @Override
    public UnmodifiableObservableList<ReadOnlyEntry> getFilteredEventList() {
        return new UnmodifiableObservableList<>(filteredEventList);
    }

    /**
     * Return a list of {@code ReadOnlyEntry} backed by the internal deadline list of
     * {@code entryBook}
     */
    @Override
    public UnmodifiableObservableList<ReadOnlyEntry> getFilteredDeadlineList() {
        return new UnmodifiableObservableList<>(filteredDeadlineList);
    }

    /**
     * Return a list of {@code ReadOnlyEntry} backed by the internal floating task list of
     * {@code entryBook}
     */
    @Override
    public UnmodifiableObservableList<ReadOnlyEntry> getFilteredFloatingTaskList() {
        return new UnmodifiableObservableList<>(filteredFloatingTaskList);
    }

    @Override
    public void updateAllFilteredListToShowAllActiveEntries() {
        this.updateAllFilteredLists(new HashSet<>(), null, null, Entry.State.ACTIVE, Search.AND);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    private void updateFilteredEventList(Expression expression) {
        filteredEventList.setPredicate(expression::satisfies);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    private void updateFilteredDeadlineList(Expression expression) {
        filteredDeadlineList.setPredicate(expression::satisfies);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    private void updateFilteredFloatingTaskList(Expression expression) {
        filteredFloatingTaskList.setPredicate(expression::satisfies);
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
    @Override
    public boolean equals(Object obj) {
        // short circuit if same object
        if (obj == this) {
            return true;
        }

        // instanceof handles nulls
        if (!(obj instanceof ModelManager)) {
            return false;
        }

        // state check
        ModelManager other = (ModelManager) obj;
        return entryBook.equals(other.entryBook) && filteredEventList.equals(other.filteredEventList)
               && filteredDeadlineList.equals(other.filteredDeadlineList)
               && filteredFloatingTaskList.equals(other.filteredFloatingTaskList);
    }

    // ========== Inner classes/interfaces used for filtering ==========

    interface Expression {
        /**
         * Evaluates whether a ReadOnlyEntry satisfies a certain condition.
         */
        boolean satisfies(ReadOnlyEntry entry);

        @Override
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyEntry entry) {
            return qualifier.run(entry);
        }

    }

    interface Qualifier {
        boolean run(ReadOnlyEntry entry);

        @Override
        String toString();
    }

```
###### \java\seedu\multitasky\model\ModelManager.java
``` java
        /**
         * Parses and concatenates all words in an entry's name and tags.
         *
         * @param entry
         * @return String
         */
        protected String parseWordsInNameAndTags(ReadOnlyEntry entry) {
            StringBuilder builder = new StringBuilder();
            builder.append(entry.getName().fullName.replaceAll("\\s+", ""));
            for (Tag t : entry.getTags()) {
                builder.append(t.tagName);
            }
            return builder.toString();
        }

```
###### \java\seedu\multitasky\model\util\TagSetBuilder.java
``` java
/**
 * Provides utility methods to build sets of Tags
 */
public class TagSetBuilder {

    /**
     * Returns a tag set containing the list of strings given.
     */
    public static Set<Tag> getTagSet(String... strings) throws IllegalValueException {
        HashSet<Tag> tags = new HashSet<>();
        for (String s : strings) {
            tags.add(new Tag(s));
        }
        return tags;
    }

}
```
