# A0140633R
###### \java\seedu\multitasky\logic\CommandHistoryTest.java
``` java
public class CommandHistoryTest {
    private CommandHistory history;

    @Before
    public void setUp() {
        history = new CommandHistory();
    }

    @Test
    public void add_anyCommand_success() {
        final String validCommand = "clear";
        final String invalidCommand = "adds Task";

        history.add(validCommand);
        history.add(invalidCommand);
        assertEquals(Arrays.asList(validCommand, invalidCommand), history.getHistory());
    }

    @Test
    public void setPrevSearch_validArgs_success() {
        Calendar startDate = Calendar.getInstance();
        Calendar endDate = Calendar.getInstance();
        Set<String> keywords = new HashSet<String>(Arrays.asList("new keywords"));
        Entry.State state = Entry.State.ARCHIVED;
        history.setPrevSearch(keywords, startDate, endDate, state);

        assertEquals(history.getPrevKeywords(), keywords);
        assertEquals(history.getPrevStartDate(), startDate);
        assertEquals(history.getPrevEndDate(), endDate);
        assertEquals(history.getPrevState(), state);
    }

    @Test
    public void setEditHistory_validArgs_success() {
        assertFalse(history.hasEditHistory());

        EditEntryDescriptor editEntryDescriptor = new EditEntryDescriptor();
        history.setEditHistory(editEntryDescriptor);
        assertTrue(history.hasEditHistory());
        assertEquals(history.getEditHistory(), editEntryDescriptor);
    }

}
```
###### \java\seedu\multitasky\logic\commands\AddCommandTest.java
``` java
    @Test
    public void execute_entryAcceptedByModel_addSuccessful() throws Exception {
        ModelStubAcceptingEntryAdded modelStub = new ModelStubAcceptingEntryAdded();
        ArrayList<Entry> expectedEntryList = new ArrayList<>();
        // Floating task
        Entry validEntry = SampleEntries.COOK;
        expectedEntryList.add(validEntry);
        CommandResult commandResult = getAddCommandForEntry(validEntry, modelStub).execute();
        assertEquals(String.format(AddCommand.MESSAGE_SUCCESS, validEntry), commandResult.feedbackToUser);
        assertEquals(expectedEntryList, modelStub.entrysAdded);

        // Deadline
        validEntry = SampleEntries.TAX;
        expectedEntryList.add(validEntry);
        commandResult = getAddCommandForEntry(validEntry, modelStub).execute();
        assertEquals(String.format(AddCommand.MESSAGE_SUCCESS, validEntry), commandResult.feedbackToUser);
        assertEquals(expectedEntryList, modelStub.entrysAdded);

        // Event
        validEntry = SampleEntries.TAX;
        expectedEntryList.add(validEntry);
        commandResult = getAddCommandForEntry(validEntry, modelStub).execute();
        assertEquals(String.format(AddCommand.MESSAGE_SUCCESS, validEntry), commandResult.feedbackToUser);
        assertEquals(expectedEntryList, modelStub.entrysAdded);
    }
```
###### \java\seedu\multitasky\logic\commands\AddCommandTest.java
``` java

    /**
     * Generates a new AddCommand with the details of the given entry.
     */
    private AddCommand getAddCommandForEntry(Entry entry, Model model) throws IllegalValueException {
        AddCommand command = new AddCommand(entry);
        command.setData(model, new CommandHistory());
        return command;
    }

    /**
     * A default model stub that have all of the methods failing.
     */
    private class ModelStub implements Model {

        @Override
        public void resetData(ReadOnlyEntryBook newData) {
            fail("This method should not be called.");
        }

        @Override
        public ReadOnlyEntryBook getEntryBook() {
            fail("This method should not be called.");
            return null;
        }

        @Override
        public void deleteEntry(ReadOnlyEntry target) throws EntryNotFoundException {
            fail("This method should not be called.");
        }

        @Override
        public void addEntry(ReadOnlyEntry entry) {
            fail("This method should not be called.");
        }

        @Override
        public void updateEntry(ReadOnlyEntry target, ReadOnlyEntry editedEntry)
                throws EntryNotFoundException {
            fail("This method should not be called.");
        }

        @Override
        public UnmodifiableObservableList<ReadOnlyEntry> getFilteredEventList() {
            fail("This method should not be called.");
            return null;
        }

        @Override
        public UnmodifiableObservableList<ReadOnlyEntry> getFilteredDeadlineList() {
            fail("This method should not be called.");
            return null;
        }

        @Override
        public UnmodifiableObservableList<ReadOnlyEntry> getFilteredFloatingTaskList() {
            fail("This method should not be called.");
            return null;
        }

        @Override
        public void updateAllFilteredLists(Set<String> keywords, Calendar startDate, Calendar endDate,
                                           Entry.State state, Search... searches) {
            fail("This method should not be called.");
        }

        @Override
        public void updateAllFilteredLists(Set<String> keywords, Calendar startDate, Calendar endDate,
                                           Entry.State state, Entry.State state2, Search... searches) {
            fail("This method should not be called.");
        }

        @Override
        public void updateFilteredFloatingTaskList(Set<String> keywords, Calendar startDate, Calendar endDate,
                                                   Entry.State state, Search search, int level) {
            fail("This method should not be called.");
        }

        @Override
        public void undoPreviousAction() {
            fail("This method should not be called.");
        }

        @Override
        public void redoPreviousAction() throws NothingToRedoException {
            fail("This method should not be called.");
        }

        @Override
        public void updateSortingComparators(Comparator<ReadOnlyEntry> eventComparator,
                                             Comparator<ReadOnlyEntry> deadlineComparator,
                                             Comparator<ReadOnlyEntry> floatingTaskComparator) {
            fail("This method should not be called.");
        }

        @Override
        public void updateAllFilteredListToShowAllActiveEntries() {
            fail("This method should not be called.");
        }

        @Override
        public void changeEntryState(ReadOnlyEntry entryToChange, State newState)
                throws DuplicateEntryException, EntryNotFoundException {
            fail("This method should not be called.");
        }

        @Override
        public void changeFilePath(String newFilePath) {
            fail("This method should not be called.");
        }

        @Override
        public void openFilePath(String newFilePath) {
            fail("This method should not be called.");
        }

        @Override
        public void clearStateSpecificEntries(State state) {
            fail("This method should not be called.");
        }

    }

    /**
     * A Model stub that always accept the entry being added.
     */
    private class ModelStubAcceptingEntryAdded extends ModelStub {
        final ArrayList<Entry> entrysAdded = new ArrayList<>();

        @Override
        public void addEntry(ReadOnlyEntry entry) {
            if (entry instanceof FloatingTask) {
                entrysAdded.add(EntryBuilder.build(entry));
            } else if (entry instanceof Deadline) {
                entrysAdded.add(EntryBuilder.build(entry));
            } else if (entry instanceof Event) {
                entrysAdded.add(EntryBuilder.build(entry));
            } else {
                throw new AssertionError("can only add float,deadline or event");
            }
        }
    }

}
```
###### \java\seedu\multitasky\logic\commands\DeleteByFindCommandTest.java
``` java
/**
 * Contains integration tests (interaction with the Model) and unit tests for {@code DeleteByFindCommand}.
 */
public class DeleteByFindCommandTest {

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Test
    public void execute_validKeywordsUnfilteredList_success() throws Exception {
        Model model = new ModelManager(SampleEntries.getSampleEntryBookWithActiveEntries(), new UserPrefs());

        ReadOnlyEntry entryToDelete = model.getFilteredFloatingTaskList()
                                           .get(INDEX_FIRST_ENTRY.getZeroBased());

        String searchString = entryToDelete.getName().fullName.replaceAll("\\\\", "");
        HashSet<String> keywords = new HashSet<>(Arrays.asList(searchString.split("\\s+")));

        DeleteCommand deleteCommand = prepareCommand(model, keywords);
        String expectedMessage = String.format(DeleteByFindCommand.MESSAGE_SUCCESS, entryToDelete);
        ModelManager expectedModel = new ModelManager(model.getEntryBook(), new UserPrefs());

        CommandResult result = deleteCommand.execute();
        assertEquals(result.feedbackToUser, expectedMessage);

        expectedModel.changeEntryState(entryToDelete, Entry.State.DELETED);
        expectedModel.updateAllFilteredListToShowAllActiveEntries();
        assertEquals(model, expectedModel);
    }

    @Test
    public void execute_noEntryFoundUnfilteredList_throwsCommandException() throws Exception {
        thrown.expect(CommandException.class);
        thrown.expectMessage(DeleteByFindCommand.MESSAGE_NO_ENTRIES);

        Model model = new ModelManager(SampleEntries.getSampleEntryBookWithActiveEntries(), new UserPrefs());
        String searchString = "randomstring";
        HashSet<String> keywords = new HashSet<>(Arrays.asList(searchString.split("\\s+")));
        DeleteCommand deleteCommand = prepareCommand(model, keywords);
        deleteCommand.execute();
    }

    @Test
    public void execute_multipleEntriesFoundFilteredList_throwsCommandException() throws Exception {
        thrown.expect(CommandException.class);
        thrown.expectMessage(DeleteByFindCommand.MESSAGE_MULTIPLE_ENTRIES);

        Model model = new ModelManager(SampleEntries.getSampleEntryBookWithActiveEntries(), new UserPrefs());
        String searchString = "try to find";
        HashSet<String> keywords = new HashSet<>(Arrays.asList(searchString.split("\\s+")));
        model.addEntry(EntryBuilder.build(searchString + " 1", "first_tag"));
        model.addEntry(EntryBuilder.build(searchString + " 2", "second_tag"));
        model.addEntry(EntryBuilder.build(searchString + " 3", "third_tag"));
        DeleteCommand deleteCommand = prepareCommand(model, keywords);
        deleteCommand.execute();
    }

    @Test
    public void execute_validKeywordsFilteredList_success() throws Exception {
        Model model = new ModelManager(SampleEntries.getSampleEntryBookWithActiveEntries(), new UserPrefs());

        showFirstEntryOnly(model);
        ReadOnlyEntry entryToDelete = model.getFilteredFloatingTaskList()
                                           .get(INDEX_FIRST_ENTRY.getZeroBased());

        String searchString = entryToDelete.getName().fullName;
        HashSet<String> keywords = new HashSet<>(Arrays.asList(searchString.split("\\s+")));

        DeleteCommand deleteCommand = prepareCommand(model, keywords);
        String expectedMessage = String.format(DeleteByFindCommand.MESSAGE_SUCCESS, entryToDelete);
        ModelManager expectedModel = new ModelManager(model.getEntryBook(), new UserPrefs());

        CommandResult result = deleteCommand.execute();
        assertEquals(result.feedbackToUser, expectedMessage);

        expectedModel.changeEntryState(entryToDelete, Entry.State.DELETED);
        expectedModel.updateAllFilteredListToShowAllActiveEntries();
        assertEquals(model, expectedModel);
    }

    /**
     * Returns a {@code DeleteCommand} with the parameter {@code index}.
     */
    private DeleteCommand prepareCommand(Model model, Set<String> keywords) {
        DeleteCommand deleteCommand = new DeleteByFindCommand(keywords);
        deleteCommand.setData(model, new CommandHistory());
        return deleteCommand;
    }

    /**
     * Updates {@code model}'s filtered list to show only the first entry from the entry book.
     */
    private void showFirstEntryOnly(Model model) {
        ReadOnlyEntry entry = model.getEntryBook().getFloatingTaskList().get(0);
        final String[] splitName = entry.getName().fullName.split("\\s+");
        model.updateFilteredFloatingTaskList(new HashSet<>(Arrays.asList(splitName)),
                                             null, null, Entry.State.ACTIVE, Model.Search.AND,
                                             PowerMatch.UNUSED);

        assert model.getFilteredFloatingTaskList().size() == 1;
    }

}
```
###### \java\seedu\multitasky\logic\commands\EditByFindCommandTest.java
``` java
    @Test
    public void execute_allFieldsSpecifiedUnfilteredList_success() throws Exception {
        ReadOnlyEntry targetEntry = model.getFilteredEventList().get(0);
        String searchString = targetEntry.getName().fullName;
        HashSet<String> keywords = new HashSet<>(Arrays.asList(searchString.split("\\s+")));
        Entry editedEntry = EntryBuilder.build(VALID_NAME_CLEAN, ParserUtil.parseDate(VALID_DATE_12_JULY_17),
                ParserUtil.parseDate(VALID_DATE_20_DEC_17), VALID_TAG_URGENT, VALID_TAG_FRIEND);
        EditEntryDescriptor descriptor = new EditEntryDescriptorBuilder(editedEntry)
                .withName(VALID_NAME_CLEAN).withStartDate(VALID_DATE_12_JULY_17).withEndDate(VALID_DATE_20_DEC_17)
                .withTags(VALID_TAG_URGENT, VALID_TAG_FRIEND).build();
        EditCommand editCommand = prepareCommand(model, keywords, descriptor);
        String expectedMessage = String.format(EditByFindCommand.MESSAGE_SUCCESS_WITH_OVERDUE_ALERT,
                                               targetEntry, editedEntry);
        Model expectedModel = new ModelManager(SampleEntries.getSampleEntryBookWithActiveEntries(), new UserPrefs());
        try {
            expectedModel.updateEntry(expectedModel.getFilteredEventList().get(INDEX_FIRST_ENTRY.getZeroBased()),
                                      editedEntry);
        } catch (EntryOverdueException eoe) {
            // Do nothing. Accept overdue entries in test.
        }

        CommandResult result = editCommand.execute();

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedModel, model);
    }
```
###### \java\seedu\multitasky\logic\commands\EditByFindCommandTest.java
``` java

    @Test
    public void execute_someFieldsSpecifiedUnfilteredList_success() throws Exception {
        ReadOnlyEntry targetEntry = model.getFilteredDeadlineList().get(0);
        String searchString = targetEntry.getName().fullName;
        HashSet<String> keywords = new HashSet<>(Arrays.asList(searchString.split("\\s+")));
        Entry editedEntry = EntryBuilder.build(VALID_NAME_CLEAN, ParserUtil.parseDate(VALID_DATE_11_JULY_17),
                                               VALID_TAG_URGENT, VALID_TAG_FRIEND);
        EditEntryDescriptor descriptor = new EditEntryDescriptorBuilder(editedEntry)
                .withName(VALID_NAME_CLEAN).withEndDate(VALID_DATE_11_JULY_17)
                .withTags(VALID_TAG_URGENT, VALID_TAG_FRIEND).build();
        EditCommand editCommand = prepareCommand(model, keywords, descriptor);
        String expectedMessage = String.format(EditByFindCommand.MESSAGE_SUCCESS_WITH_OVERDUE_ALERT,
                                               targetEntry, editedEntry);
        Model expectedModel = new ModelManager(SampleEntries.getSampleEntryBookWithActiveEntries(), new UserPrefs());
        try {
            expectedModel.updateEntry(expectedModel.getFilteredDeadlineList().get(INDEX_FIRST_ENTRY.getZeroBased()),
                                      editedEntry);
        } catch (EntryOverdueException eoe) {
            // Do nothing. Accept overdue entries in test.
        }

        CommandResult result = editCommand.execute();

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedModel, model);
    }

    @Test
    public void execute_filteredList_success() throws Exception {
        showFirstEntryOnly();
        ReadOnlyEntry entryInFilteredList = model.getFilteredFloatingTaskList()
                                                 .get(INDEX_FIRST_ENTRY.getZeroBased());
        String searchString = entryInFilteredList.getName().fullName;
        HashSet<String> keywords = new HashSet<>(Arrays.asList(searchString.split("\\s+")));
        Entry editedEntry = EntryBuilder.build();
        editedEntry.setName(new Name(VALID_NAME_MEETING));
        editedEntry.setTags(entryInFilteredList.getTags());
        EditCommand editCommand = prepareCommand(model, keywords,
                                                 new EditEntryDescriptorBuilder().withName(VALID_NAME_MEETING)
                                                                                 .build());
        String expectedMessage = String.format(EditByFindCommand.MESSAGE_SUCCESS, entryInFilteredList, editedEntry);
        Model expectedModel = new ModelManager(new EntryBook(model.getEntryBook()), new UserPrefs());

        CommandResult result = editCommand.execute();

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedModel, model);
    }

```
###### \java\seedu\multitasky\logic\commands\EditByFindCommandTest.java
``` java
    @Test
    public void execute_multipleEntriesFound_returnsMultipleEntriesMessage() throws Exception {
        thrown.expect(CommandException.class);
        thrown.expectMessage(EditByFindCommand.MESSAGE_MULTIPLE_ENTRIES);

        String searchString = "try to find";
        HashSet<String> keywords = new HashSet<>(Arrays.asList(searchString.split("\\s+")));
        model.addEntry(EntryBuilder.build(searchString + " 1", "first_tag"));
        model.addEntry(EntryBuilder.build(searchString + " 2", "second_tag"));
        model.addEntry(EntryBuilder.build(searchString + " 3", "third_tag"));
        EditEntryDescriptor editEntryDescriptor = new EditEntryDescriptor();
        EditCommand editCommand = prepareCommand(model, keywords, editEntryDescriptor);

        editCommand.execute();
    }

    @Test
    public void execute_noEntriesFound_returnsNoEntriesMessage() throws Exception {
        thrown.expect(CommandException.class);
        thrown.expectMessage(EditByFindCommand.MESSAGE_NO_ENTRIES);

        String searchString = "a random string";
        HashSet<String> keywords = new HashSet<>(Arrays.asList(searchString.split("\\s+")));
        EditEntryDescriptor editEntryDescriptor = new EditEntryDescriptor();
        EditCommand editCommand = prepareCommand(model, keywords, editEntryDescriptor);

        editCommand.execute();
    }
```
###### \java\seedu\multitasky\logic\commands\EditByIndexCommandTest.java
``` java
    @Test
    public void execute_allFieldsSpecifiedUnfilteredList_success() throws Exception {
        Entry editedEntry = EntryBuilder.build(VALID_NAME_CLEAN, parseDate(VALID_DATE_12_JULY_17),
                parseDate(VALID_DATE_20_DEC_17), VALID_TAG_URGENT, VALID_TAG_FRIEND);
        EditEntryDescriptor descriptor = new EditEntryDescriptorBuilder(editedEntry)
                .withName(VALID_NAME_CLEAN).withStartDate(VALID_DATE_12_JULY_17).withEndDate(VALID_DATE_20_DEC_17)
                .withTags(VALID_TAG_URGENT, VALID_TAG_FRIEND).build();
        EditCommand editCommand = prepareCommand(INDEX_FIRST_ENTRY, PREFIX_EVENT, descriptor);
        Model expectedModel = new ModelManager(SampleEntries.getSampleEntryBookWithActiveEntries(), new UserPrefs());
        String expectedMessage = String.format(EditCommand.MESSAGE_SUCCESS_WITH_OVERDUE_ALERT,
                                               model.getFilteredEventList().get(0), editedEntry);
        CommandResult result = editCommand.execute();
        try {
            expectedModel.updateEntry(expectedModel.getFilteredEventList().get(INDEX_FIRST_ENTRY.getZeroBased()),
                                      editedEntry);
        } catch (EntryOverdueException eoe) {
            // Do nothing. Accept overdue entries in test.
        }

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedModel, model);
    }
```
###### \java\seedu\multitasky\logic\commands\EditCommandTest.java
``` java
    @Test
    public void execute_editFloatingToEvent_success() throws Exception {
        ReadOnlyEntry targetEntry = model.getFilteredFloatingTaskList().get(INDEX_FIRST_ENTRY.getZeroBased());
        Entry editedEntry = EditCommandTestUtil.EVENT_BOWLING;
        EditEntryDescriptor descriptor = new EditEntryDescriptorBuilder(editedEntry).build();
        EditCommand editCommand = prepareCommand(INDEX_FIRST_ENTRY, PREFIX_FLOATINGTASK, descriptor);
        String expectedMessage = String.format(EditCommand.MESSAGE_SUCCESS, targetEntry, editedEntry);
        Model expectedModel = new ModelManager(SampleEntries.getSampleEntryBookWithActiveEntries(),
                                               new UserPrefs());
        expectedModel.updateEntry(targetEntry, editedEntry);
        CommandResult result = editCommand.execute();

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedModel, model);
    }

    @Test
    public void execute_editEventToDeadline_success() throws Exception {
        ReadOnlyEntry targetEntry = model.getFilteredEventList().get(INDEX_FIRST_ENTRY.getZeroBased());
        Entry editedEntry = EditCommandTestUtil.DEADLINE_EXAM;
        EditEntryDescriptor descriptor = new EditEntryDescriptorBuilder(editedEntry).withResetStartDate().build();
        EditCommand editCommand = prepareCommand(INDEX_FIRST_ENTRY, PREFIX_EVENT, descriptor);
        String expectedMessage = String.format(EditCommand.MESSAGE_SUCCESS, targetEntry, editedEntry);
        Model expectedModel = new ModelManager(SampleEntries.getSampleEntryBookWithActiveEntries(),
                                               new UserPrefs());
        expectedModel.updateEntry(targetEntry, editedEntry);
        CommandResult result = editCommand.execute();

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedModel, model);
    }

    @Test
    public void execute_editEventToFloating_success() throws Exception {
        ReadOnlyEntry targetEntry = model.getFilteredEventList().get(INDEX_FIRST_ENTRY.getZeroBased());
        Entry editedEntry = EditCommandTestUtil.FLOATINGTASK_DOG;
        EditEntryDescriptor descriptor = new EditEntryDescriptorBuilder(editedEntry)
                .withResetStartDate().withResetEndDate().build();
        EditCommand editCommand = prepareCommand(INDEX_FIRST_ENTRY, PREFIX_EVENT, descriptor);
        String expectedMessage = String.format(EditCommand.MESSAGE_SUCCESS, targetEntry, editedEntry);
        Model expectedModel = new ModelManager(SampleEntries.getSampleEntryBookWithActiveEntries(),
                                               new UserPrefs());
        expectedModel.updateEntry(targetEntry, editedEntry);
        CommandResult result = editCommand.execute();

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedModel, model);
    }

    @Test
    public void execute_editDeadlineToFullDayEvent_success() throws Exception {
        ReadOnlyEntry targetEntry = model.getFilteredDeadlineList().get(INDEX_FIRST_ENTRY.getZeroBased());
        Entry editedEntry = EditCommandTestUtil.EVENT_FULLDAY;
        EditEntryDescriptor descriptor = new EditEntryDescriptorBuilder(editedEntry).build();
        editedEntry = EditCommandTestUtil.EVENT_FULLDAY_CORRECTED;
        EditCommand editCommand = prepareCommand(INDEX_FIRST_ENTRY, PREFIX_DEADLINE, descriptor);
        String expectedMessage = String.format(EditCommand.MESSAGE_SUCCESS, targetEntry, editedEntry);
        Model expectedModel = new ModelManager(SampleEntries.getSampleEntryBookWithActiveEntries(),
                                               new UserPrefs());
        expectedModel.updateEntry(targetEntry, editedEntry);
        CommandResult result = editCommand.execute();

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedModel, model);
    }
```
###### \java\seedu\multitasky\logic\commands\EditCommandTest.java
``` java
    @Test
    public void execute_editToInvalidDate_throwsCommandException() throws Exception {
        thrown.expect(CommandException.class);
        thrown.expectMessage(EditCommand.MESSAGE_ENDDATE_BEFORE_STARTDATE);

        EditEntryDescriptor descriptor = new EditEntryDescriptorBuilder()
                .withStartDate(INVALID_CALENDAR_START).withEndDate(INVALID_CALENDAR_END).build();
        EditCommand editCommand = prepareCommand(INDEX_FIRST_ENTRY, PREFIX_FLOATINGTASK, descriptor);
        editCommand.execute();
    }
```
###### \java\seedu\multitasky\logic\parser\EditCommandParserTest.java
``` java
    @Test
    public void parse_invalidValue_failure() {
        // what index specified does not matter in these tests.
        assertParseFailure(PREFIX_DESC_FLOAT + " 1" + INVALID_NAME_DESC,
                           Name.MESSAGE_NAME_CONSTRAINTS); // invalid name

        // while parsing {@code PREFIX_TAG} alone will reset the tags of the {@code Entry} being edited,
        // parsing it together with a valid tag results in error
        assertParseFailure(PREFIX_DESC_FLOAT + " 1" + TAG_DESC_FRIEND + TAG_DESC_URGENT + TAG_EMPTY,
                           Tag.MESSAGE_TAG_CONSTRAINTS);
        assertParseFailure(PREFIX_DESC_FLOAT + " 1" + TAG_DESC_FRIEND + TAG_EMPTY + TAG_DESC_URGENT,
                           Tag.MESSAGE_TAG_CONSTRAINTS);
        assertParseFailure(PREFIX_DESC_FLOAT + " 1" + TAG_EMPTY + TAG_DESC_FRIEND + TAG_DESC_URGENT,
                           Tag.MESSAGE_TAG_CONSTRAINTS);

        // does not allow multiple list indicating index flags to be parsed
        assertParseFailure(PREFIX_DESC_FLOAT + "1" + PREFIX_DESC_EVENT + "1"
                           + TAG_DESC_FRIEND, MESSAGE_INVALID_FORMAT);

        // does not allow tag and addtag to be used together, illogical combination
        assertParseFailure(PREFIX_DESC_FLOAT + "1" + PREFIX_DESC_EVENT + "1"
                + TAG_DESC_FRIEND + ADDTAG_DESC_URGENT, MESSAGE_INVALID_FORMAT);

        // does not allow parsing of terms prettyTime lib does not recognize.
        assertParseFailure(PREFIX_DESC_FLOAT + " 1" + INVALID_DATE_END_DESC,
                           String.format(MESSAGE_FAIL_PARSE_DATE, "end of time"));
        // catches all start date invalid values before end date ones
        assertParseFailure(PREFIX_DESC_FLOAT + " 1" + INVALID_DATE_START_DESC + INVALID_DATE_END_DESC,
                           String.format(MESSAGE_FAIL_PARSE_DATE, "start of time"));
        assertParseFailure(PREFIX_DESC_FLOAT + " 1" + INVALID_DATE_END_DESC + INVALID_DATE_START_DESC,
                           String.format(MESSAGE_FAIL_PARSE_DATE, "start of time"));

        // multiple invalid values, but only the first invalid value is captured
        assertParseFailure(PREFIX_DESC_FLOAT + " 1" + INVALID_NAME_DESC + INVALID_TAG_DESC,
                           Name.MESSAGE_NAME_CONSTRAINTS);
    }

    @Test
    public void parse_byIndexAllFieldsSpecified_success() throws Exception {
        Index targetIndex = INDEX_SECOND_ENTRY;
        String userInput = PREFIX_DESC_EVENT + targetIndex.getOneBased()
                + DATE_DESC_START_12JULY + DATE_DESC_END_20DEC + TAG_DESC_URGENT
                + NAME_DESC_CLEAN + TAG_DESC_FRIEND;
        EditEntryDescriptor descriptor = new EditEntryDescriptorBuilder().withName(VALID_NAME_CLEAN)
                .withTags(VALID_TAG_URGENT, VALID_TAG_FRIEND).withStartDate(VALID_DATE_12_JULY_17)
                .withEndDate(VALID_DATE_20_DEC_17).build();
        EditCommand expectedCommand = new EditByIndexCommand(targetIndex, PREFIX_EVENT, descriptor);

        assertParseSuccess(userInput, expectedCommand);
    }

    @Test
    public void parse_byFindAllFieldsSpecified_success() throws Exception {
        String searchString = "typical entryname";
        String[] keywords = searchString.split("\\s+");
        Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        String userInput = searchString + DATE_DESC_START_12JULY + DATE_DESC_END_20DEC + TAG_DESC_URGENT
                + NAME_DESC_CLEAN + TAG_DESC_FRIEND;
        EditEntryDescriptor descriptor = new EditEntryDescriptorBuilder().withName(VALID_NAME_CLEAN)
                .withTags(VALID_TAG_URGENT, VALID_TAG_FRIEND).withStartDate(VALID_DATE_12_JULY_17)
                .withEndDate(VALID_DATE_20_DEC_17).build();
        EditCommand expectedCommand = new EditByFindCommand(keywordSet, descriptor);

        assertParseSuccess(userInput, expectedCommand);

        // search with escape words
        searchString = "typical entry with escaped words \\name \\by \\at \\on";
        keywords = searchString.split("\\s+");
        keywordSet = new HashSet<>(Arrays.asList(keywords));
        userInput = searchString + DATE_DESC_START_12JULY + DATE_DESC_END_20DEC + TAG_DESC_URGENT
                + NAME_DESC_CLEAN + TAG_DESC_FRIEND;
        descriptor = new EditEntryDescriptorBuilder().withName(VALID_NAME_CLEAN)
                .withTags(VALID_TAG_URGENT, VALID_TAG_FRIEND).withStartDate(VALID_DATE_12_JULY_17)
                .withEndDate(VALID_DATE_20_DEC_17).build();
        expectedCommand = new EditByFindCommand(keywordSet, descriptor);

        assertParseSuccess(userInput, expectedCommand);
    }

    @Test
    public void parse_byIndexSomeFieldsSpecified_success() throws Exception {
        Index targetIndex = INDEX_FIRST_ENTRY;
        String userInput = PREFIX_DESC_FLOAT + targetIndex.getOneBased() + NAME_DESC_MEETING + TAG_DESC_URGENT;

        EditEntryDescriptor descriptor = new EditEntryDescriptorBuilder().withName(VALID_NAME_MEETING)
                                                                         .withTags(VALID_TAG_URGENT).build();
        EditCommand expectedCommand = new EditByIndexCommand(targetIndex, PREFIX_FLOATINGTASK, descriptor);

        assertParseSuccess(userInput, expectedCommand);

        // start date == end date
        userInput = PREFIX_DESC_FLOAT + targetIndex.getOneBased() + DATE_DESC_START_12JULY + DATE_DESC_END_12JULY;
        descriptor = new EditEntryDescriptorBuilder().withStartDate(VALID_DATE_12_JULY_17)
                                                     .withEndDate(VALID_DATE_12_JULY_17).build();
        expectedCommand = new EditByIndexCommand(targetIndex, PREFIX_EVENT, descriptor);
        assertParseSuccess(userInput, expectedCommand);

        // full start date time given but only end time. parser should infer month, date fields from start date.
        userInput = PREFIX_DESC_FLOAT + targetIndex.getOneBased() + DATE_TIME_DESC_START_12JULY6PM
                    + TIME_DESC_END_9PM;
        descriptor = new EditEntryDescriptorBuilder().withStartDate(VALID_DATE_TIME_12_JULY_6PM)
                                                     .withEndDate(VALID_DATE_TIME_12_JULY_9PM).build();
        expectedCommand = new EditByIndexCommand(targetIndex, PREFIX_EVENT, descriptor);
        assertParseSuccess(userInput, expectedCommand);
    }

```
###### \java\seedu\multitasky\logic\parser\EditCommandParserTest.java
``` java
    @Test
    public void parse_byIndexOneFieldSpecified_success() throws Exception {
        // name
        Index targetIndex = INDEX_THIRD_ENTRY;
        String userInput = PREFIX_DESC_FLOAT + targetIndex.getOneBased() + NAME_DESC_CLEAN;
        EditEntryDescriptor descriptor = new EditEntryDescriptorBuilder().withName(VALID_NAME_CLEAN).build();
        EditCommand expectedCommand = new EditByIndexCommand(targetIndex, PREFIX_FLOATINGTASK, descriptor);
        assertParseSuccess(userInput, expectedCommand);

        // tags
        userInput = PREFIX_DESC_FLOAT + targetIndex.getOneBased() + TAG_DESC_FRIEND;
        descriptor = new EditEntryDescriptorBuilder().withTags(VALID_TAG_FRIEND).build();
        expectedCommand = new EditByIndexCommand(targetIndex, PREFIX_FLOATINGTASK, descriptor);
        assertParseSuccess(userInput, expectedCommand);

        // addtag
        userInput = PREFIX_DESC_FLOAT + targetIndex.getOneBased() + ADDTAG_DESC_URGENT;
        descriptor = new EditEntryDescriptorBuilder().withAddTags(VALID_TAG_URGENT).build();
        expectedCommand = new EditByIndexCommand(targetIndex, PREFIX_FLOATINGTASK, descriptor);
        assertParseSuccess(userInput, expectedCommand);

        // start date
        userInput = PREFIX_DESC_EVENT + targetIndex.getOneBased() + DATE_DESC_START_12JULY;
        descriptor = new EditEntryDescriptorBuilder().withStartDate(VALID_DATE_12_JULY_17).build();
        expectedCommand = new EditByIndexCommand(targetIndex, PREFIX_EVENT, descriptor);
        assertParseSuccess(userInput, expectedCommand);

        // end date
        userInput = PREFIX_DESC_DEADLINE + targetIndex.getOneBased() + DATE_DESC_END_11JULY;
        descriptor = new EditEntryDescriptorBuilder().withEndDate(VALID_DATE_11_JULY_17).build();
        expectedCommand = new EditByIndexCommand(targetIndex, PREFIX_DEADLINE, descriptor);
        assertParseSuccess(userInput, expectedCommand);
    }

    @Test
    public void parse_byFindOneFieldSpecified_success() throws Exception {
        String searchString = "typical entryname";
        String[] keywords = searchString.split("\\s+");
        Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));

        // name
        String userInput = searchString + NAME_DESC_CLEAN;
        EditEntryDescriptor descriptor = new EditEntryDescriptorBuilder().withName(VALID_NAME_CLEAN).build();
        EditCommand expectedCommand = new EditByFindCommand(keywordSet, descriptor);
        assertParseSuccess(userInput, expectedCommand);

        // tags
        userInput = searchString + TAG_DESC_URGENT;
        descriptor = new EditEntryDescriptorBuilder().withTags(VALID_TAG_URGENT).build();
        expectedCommand = new EditByFindCommand(keywordSet, descriptor);
        assertParseSuccess(userInput, expectedCommand);

        // start date
        userInput = searchString + DATE_DESC_START_12JULY;
        descriptor = new EditEntryDescriptorBuilder().withStartDate(VALID_DATE_12_JULY_17).build();
        expectedCommand = new EditByFindCommand(keywordSet, descriptor);
        assertParseSuccess(userInput, expectedCommand);

        // end date
        userInput = searchString + DATE_DESC_END_11JULY;
        descriptor = new EditEntryDescriptorBuilder().withEndDate(VALID_DATE_11_JULY_17).build();
        expectedCommand = new EditByFindCommand(keywordSet, descriptor);
        assertParseSuccess(userInput, expectedCommand);
    }

    @Test
    public void parse_withSavedDescriptor_success() throws Exception {
        String searchString = "typical entryname";
        String[] keywords = searchString.split("\\s+");
        Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));

        // assumes editEntry has been saved in history
        history.setEditHistory(EditCommandTestUtil.DESC_MEETING);

        String userInput = searchString;
        EditEntryDescriptor descriptor = history.getEditHistory();
        EditCommand expectedCommand = new EditByFindCommand(keywordSet, descriptor);
        assertParseSuccess(userInput, expectedCommand);
    }
```
###### \java\seedu\multitasky\logic\parser\ParserTest.java
``` java
    @Test
    public void parseCommand_clear_success() throws Exception {
        assertTrue(parser.parseCommand(ClearCommand.COMMAND_WORD, userprefs, history) instanceof ClearCommand);
    }

    @Test
    public void parseCommand_undo_success() throws Exception {
        assertTrue(parser.parseCommand(UndoCommand.COMMAND_WORD, userprefs, history) instanceof UndoCommand);
    }

    @Test
    public void parseCommand_redo_success() throws Exception {
        assertTrue(parser.parseCommand(RedoCommand.COMMAND_WORD, userprefs, history) instanceof RedoCommand);
    }

}
```
###### \java\seedu\multitasky\logic\parser\ParserUtilTest.java
``` java
/**
 * Contains unit tests for ParserUtil methods used by the parser classes.
 */
```
###### \java\seedu\multitasky\logic\parser\ParserUtilTest.java
``` java
    @Test
    public void arePrefixesPresent_emptyArgMap_throwsNullPointerException() throws Exception {
        thrown.expect(NullPointerException.class);
        ArgumentMultimap argMultimap = null;
        ParserUtil.arePrefixesPresent(argMultimap, VALID_PREFIX_FLOAT, VALID_PREFIX_TAG);
    }

    @Test
    public void arePrefixesPresent_noPrefixFound_returnFalse() {
        String argString = " typical argument string without flags";
        ArgumentMultimap argMultimap = ArgumentTokenizer.tokenize(argString, VALID_PREFIX_TAG,
                                                                  VALID_PREFIX_FLOAT);
        assertFalse(ParserUtil.arePrefixesPresent(argMultimap, VALID_PREFIX_TAG, VALID_PREFIX_FLOAT));
    }

    @Test
    public void arePrefixesPresent_prefixFound_returnTrue() {
        String argString = " typical argument string with flags float 1 tag flagged tagged";
        ArgumentMultimap argMultimap = ArgumentTokenizer.tokenize(argString, VALID_PREFIX_TAG,
                                                                  VALID_PREFIX_FLOAT);
        assertTrue(ParserUtil.arePrefixesPresent(argMultimap, VALID_PREFIX_TAG, VALID_PREFIX_FLOAT));
    }

    public void areAllPrefixesPresent_emptyArgMap_throwsNullPointerException() throws Exception {
        thrown.expect(NullPointerException.class);
        ArgumentMultimap argMultimap = null;
        ParserUtil.areAllPrefixesPresent(argMultimap, VALID_PREFIX_FLOAT, VALID_PREFIX_TAG);
    }

    @Test
    public void areAllPrefixesPresent_allPrefixFound_returnTrue() {
        String argString = " typical argument string with flags float 1 tag flagged tagged";
        ArgumentMultimap argMultimap = ArgumentTokenizer.tokenize(argString, VALID_PREFIX_TAG,
                                                                  VALID_PREFIX_FLOAT);
        assertTrue(ParserUtil.areAllPrefixesPresent(argMultimap, VALID_PREFIX_TAG, VALID_PREFIX_FLOAT));
    }

    @Test
    public void areAllPrefixesPresent_notAllPrefixFound_returnFalse() {
        // only 1 prefix in arg
        String argString = " typical argument string with flags tag flagged tagged";
        ArgumentMultimap argMultimap = ArgumentTokenizer.tokenize(argString, VALID_PREFIX_TAG,
                                                                  VALID_PREFIX_FLOAT);
        assertFalse(ParserUtil.areAllPrefixesPresent(argMultimap, VALID_PREFIX_TAG, VALID_PREFIX_FLOAT));

        // no prefixes in arg
        argString = " typical argument string without flags";
        argMultimap = ArgumentTokenizer.tokenize(argString, VALID_PREFIX_TAG, VALID_PREFIX_FLOAT);
        assertFalse(ParserUtil.areAllPrefixesPresent(argMultimap, VALID_PREFIX_TAG, VALID_PREFIX_FLOAT));
    }

    @Test
    public void parseDate_emptyString_throwsIllegalValueException() throws Exception {
        thrown.expect(IllegalValueException.class);
        ParserUtil.parseDate("");
    }

    @Test
    public void parseDate_optionalEmpty_returnsOptionalEmpty() throws Exception {
        assertFalse(ParserUtil.parseDate(Optional.empty()).isPresent());
    }

    @Test
    public void parseDate_validValue_returnsCalendar() throws Exception {
        Calendar expectedCalendar = new GregorianCalendar();
        // following MM/dd/yy format of prettyTime dependency.
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yy HH:mm:ss");
        sdf.setLenient(false);
        Date expectedDate = sdf.parse(VALID_DATE);
        expectedCalendar.setTime(expectedDate);
        Optional<Calendar> actualCalendar = ParserUtil.parseDate(Optional.of(VALID_DATE));

        assertTrue(expectedCalendar.compareTo(actualCalendar.get()) == 0);
    }

    @Test
    public void parseExtendedDate_validValue_returnsCalendar() throws Exception {
        Calendar expectedCalendar = new GregorianCalendar();
        // following MM/dd/yy format of prettyTime dependency.
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yy HH:mm:ss");
        sdf.setLenient(false);
        Date expectedDate = sdf.parse(VALID_DATE_2);
        expectedCalendar.setTime(expectedDate);
        Optional<Calendar> actualCalendar = ParserUtil.parseExtendedDate(Optional.of(VALID_DATE),
                                                                         Optional.of(VALID_DATE_2));

        assertTrue(expectedCalendar.compareTo(actualCalendar.get()) == 0);
    }

    @Test
    public void getMainPrefix_preconditionFailed_throwsAssertionError() throws Exception {
        String argString = " typical argument string with flags flags float 1 tag flagged tagged";
        ArgumentMultimap argMultimap = ArgumentTokenizer.tokenize(argString, VALID_PREFIX_TAG,
                                                                  VALID_PREFIX_FLOAT);
        thrown.expect(AssertionError.class);
        ParserUtil.getMainPrefix(argMultimap, VALID_PREFIX_TAG, VALID_PREFIX_FLOAT);
    }

    @Test
    public void getMainPrefix_validInput_success() throws Exception {
        String argString = " typical argument string with flag tag flagged tagged";
        ArgumentMultimap argMultimap = ArgumentTokenizer.tokenize(argString, VALID_PREFIX_TAG,
                                                                  VALID_PREFIX_FLOAT);
        Prefix expectedPrefix = VALID_PREFIX_TAG;
        Prefix actualPrefix = ParserUtil.getMainPrefix(argMultimap, VALID_PREFIX_TAG, VALID_PREFIX_FLOAT);
        assertEquals(expectedPrefix, actualPrefix);
    }

}
```
###### \java\seedu\multitasky\testutil\EditCommandTestUtil.java
``` java
/**
 * Utility class containing the constants required for tests related to EditCommand
 */
public class EditCommandTestUtil {
    public static final String VALID_NAME_CLEAN = "Clean the house";
    public static final String VALID_NAME_MEETING = "Meet the boss";
    public static final String VALID_NAME_BOWLING = "go and play bowling";
    public static final String VALID_NAME_DOG = "walk the dog";
    public static final String VALID_NAME_EXAM = "final exams";
    public static final String VALID_NAME_FULLDAY = "work for 24/7";
    public static final String VALID_TAG_URGENT = "urgent";
    public static final String VALID_TAG_FRIEND = "friend";
    public static final String VALID_DATE_12_JULY_17 = "12 july 17";
    public static final String VALID_DATE_TIME_12_JULY_6PM = "12 july 6pm";
    public static final String VALID_TIME_9PM = "9pm";
    public static final String VALID_DATE_TIME_12_JULY_9PM = "12 july 9pm";
    public static final String VALID_DATE_11_JULY_17 = "11 july 17";
    public static final String VALID_DATE_20_DEC_17 = "12 dec 17";
    public static final Calendar VALID_CALENDAR_1 = new GregorianCalendar(2020, Calendar.JANUARY, 25, 18, 00);
    public static final Calendar VALID_CALENDAR_2 = new GregorianCalendar(2020, Calendar.JANUARY, 25, 19, 00);
    public static final Calendar VALID_CALENDAR_3 = new GregorianCalendar(2030, Calendar.JANUARY, 25, 04, 00);
    public static final Calendar VALID_CALENDAR_4 = new GregorianCalendar(2030, Calendar.JANUARY, 25, 12, 00);
    public static final Calendar VALID_CALENDAR_4_1 = new GregorianCalendar(2030, Calendar.JANUARY, 25, 00, 00);
    public static final Calendar VALID_CALENDAR_4_2 = new GregorianCalendar(2030, Calendar.JANUARY, 25, 23, 59);
    public static final Calendar INVALID_CALENDAR_START = new GregorianCalendar(2030, Calendar.JANUARY, 25, 23, 59);
    public static final Calendar INVALID_CALENDAR_END = new GregorianCalendar(2030, Calendar.JANUARY, 24, 00, 00);

    public static final EditEntryDescriptor DESC_CLEAN;
    public static final EditEntryDescriptor DESC_MEETING;
    public static final EditEntryDescriptor DESC_FULL;
    public static final Entry EVENT_BOWLING;
    public static final Entry EVENT_FULLDAY;
    public static final Entry EVENT_FULLDAY_CORRECTED;
    public static final Entry DEADLINE_EXAM;
    public static final Entry FLOATINGTASK_DOG;


    static {
        try {
            DESC_CLEAN = new EditEntryDescriptorBuilder().withName(VALID_NAME_CLEAN)
                                                         .withTags(VALID_TAG_FRIEND).build();
            DESC_MEETING = new EditEntryDescriptorBuilder().withName(VALID_NAME_MEETING)
                                                           .withTags(VALID_TAG_URGENT, VALID_TAG_FRIEND)
                                                           .build();

            DESC_FULL = new EditEntryDescriptorBuilder().withName(VALID_NAME_CLEAN).withTags(VALID_TAG_URGENT)
                    .withAddTags(VALID_TAG_FRIEND).withStartDate(VALID_CALENDAR_1).withEndDate(VALID_CALENDAR_2)
                    .withResetStartDate().withResetEndDate().build();

            EVENT_BOWLING = EntryBuilder.build(new Name(VALID_NAME_BOWLING),
                                               VALID_CALENDAR_1,
                                               VALID_CALENDAR_2,
                                               "with", "colleagues");

            DEADLINE_EXAM = EntryBuilder.build(new Name(VALID_NAME_EXAM),
                                               VALID_CALENDAR_1,
                                               "hard", "study");

            EVENT_FULLDAY = EntryBuilder.build(new Name(VALID_NAME_FULLDAY),
                                               VALID_CALENDAR_4,
                                               VALID_CALENDAR_4,
                                               "tags");

            EVENT_FULLDAY_CORRECTED = EntryBuilder.build(new Name(VALID_NAME_FULLDAY),
                                               VALID_CALENDAR_4_1,
                                               VALID_CALENDAR_4_2,
                                               "tags");

            FLOATINGTASK_DOG = EntryBuilder.build(VALID_NAME_DOG);

        } catch (IllegalValueException ive) {
            throw new AssertionError("Method should not fail.");
        }
    }
}
```
###### \java\seedu\multitasky\testutil\EditEntryDescriptorBuilder.java
``` java
    /**
     * Returns an {@code EditEntryDescriptor} with fields containing {@code entry}'s details
     */
    public EditEntryDescriptorBuilder(ReadOnlyEntry entry) throws IllegalValueException {
        descriptor = new EditEntryDescriptor();
        descriptor.setName(entry.getName());
        descriptor.setTags(entry.getTags());
        if (entry instanceof Deadline) {
            descriptor.setEndDate(entry.getEndDateAndTime());
        } else if (entry instanceof Event) {
            descriptor.setStartDate(entry.getStartDateAndTime());
            descriptor.setEndDate(entry.getEndDateAndTime());
        }
    }

    public EditEntryDescriptorBuilder withStartDate(String startDate) throws IllegalValueException {
        ParserUtil.parseDate(Optional.of(startDate)).ifPresent(descriptor::setStartDate);
        return this;
    }

    public EditEntryDescriptorBuilder withStartDate(Calendar startDate) throws IllegalValueException {
        descriptor.setStartDate(startDate);
        return this;
    }

    public EditEntryDescriptorBuilder withEndDate(String endDate) throws IllegalValueException {
        ParserUtil.parseDate(Optional.of(endDate)).ifPresent(descriptor::setEndDate);
        return this;
    }

    public EditEntryDescriptorBuilder withEndDate(Calendar endDate) throws IllegalValueException {
        descriptor.setEndDate(endDate);
        return this;
    }

    public EditEntryDescriptorBuilder withName(String name) throws IllegalValueException {
        ParserUtil.parseName(Optional.of(name)).ifPresent(descriptor::setName);
        return this;
    }

    public EditEntryDescriptorBuilder withTags(String... tags) throws IllegalValueException {
        descriptor.setTags(ParserUtil.parseTags(Arrays.asList(tags)));
        return this;
    }

    public EditEntryDescriptorBuilder withAddTags(String... tags) throws IllegalValueException {
        descriptor.setAddTags(ParserUtil.parseTags(Arrays.asList(tags)));
        return this;
    }

    public EditEntryDescriptorBuilder withResetStartDate() throws IllegalValueException {
        descriptor.setResetStartDate(true);
        return this;
    }

    public EditEntryDescriptorBuilder withResetEndDate() throws IllegalValueException {
        descriptor.setResetEndDate(true);
        return this;
    }

    public EditEntryDescriptor build() {
        return descriptor;
    }
}
```
