# A0125586X
###### \java\guitests\AddCommandTest.java
``` java
public class AddCommandTest extends EntryBookGuiTest {

    /******************************************
     * Adding a single entry to an empty list *
     ******************************************/
    @Test
    public void add_eventToEmptyList_success() {
        assertCleared();
        Entry[] currentList = new Entry[0];
        Entry entryToAdd = typicalEntries.cat;
        currentList = assertAddEvent(entryToAdd, currentList);
    }

    @Test
    public void add_deadlineToEmptyList_success() {
        assertCleared();
        Entry[] currentList = new Entry[0];
        Entry entryToAdd = typicalEntries.submission;
        currentList = assertAddDeadline(entryToAdd, currentList);
    }

    @Test
    public void add_floatingTaskToEmptyList_success() {
        assertCleared();
        Entry[] currentList = new Entry[0];
        Entry entryToAdd = typicalEntries.spectacles;
        currentList = assertAddFloatingTask(entryToAdd, currentList);
    }

    /********************************************
     * Adding multiple entries to an empty list *
     ********************************************/
    @Test
    public void add_multipleEventToEmptyList_success() {
        assertCleared();
        Entry[] currentList = new Entry[0];
        Entry entryToAdd = typicalEntries.dinner;
        currentList = assertAddEvent(entryToAdd, currentList);

        entryToAdd = typicalEntries.cat;
        currentList = assertAddEvent(entryToAdd, currentList);
    }

    @Test
    public void add_multipleDeadlineToEmptyList_success() {
        assertCleared();
        Entry[] currentList = new Entry[0];
        Entry entryToAdd = typicalEntries.paper;
        currentList = assertAddDeadline(entryToAdd, currentList);

        entryToAdd = typicalEntries.submission;
        currentList = assertAddDeadline(entryToAdd, currentList);
    }

    @Test
    public void add_multipleFloatingTaskToEmptyList_success() {
        assertCleared();
        Entry[] currentList = new Entry[0];
        Entry entryToAdd = typicalEntries.spectacles;
        currentList = assertAddFloatingTask(entryToAdd, currentList);

        entryToAdd = typicalEntries.clean;
        currentList = assertAddFloatingTask(entryToAdd, currentList);
    }

    /*********************************************
     * Adding a single entry to an existing list *
     *********************************************/
    @Test
    public void add_eventToExistingList_success() {
        Entry[] currentList = typicalEntries.getTypicalEvents();
        Entry entryToAdd = typicalEntries.movie;
        currentList = assertAddEvent(entryToAdd, currentList);
    }

    @Test
    public void add_deadlineToExistingList_success() {
        Entry[] currentList = typicalEntries.getTypicalDeadlines();
        Entry entryToAdd = typicalEntries.submission;
        currentList = assertAddDeadline(entryToAdd, currentList);
    }

    @Test
    public void add_floatingTaskToExistingList_success() {
        Entry[] currentList = typicalEntries.getTypicalFloatingTasks();
        Entry entryToAdd = typicalEntries.spectacles;
        currentList = assertAddFloatingTask(entryToAdd, currentList);
    }

    /***********************************************
     * Adding multiple entries to an existing list *
     ***********************************************/
    @Test
    public void add_multipleUniqueEventToExistingList_success() {
        Entry[] currentList = typicalEntries.getTypicalEvents();
        Entry entryToAdd = typicalEntries.movie;
        currentList = assertAddEvent(entryToAdd, currentList);

        entryToAdd = typicalEntries.opening;
        currentList = assertAddEvent(entryToAdd, currentList);
    }

    @Test
    public void add_multipleUniqueDeadlineToExistingList_success() {
        Entry[] currentList = typicalEntries.getTypicalDeadlines();
        Entry entryToAdd = typicalEntries.submission;
        currentList = assertAddDeadline(entryToAdd, currentList);

        entryToAdd = typicalEntries.upgrade;
        currentList = assertAddDeadline(entryToAdd, currentList);
    }

    @Test
    public void add_multipleUniqueFloatingTaskToExistingList_success() {
        Entry[] currentList = typicalEntries.getTypicalFloatingTasks();
        Entry entryToAdd = typicalEntries.spectacles;
        currentList = assertAddFloatingTask(entryToAdd, currentList);

        entryToAdd = typicalEntries.clean;
        currentList = assertAddFloatingTask(entryToAdd, currentList);
    }

    /**************************************
     * Different types of invalid wording *
     **************************************/
    @Test
    public void add_unknownCommandName_errorMessage() {
        commandBox.runCommand("ad");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand("addd");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void add_invalidCommandFormat_errorMessage() {
        commandBox.runCommand("add");
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));

        commandBox.runCommand("add /tag");
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
    }


    @Test
    public void add_invalidEntryName_errorMessage() {
        commandBox.runCommand("add $");
        assertResultMessage(Name.MESSAGE_NAME_CONSTRAINTS);

        commandBox.runCommand("add /");
        assertResultMessage(Name.MESSAGE_NAME_CONSTRAINTS);
    }

    @Test
    public void add_invalidTags_errorMessage() {
        commandBox.runCommand("add task /tag");
        assertResultMessage(Tag.MESSAGE_TAG_CONSTRAINTS);

        commandBox.runCommand("add task /tag $");
        assertResultMessage(Tag.MESSAGE_TAG_CONSTRAINTS);
    }

    /*******************************
     * Mixed-case and autocomplete *
     ******************************/
    /**
     * For all mixed-case tests only floating task entries are tested,
     * which should be suitable to test for all types since the type of task
     * doesn't affect the parsing of the command word.
     */
    @Test
    public void add_firstCharUppercase_success() {
        char[] commandWord = AddCommand.COMMAND_WORD.toCharArray();
        commandWord[0] = Character.toUpperCase(commandWord[0]);
        assertAddWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void add_lastCharUppercase_success() {
        char[] commandWord = AddCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length - 1] = Character.toUpperCase(commandWord[commandWord.length - 1]);
        assertAddWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void add_middleCharUppercase_success() {
        char[] commandWord = AddCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length / 2] = Character.toUpperCase(commandWord[commandWord.length / 2]);
        assertAddWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void add_allCharUppercase_success() {
        String commandWord = AddCommand.COMMAND_WORD.toUpperCase();
        assertAddWithCommandWord(commandWord);
    }

    @Test
    public void add_tabAutocomplete_success() {
        for (int i = 1; i < AddCommand.COMMAND_WORD.length(); ++i) {
            assertAddTabAutocomplete(AddCommand.COMMAND_WORD.substring(0, i));
        }
    }

    /**
     * Confirms that the given input string will autocomplete to the correct command word.
     */
    private void assertAddTabAutocomplete(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(AddCommand.COMMAND_WORD + " ");
    }

    /**
     * Helps with the testing of command words with different character cases
     */
    private void assertAddWithCommandWord(String commandWord) {
        Entry[] currentList = typicalEntries.getTypicalFloatingTasks();
        Entry entryToAdd = typicalEntries.spectacles;
        commandBox.runCommand(commandWord + " " + EntryUtil.getFloatingTaskDetailsForAdd(entryToAdd));
        assertFloatingTaskAdded(entryToAdd, currentList);
    }

    /**
     * Adds an event to the entry book as well as to the supplied array
     *
     */
    private Entry[] assertAddEvent(Entry entryToAdd, Entry... currentList) {
        assertAddEventSuccess(entryToAdd, currentList);
        return TestUtil.addEntriesToSortedList(currentList, entryToAdd);
    }

    /**
     * Adds a deadline to the entry book as well as to the supplied array
     *
     */
    private Entry[] assertAddDeadline(Entry entryToAdd, Entry... currentList) {
        assertAddDeadlineSuccess(entryToAdd, currentList);
        return TestUtil.addEntriesToSortedList(currentList, entryToAdd);
    }

    /**
     * Adds a floating task to the entry book as well as to the supplied array
     */
    private Entry[] assertAddFloatingTask(Entry entryToAdd, Entry... currentList) {
        assertAddFloatingTaskSuccess(entryToAdd, currentList);
        return TestUtil.addEntriesToList(currentList, entryToAdd);
    }

    /**
     * Clears all tasks and asserts that they have been cleared
     */
    private void assertCleared() {
        commandBox.runCommand(ClearCommand.COMMAND_WORD);
        //commandBox.runCommand(ClearCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_ARCHIVE);
        //commandBox.runCommand(ClearCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_BIN);
        assertTrue(eventListPanel.isEmpty());
        assertTrue(deadlineListPanel.isEmpty());
        assertTrue(floatingTaskListPanel.isEmpty());
    }

    /**
     * Attempts to add an entry as an event and confirms that it has been added.
     */
    private void assertAddEventSuccess(Entry entryToAdd, Entry... currentList) {
        commandBox.runCommand(EntryUtil.getEventAddCommand(entryToAdd));
        assertEventAdded(entryToAdd, currentList);
    }

    /**
     * Attempts to add an entry as a deadline and confirms that it has been added.
     */
    private void assertAddDeadlineSuccess(Entry entryToAdd, Entry... currentList) {
        commandBox.runCommand(EntryUtil.getDeadlineAddCommand(entryToAdd));
        assertDeadlineAdded(entryToAdd, currentList);
    }

    /**
     * Attempts to add an entry as a floating task and confirms that it has been added.
     */
    private void assertAddFloatingTaskSuccess(Entry entryToAdd, Entry... currentList) {
        commandBox.runCommand(EntryUtil.getFloatingTaskAddCommand(entryToAdd));
        assertFloatingTaskAdded(entryToAdd, currentList);
    }

    /**
     * Confirms that the added entry is in the expected list, and that the
     * expected list matches the displayed list.
     */
    private void assertEventAdded(Entry entryAdded, Entry... currentList) {
        EntryCardHandle addedCard = eventListPanel.navigateToEntry(entryAdded.getName().toString());
        assertMatching(entryAdded, addedCard);
        Entry[] expectedList = TestUtil.addEntriesToSortedList(currentList, entryAdded);
        assertTrue(eventListPanel.isListMatching(expectedList));
    }

    /**
     * Confirms that the added entry is in the expected list, and that the
     * expected list matches the displayed list.
     */
    private void assertDeadlineAdded(Entry entryAdded, Entry... currentList) {
        EntryCardHandle addedCard = deadlineListPanel.navigateToEntry(entryAdded.getName().toString());
        assertMatching(entryAdded, addedCard);
        Entry[] expectedList = TestUtil.addEntriesToSortedList(currentList, entryAdded);
        assertTrue(deadlineListPanel.isListMatching(expectedList));
    }

    /**
     * Confirms that the added entry is in the expected list, and that the
     * expected list matches the displayed list.
     */
    private void assertFloatingTaskAdded(Entry entryAdded, Entry... currentList) {
        EntryCardHandle addedCard = floatingTaskListPanel.navigateToEntry(entryAdded.getName().toString());
        assertMatching(entryAdded, addedCard);
        Entry[] expectedList = TestUtil.addEntriesToList(currentList, entryAdded);
        assertTrue(floatingTaskListPanel.isListMatching(expectedList));
    }

}
```
###### \java\guitests\ClearCommandTest.java
``` java
public class ClearCommandTest extends EntryBookGuiTest {

    /*********************
     * Clearing the list *
     ********************/
    @Test
    public void clear_emptyList_success() {
        assertClearCommandSuccess();
        assertClearCommandSuccess();
    }

    @Test
    public void clear_nonEmptyList_success() {
        assertFalse(eventListPanel.isEmpty());
        assertFalse(deadlineListPanel.isEmpty());
        assertFalse(floatingTaskListPanel.isEmpty());
        assertClearCommandSuccess();
    }

    /**********************************
     * Adding after clearing the list *
     *********************************/
    @Test
    public void clear_addEventAfterClear_success() {
        assertClearCommandSuccess();
        commandBox.runCommand(EntryUtil.getEventAddCommand(typicalEntries.cat));
        assertTrue(eventListPanel.isListMatching(typicalEntries.cat));
    }

    @Test
    public void clear_addDeadlineAfterClear_success() {
        assertClearCommandSuccess();
        commandBox.runCommand(EntryUtil.getDeadlineAddCommand(typicalEntries.submission));
        assertTrue(deadlineListPanel.isListMatching(typicalEntries.submission));
    }

    @Test
    public void clear_addFloatingTaskAfterClear_success() {
        assertClearCommandSuccess();
        commandBox.runCommand(EntryUtil.getFloatingTaskAddCommand(typicalEntries.clean));
        assertTrue(floatingTaskListPanel.isListMatching(typicalEntries.clean));
    }

    /**************************************
     * Different types of invalid wording *
     **************************************/
    @Test
    public void clear_unknownCommandName_errorMessage() {
        commandBox.runCommand("clea");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand("clearr");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }


    /*******************************
     * Mixed-case and autocomplete *
     ******************************/
    @Test
    public void clear_firstCharUppercase_success() {
        char[] commandWord = ClearCommand.COMMAND_WORD.toCharArray();
        commandWord[0] = Character.toUpperCase(commandWord[0]);
        commandBox.runCommand(String.copyValueOf(commandWord));
        assertCleared();
    }

    @Test
    public void clear_lastCharUppercase_success() {
        char[] commandWord = ClearCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length - 1] = Character.toUpperCase(commandWord[commandWord.length - 1]);
        commandBox.runCommand(String.copyValueOf(commandWord));
        assertCleared();
    }

    @Test
    public void clear_middleCharUppercase_success() {
        char[] commandWord = ClearCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length / 2] = Character.toUpperCase(commandWord[commandWord.length / 2]);
        commandBox.runCommand(String.copyValueOf(commandWord));
        assertCleared();
    }

    @Test
    public void clear_allCharUppercase_success() {
        String commandWord = ClearCommand.COMMAND_WORD.toUpperCase();
        commandBox.runCommand(commandWord);
        assertCleared();
    }

    @Test
    public void clear_tabAutocomplete_success() {
        for (int i = 1; i < ClearCommand.COMMAND_WORD.length(); ++i) {
            assertClearTabAutocomplete(ClearCommand.COMMAND_WORD.substring(0, i));
        }
    }

    /**
     * Confirms that the given input string will autocomplete to the correct command word.
     */
    private void assertClearTabAutocomplete(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(ClearCommand.COMMAND_WORD + " ");
    }

    private void assertCleared() {
        assertTrue(eventListPanel.isEmpty());
        assertTrue(deadlineListPanel.isEmpty());
        assertTrue(floatingTaskListPanel.isEmpty());
    }

    private void assertClearCommandSuccess() {
        commandBox.runCommand(ClearCommand.COMMAND_WORD);
        assertCleared();
        assertResultMessage("Entry book has been cleared!");
    }
}
```
###### \java\guitests\CommandBoxTest.java
``` java
public class CommandBoxTest extends EntryBookGuiTest {

    private static final String COMMAND_THAT_SUCCEEDS = ListCommand.COMMAND_WORD;
    private static final String COMMAND_THAT_FAILS = "invalid command";

    private static final String[] DUMMY_COMMANDS = {
        "dummy command 1",
        "dummy command 2"
    };

    private ArrayList<String> defaultStyleOfCommandBox;
    private ArrayList<String> errorStyleOfCommandBox;

    @Before
    public void setUp() {
        defaultStyleOfCommandBox = new ArrayList<>(commandBox.getStyleClass());
        assertFalse("CommandBox default style classes should not contain error style class.",
                    defaultStyleOfCommandBox.contains(CommandBox.ERROR_STYLE_CLASS));

        // build style class for error
        errorStyleOfCommandBox = new ArrayList<>(defaultStyleOfCommandBox);
        errorStyleOfCommandBox.add(CommandBox.ERROR_STYLE_CLASS);
    }

    @Test
    public void commandBox_successfulThenFailedCommand_errorStyle() {
        // Reset style
        assertBehaviorForSuccessfulCommand();
        // Test for error style with failed command
        assertBehaviorForFailedCommand();
    }

    @Test
    public void commandBox_failedThenSuccessfulCommand_noErrorStyle() {
        // Error style
        assertBehaviorForFailedCommand();
        // Test for no error style with successful command
        assertBehaviorForSuccessfulCommand();
    }

    @Test
    public void commandBox_mixFailedSuccessfulCommand_correctStyle() {
        assertBehaviorForSuccessfulCommand();
        assertBehaviorForFailedCommand();
        assertBehaviorForFailedCommand();
        assertBehaviorForSuccessfulCommand();
        assertBehaviorForSuccessfulCommand();
        assertBehaviorForFailedCommand();
        assertBehaviorForSuccessfulCommand();
    }

    /**
     * Using dummy command names as this test is only concerned with the
     * proper retrieval of previously entered commands.
     */
    @Test
    public void commandBox_upKey_retrievePreviousCommand() {
        commandBox.runCommand(DUMMY_COMMANDS[0]);
        commandBox.pressUpKey();
        assertCommandBox(DUMMY_COMMANDS[0]);
    }

    @Test
    public void commandBox_downKey_retrievePreviousCommand() {
        commandBox.runCommand(DUMMY_COMMANDS[0]);
        commandBox.runCommand(DUMMY_COMMANDS[1]);
        commandBox.pressUpKey();
        commandBox.pressUpKey();
        commandBox.pressDownKey();
        assertCommandBox(DUMMY_COMMANDS[1]);
    }

    @Test
    public void commandbox_downKey_retrievedTypedCommand() {
        commandBox.runCommand(DUMMY_COMMANDS[0]);
        commandBox.enterCommand(DUMMY_COMMANDS[1]);
        commandBox.pressUpKey();
        commandBox.pressDownKey();
        assertCommandBox(DUMMY_COMMANDS[1]);
    }

    /**
     * Runs a command that fails, then verifies that
     * - the return value of runCommand(...) is false,
     * - the text is cleared,
     * - the command box has only one ERROR_STYLE_CLASS, with other style classes untouched.
     */
    private void assertBehaviorForFailedCommand() {
        assertFalse(commandBox.runCommand(COMMAND_THAT_FAILS));
        assertCommandBox("");
        assertEquals(errorStyleOfCommandBox, commandBox.getStyleClass());
    }

    /**
     * Runs a command that succeeds, then verifies that
     * - the return value of runCommand(...) is true,
     * - the text is cleared,
     * - the command box does not have any ERROR_STYLE_CLASS, with style classes the same as default.
     */
    private void assertBehaviorForSuccessfulCommand() {
        assertTrue(commandBox.runCommand(COMMAND_THAT_SUCCEEDS));
        assertCommandBox("");
        assertEquals(defaultStyleOfCommandBox, commandBox.getStyleClass());
    }

}
```
###### \java\guitests\DeleteCommandTest.java
``` java
public class DeleteCommandTest extends EntryBookGuiTest {

    /*********************
     * Deleting by Index *
     ********************/
    @Test
    public void delete_firstEventByIndex_success() {
        Entry[] currentList = typicalEntries.getTypicalEvents();
        Index targetIndex = TypicalEntries.INDEX_FIRST_ENTRY;
        assertDeleteEventSuccess(targetIndex, currentList);
    }

    @Test
    public void delete_lastEventByIndex_success() {
        Entry[] currentList = typicalEntries.getTypicalEvents();
        Index targetIndex = Index.fromOneBased(currentList.length);
        assertDeleteEventSuccess(targetIndex, currentList);
    }

    @Test
    public void delete_firstDeadlineByIndex_success() {
        Entry[] currentList = typicalEntries.getTypicalDeadlines();
        Index targetIndex = TypicalEntries.INDEX_FIRST_ENTRY;
        assertDeleteDeadlineSuccess(targetIndex, currentList);
    }

    @Test
    public void delete_lastDeadlineByIndex_success() {
        Entry[] currentList = typicalEntries.getTypicalDeadlines();
        Index targetIndex = Index.fromOneBased(currentList.length);
        assertDeleteDeadlineSuccess(targetIndex, currentList);
    }

    @Test
    public void delete_firstFloatingTaskByIndex_success() {
        Entry[] currentList = typicalEntries.getTypicalFloatingTasks();
        Index targetIndex = TypicalEntries.INDEX_FIRST_ENTRY;
        assertDeleteFloatingTaskSuccess(targetIndex, currentList);
    }

    @Test
    public void delete_lastFloatingTaskByIndex_success() {
        Entry[] currentList = typicalEntries.getTypicalFloatingTasks();
        Index targetIndex = Index.fromOneBased(currentList.length);
        assertDeleteFloatingTaskSuccess(targetIndex, currentList);
    }

    @Test
    public void delete_invalidFloatingTaskIndex_errorMessage() {
        Entry[] currentList = typicalEntries.getTypicalFloatingTasks();
        Index targetIndex = Index.fromOneBased(currentList.length + 1);
        commandBox.runCommand(EntryUtil.getFloatingTaskDeleteByIndexCommand(targetIndex));
        assertResultMessage(Messages.MESSAGE_INVALID_ENTRY_DISPLAYED_INDEX);
    }

    /***********************
     * Deleting by Keyword *
     ***********************/
    @Test
    public void delete_floatingTaskKeyword_singleMatch() {

    }

    /**************************************
     * Different types of invalid wording *
     **************************************/
    @Test
    public void delete_unknownCommandName_errorMessage() {
        commandBox.runCommand("delet");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand("deletee");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void delete_invalidCommandFormat_errorMessage() {
        commandBox.runCommand("delete");
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT,
                                          DeleteCommand.MESSAGE_USAGE));
    }

    /*******************************
     * Mixed-case and autocomplete *
     ******************************/
    /**
     * For all mixed-case tests only floating task entries are tested,
     * which should be suitable to test for all types since the type of task
     * doesn't affect the parsing of the command word.
     */
    @Test
    public void delete_firstCharUppercase_success() {
        char[] commandWord = DeleteCommand.COMMAND_WORD.toCharArray();
        commandWord[0] = Character.toUpperCase(commandWord[0]);
        assertDeleteWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void delete_lastCharUppercase_success() {
        char[] commandWord = DeleteCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length - 1] = Character.toUpperCase(commandWord[commandWord.length - 1]);
        assertDeleteWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void delete_middleCharUppercase_success() {
        char[] commandWord = DeleteCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length / 2] = Character.toUpperCase(commandWord[commandWord.length / 2]);
        assertDeleteWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void delete_allCharUppercase_success() {
        String commandWord = DeleteCommand.COMMAND_WORD.toUpperCase();
        assertDeleteWithCommandWord(commandWord);
    }

    @Test
    public void delete_tabAutocomplete_success() {
        for (int i = 1; i < DeleteCommand.COMMAND_WORD.length(); ++i) {
            assertDeleteTabAutocomplete(DeleteCommand.COMMAND_WORD.substring(0, i));
        }
    }

    /**
     * Confirms that the given input string will autocomplete to the correct delete command word.
     */
    private void assertDeleteTabAutocomplete(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(DeleteCommand.COMMAND_WORD + " ");
    }

    private void assertDeleteWithCommandWord(String commandWord) {
        Entry[] currentList = typicalEntries.getTypicalFloatingTasks();
        Index targetIndex = TypicalEntries.INDEX_FIRST_ENTRY;
        Entry entryToDelete = currentList[targetIndex.getZeroBased()];
        commandBox.runCommand(commandWord + " " + CliSyntax.PREFIX_FLOATINGTASK
                + " " + targetIndex.getOneBased());
        assertFloatingTaskDeleted(entryToDelete, currentList);
    }

    /**
     * Runs the delete command to delete the event at {@code index} and confirms the result is correct.
     * @param currentList A copy of the current list of events (before deletion).
     */
    private void assertDeleteEventSuccess(Index index, final Entry[] currentList) {
        Entry entryToDelete = currentList[index.getZeroBased()];
        commandBox.runCommand(EntryUtil.getEventDeleteByIndexCommand(index));
        assertEventDeleted(entryToDelete, currentList);
    }

    /**
     * Runs the delete command to delete the deadline at {@code index} and confirms the result is correct.
     * @param currentList A copy of the current list of deadlines (before deletion).
     */
    private void assertDeleteDeadlineSuccess(Index index, final Entry[] currentList) {
        Entry entryToDelete = currentList[index.getZeroBased()];
        commandBox.runCommand(EntryUtil.getDeadlineDeleteByIndexCommand(index));
        assertDeadlineDeleted(entryToDelete, currentList);
    }

    /**
     * Runs the delete command to delete the floating task at {@code index} and confirms the result is correct.
     * @param currentList A copy of the current list of floating tasks (before deletion).
     */
    private void assertDeleteFloatingTaskSuccess(Index index, final Entry[] currentList) {
        Entry entryToDelete = currentList[index.getZeroBased()];
        commandBox.runCommand(EntryUtil.getFloatingTaskDeleteByIndexCommand(index));
        assertFloatingTaskDeleted(entryToDelete, currentList);
    }

    private void assertEventDeleted(Entry entryDeleted, final Entry[] currentList) {
        Entry[] expectedList = TestUtil.removeEntriesFromList(currentList, entryDeleted);
        assertTrue(eventListPanel.isListMatching(expectedList));
        assertResultMessage(String.format(DeleteCommand.MESSAGE_SUCCESS, entryDeleted));
    }

    private void assertDeadlineDeleted(Entry entryDeleted, final Entry[] currentList) {
        Entry[] expectedList = TestUtil.removeEntriesFromList(currentList, entryDeleted);
        assertTrue(deadlineListPanel.isListMatching(expectedList));
        assertResultMessage(String.format(DeleteCommand.MESSAGE_SUCCESS, entryDeleted));
    }

    private void assertFloatingTaskDeleted(Entry entryDeleted, final Entry[] currentList) {
        Entry[] expectedList = TestUtil.removeEntriesFromList(currentList, entryDeleted);
        assertTrue(floatingTaskListPanel.isListMatching(expectedList));
        assertResultMessage(String.format(DeleteCommand.MESSAGE_SUCCESS, entryDeleted));
    }

}
```
###### \java\guitests\EntryBookGuiTest.java
``` java
/**
 * A GUI Test class for EntryBook.
 */
public abstract class EntryBookGuiTest {

    /* The TestName Rule makes the current test name available inside test methods */
    @Rule
    public TestName name = new TestName();

    protected TypicalEntries typicalEntries = new TypicalEntries();

    /*
     *   Handles to GUI elements present at the start up are created in advance
     *   for easy access from child classes.
     */
    protected MainWindowHandle mainGui;
    protected MainMenuHandle mainMenu;
    protected EventListPanelHandle eventListPanel;
    protected DeadlineListPanelHandle deadlineListPanel;
    protected FloatingTaskListPanelHandle floatingTaskListPanel;
    protected ResultDisplayHandle resultDisplay;
    protected CommandBoxHandle commandBox;
    protected StatusBarFooterHandle statusBarFooter;

    protected Stage stage;

    @BeforeClass
    public static void setupSpec() {
        try {
            FxToolkit.registerPrimaryStage();
            FxToolkit.hideStage();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }

    @Before
    public void setup() throws Exception {
        FxToolkit.setupStage((stage) -> {
            mainGui = new MainWindowHandle(new GuiRobot(), stage);
            mainMenu = mainGui.getMainMenu();
            eventListPanel = mainGui.getEventListPanel();
            deadlineListPanel = mainGui.getDeadlineListPanel();
            floatingTaskListPanel = mainGui.getFloatingTaskListPanel();
            resultDisplay = mainGui.getResultDisplay();
            commandBox = mainGui.getCommandBox();
            statusBarFooter = mainGui.getStatusBarFooter();
            this.stage = stage;
        });
        EventsCenter.clearSubscribers();
        FxToolkit.setupApplication(() -> new TestApp(this::getInitialData, getDataFileLocation()));
        FxToolkit.showStage();
        while (!stage.isShowing());
        mainGui.focusOnMainApp();
    }

    /**
     * Override this in child classes to set the initial local data.
     * Return null to use the data in the file specified in {@link #getDataFileLocation()}
     */
    protected EntryBook getInitialData() {
        EntryBook entryBook = new EntryBook();
        TypicalEntries.loadEntryBookWithSampleData(entryBook);
        return entryBook;
    }

    /**
     * Override this in child classes to set the data file location.
     */
    protected String getDataFileLocation() {
        return TestApp.TESTING_SAVE_LOCATION;
    }

    @After
    public void cleanup() throws TimeoutException {
        FxToolkit.cleanupStages();
    }

    /**
     * Asserts the entry shown in the card is same as the given entry
     */
    public void assertMatching(ReadOnlyEntry entry, EntryCardHandle card) {
        assertTrue(TestUtil.compareCardAndEntry(card, entry));
    }

    /**
     * Asserts the size of the event list is equal to the given number.
     */
    protected void assertEventListSize(int size) {
        int numberOfEntries = eventListPanel.getNumberOfEntries();
        assertEquals(size, numberOfEntries);
    }

    /**
     * Asserts the size of the deadline list is equal to the given number.
     */
    protected void assertDeadlineListSize(int size) {
        int numberOfEntries = deadlineListPanel.getNumberOfEntries();
        assertEquals(size, numberOfEntries);
    }

    /**
     * Asserts the size of the floating task list is equal to the given number.
     */
    protected void assertFloatingTaskListSize(int size) {
        int numberOfEntries = floatingTaskListPanel.getNumberOfEntries();
        assertEquals(size, numberOfEntries);
    }

    /**
     * Asserts the message shown in the Result Display area is same as the given string.
     */
    protected void assertResultMessage(String expected) {
        assertEquals(expected, resultDisplay.getText());
    }

    /**
     * Asserts the message shown in the Command Box area is same as the given string.
     */
    protected void assertCommandBox(String expected) {
        assertEquals(expected, commandBox.getCommandInput());
    }

    public void raise(BaseEvent e) {
        //JUnit doesn't run its test cases on the UI thread. Platform.runLater is used to post event on the UI thread.
        Platform.runLater(() -> EventsCenter.getInstance().post(e));
    }
}
```
###### \java\guitests\FindCommandTest.java
``` java
public class FindCommandTest extends EntryBookGuiTest {

    @Test
    public void find_nonmatchingKeyword_noResult() {
        assertFindFloatingTaskResult("making", 0);
    }

    @Test
    public void find_matchingKeyword_singleResult() {
        assertFindFloatingTaskResult("programming", 1, typicalEntries.programming);
    }

    @Test
    public void find_matchingKeyword_multipleResults() {
        assertFindFloatingTaskResult("learn", 2, typicalEntries.cook, typicalEntries.programming);
    }

    @Test
    public void find_matchingKeywordAfterDeleting_singleResult() {
        assertFindFloatingTaskResult("learn", 2, typicalEntries.cook, typicalEntries.programming);
        commandBox.runCommand(DeleteCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_FLOATINGTASK + " 1");
        assertFindFloatingTaskResult("learn", 1, typicalEntries.programming);
    }

    @Test
    public void find_emptyList_noResult() {
        commandBox.runCommand(ClearCommand.COMMAND_WORD);
        assertFindFloatingTaskResult("learn", 0);
    }

    /**
     * For all mixed-case tests only floating task entries are tested,
     * which should be suitable to test for all types since the type of task
     * doesn't affect the parsing of the command word.
     */
    @Test
    public void find_firstCharUppercase_success() {
        char[] commandWord = FindCommand.COMMAND_WORD.toCharArray();
        commandWord[0] = Character.toUpperCase(commandWord[0]);
        assertFindWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void find_lastCharUppercase_success() {
        char[] commandWord = FindCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length - 1] = Character.toUpperCase(commandWord[commandWord.length - 1]);
        assertFindWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void find_middleCharUppercase_success() {
        char[] commandWord = FindCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length / 2] = Character.toUpperCase(commandWord[commandWord.length / 2]);
        assertFindWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void find_allCharUppercase_success() {
        String commandWord = FindCommand.COMMAND_WORD.toUpperCase();
        assertFindWithCommandWord(commandWord);
    }

    @Test
    public void find_unknownCommandName_errorMessage() {
        commandBox.runCommand("f");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand("fin");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand("findd");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void find_invalidCommandFormat_errorMessage() {
        commandBox.runCommand("find");
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT,
                                          FindCommand.MESSAGE_USAGE));

        commandBox.runCommand("find ");
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT,
                                          FindCommand.MESSAGE_USAGE));
    }

    @Test
    public void find_tabAutocompleteFromOneChar_success() {
        assertFindTabAutocomplete(FindCommand.COMMAND_WORD.substring(0, 1));
    }

    @Test
    public void find_tabAutocompleteFromTwoCharr_success() {
        assertFindTabAutocomplete(FindCommand.COMMAND_WORD.substring(0, 2));
    }

    /**
     * Confirms that the given input string will autocomplete to the correct find command word.
     */
    private void assertFindTabAutocomplete(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(FindCommand.COMMAND_WORD + " ");
    }

    private void assertFindWithCommandWord(String commandWord) {
        commandBox.runCommand(commandWord + " programming");
        assertFindFloatingTaskListMessage(1, typicalEntries.programming);
    }

    private void assertFindFloatingTaskResult(String keywords, int numExpectedTotalResults,
                                              Entry... expectedFloatingTaskResults) {
        commandBox.runCommand(FindCommand.COMMAND_WORD + " " + keywords);
        assertFindFloatingTaskListMessage(numExpectedTotalResults, expectedFloatingTaskResults);
    }

    private void assertFindFloatingTaskListMessage(int numExpectedTotalResults,
                                                   Entry... expectedFloatingTaskResults) {
        assertFloatingTaskListSize(expectedFloatingTaskResults.length);
        assertResultMessage(numExpectedTotalResults + " entries listed!");
        assertTrue(floatingTaskListPanel.isListMatching(expectedFloatingTaskResults));
    }

}
```
###### \java\guitests\guihandles\DeadlineListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the deadline list.
 */
public class DeadlineListPanelHandle extends EntryListPanelHandle {

    public DeadlineListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage);
        listViewId = "#deadlineListView";
    }

    /**
     * Gets an entry handle for a deadline entry in the list by index
     */
    @Override
    public EntryCardHandle getEntryCardHandle(int index) {
        return getEntryCardHandle(new Deadline(getListView().getItems().get(index)));
    }
}
```
###### \java\guitests\guihandles\EntryCardHandle.java
``` java
/**
 * Provides a handle to a entry card in the entry list panel.
 */
public class EntryCardHandle extends GuiHandle {
    private static final String NAME_FIELD_ID = "#name";
    private static final String START_DATE_TIME_ID = "#startDateTime";
    private static final String END_DATE_TIME_ID = "#endDateTime";
    private static final String ADDITIONAL_INFO_ID = "#additionalInfo";
    private static final String TAGS_FIELD_ID = "#tags";

    private Node node;

    public EntryCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node) {
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getName() {
        return getTextFromLabel(NAME_FIELD_ID);
    }

    public String getStartDateTime() {
        return getTextFromLabel(START_DATE_TIME_ID);
    }

    public String getEndDateTime() {
        return getTextFromLabel(END_DATE_TIME_ID);
    }

    public String getAdditionalInfo() {
        return getTextFromLabel(ADDITIONAL_INFO_ID);
    }

    public List<String> getTags() {
        return getTags(getTagsContainer());
    }

    private List<String> getTags(Region tagsContainer) {
        return tagsContainer
                .getChildrenUnmodifiable()
                .stream()
                .map(node -> ((Labeled) node).getText())
                .collect(Collectors.toList());
    }

    private List<String> getTags(Set<Tag> tags) {
        return tags
                .stream()
                .map(tag -> tag.tagName)
                .collect(Collectors.toList());
    }

    private Region getTagsContainer() {
        return guiRobot.from(node).lookup(TAGS_FIELD_ID).query();
    }

    public boolean isSameEntry(ReadOnlyEntry entry) {
        //TODO add more checks once other Entry fields are ready
        return getName().equals(entry.getName().toString())
                && getTags().equals(getTags(entry.getTags()));
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof EntryCardHandle) {
            EntryCardHandle handle = (EntryCardHandle) obj;
            return getName().equals(handle.getName())
                && getTags().equals(handle.getTags());
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getName();
    }
}
```
###### \java\guitests\guihandles\EntryListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the event entry list.
 */
public abstract class EntryListPanelHandle extends GuiHandle {

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#cardPane";

    protected String listViewId;

    public EntryListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
        listViewId = "#entryListView";
    }

    public List<ReadOnlyEntry> getSelectedEntries() {
        ListView<ReadOnlyEntry> entryList = getListView();
        return entryList.getSelectionModel().getSelectedItems();
    }

    public ListView<ReadOnlyEntry> getListView() {
        return getNode(listViewId);
    }

    /**
     * Returns true if the list is showing the entry details correctly and in correct order.
     * @param entries A list of entries in the correct order.
     */
    public boolean isListMatching(ReadOnlyEntry... entries) {
        return this.isListMatching(0, entries);
    }

    /**
     * Returns true if the list is showing the entry details correctly and in correct order.
     * @param startPosition The starting position of the sub list.
     * @param entries A list of entries in the correct order.
     */
    public boolean isListMatching(int startPosition, ReadOnlyEntry... entries) throws IllegalArgumentException {
        if (entries.length + startPosition != getListView().getItems().size()) {
            throw new IllegalArgumentException("List size mismatched\n"
                    + "Expected " + (getListView().getItems().size() - 1) + " entries, "
                    + "got " + (entries.length + startPosition - 1));
        }
        assertTrue(this.containsInOrder(startPosition, entries));
        for (int i = 0; i < entries.length; i++) {
            final int scrollTo = i + startPosition;
            guiRobot.interact(() -> getListView().scrollTo(scrollTo));
            guiRobot.sleep(200);
            if (!TestUtil.compareCardAndEntry(getEntryCardHandle(scrollTo), entries[i])) {
                return false;
            }
        }
        return true;
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point = TestUtil.getScreenMidPoint(getListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code entries} appear as the sub list (in that order) at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ReadOnlyEntry... entries) {
        List<ReadOnlyEntry> entriesInList = getListView().getItems();

        // Return false if the list in panel is too short to contain the given list
        if (startPosition + entries.length > entriesInList.size()) {
            return false;
        }

        // Return false if any of the entries doesn't match
        for (int i = 0; i < entries.length; i++) {
            if (!entriesInList.get(startPosition + i).getName().toString().equals(entries[i].getName().toString())) {
                return false;
            }
        }

        return true;
    }

    /**
     * Navigates the listview to display and select the entry that matches the {@code name}.
     */
    public EntryCardHandle navigateToEntry(String name) {
        guiRobot.sleep(500); //Allow a bit of time for the list to be updated
        final Optional<ReadOnlyEntry> entry = getListView().getItems().stream()
                                                .filter(p -> p.getName().toString().equals(name))
                                                .findAny();
        if (!entry.isPresent()) {
            throw new IllegalStateException("Name of entry not found: " + name);
        }

        return navigateToEntry(entry.get());
    }

    /**
     * Navigates the listview to display and select the entry.
     */
    public EntryCardHandle navigateToEntry(ReadOnlyEntry entry) {
        int index = getEntryIndex(entry);

        guiRobot.interact(() -> {
            getListView().scrollTo(index);
            guiRobot.sleep(150);
            getListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(100);
        return getEntryCardHandle(entry);
    }


    /**
     * Returns the position index of the entry given, {@code NOT_FOUND} if not found in the list.
     */
    public int getEntryIndex(ReadOnlyEntry target) {
        List<ReadOnlyEntry> entriesInList = getListView().getItems();
        for (int i = 0; i < entriesInList.size(); i++) {
            if (entriesInList.get(i).getName().equals(target.getName())) {
                return i;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets an entry from the list by index
     */
    public ReadOnlyEntry getEntry(int index) {
        return getListView().getItems().get(index);
    }

    /**
     * Gets an entry handle for an entry in the list by index
     */
    public EntryCardHandle getEntryCardHandle(int index) {
        assert false : "EntryListPanelHandle::getEntryCardHandle should not be called";
        return null;
    }

    /**
     * Gets an entry handle for an entry in the list
     */
    public EntryCardHandle getEntryCardHandle(ReadOnlyEntry entry) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> entryCardNode = nodes.stream()
                .filter(n -> new EntryCardHandle(guiRobot, primaryStage, n).isSameEntry(entry))
                .findFirst();
        if (entryCardNode.isPresent()) {
            return new EntryCardHandle(guiRobot, primaryStage, entryCardNode.get());
        } else {
            return null;
        }
    }

    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(CARD_PANE_ID).queryAll();
    }

    public int getNumberOfEntries() {
        return getListView().getItems().size();
    }

    public boolean isEmpty() {
        return getListView().getItems().size() == 0;
    }
}
```
###### \java\guitests\guihandles\EventListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the event list.
 */
public class EventListPanelHandle extends EntryListPanelHandle {

    public EventListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage);
        listViewId = "#eventListView";
    }

    /**
     * Gets an entry handle for a event entry in the list by index
     */
    @Override
    public EntryCardHandle getEntryCardHandle(int index) {
        return getEntryCardHandle(new Event(getListView().getItems().get(index)));
    }
}
```
###### \java\guitests\guihandles\FloatingTaskListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the floating task list.
 */
public class FloatingTaskListPanelHandle extends EntryListPanelHandle {

    public FloatingTaskListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage);
        listViewId = "#floatingTaskListView";
    }

    /**
     * Gets an entry handle for a floating list entry in the list by index
     */
    @Override
    public EntryCardHandle getEntryCardHandle(int index) {
        return getEntryCardHandle(new FloatingTask(getListView().getItems().get(index)));
    }
}
```
###### \java\guitests\guihandles\GuiHandle.java
``` java
    public void pressUpKey() {
        guiRobot.type(KeyCode.UP).sleep(250);
    }

    public void pressKeypadUpKey() {
        guiRobot.type(KeyCode.KP_UP).sleep(250);
    }

    public void pressDownKey() {
        guiRobot.type(KeyCode.DOWN).sleep(250);
    }

    public void pressKeypadDownKey() {
        guiRobot.type(KeyCode.KP_DOWN).sleep(250);
    }

    public void pressTabKey() {
        guiRobot.type(KeyCode.TAB).sleep(250);
    }
```
###### \java\guitests\guihandles\MainWindowHandle.java
``` java
/**
 * Provides a handle for {@code MainWindow}.
 */
public class MainWindowHandle extends GuiHandle {

    private final EventListPanelHandle eventListPanel;
    private final DeadlineListPanelHandle deadlineListPanel;
    private final FloatingTaskListPanelHandle floatingTaskListPanel;
    private final ResultDisplayHandle resultDisplay;
    private final CommandBoxHandle commandBox;
    private final StatusBarFooterHandle statusBarFooter;
    private final MainMenuHandle mainMenu;

    public MainWindowHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);

        eventListPanel = new EventListPanelHandle(guiRobot, primaryStage);
        deadlineListPanel = new DeadlineListPanelHandle(guiRobot, primaryStage);
        floatingTaskListPanel = new FloatingTaskListPanelHandle(guiRobot, primaryStage);

        resultDisplay = new ResultDisplayHandle(guiRobot, primaryStage);
        commandBox = new CommandBoxHandle(guiRobot, primaryStage, TestApp.APP_TITLE);
        statusBarFooter = new StatusBarFooterHandle(guiRobot, primaryStage);
        mainMenu = new MainMenuHandle(guiRobot, primaryStage);
    }

    public EventListPanelHandle getEventListPanel() {
        return eventListPanel;
    }

    public DeadlineListPanelHandle getDeadlineListPanel() {
        return deadlineListPanel;
    }

    public FloatingTaskListPanelHandle getFloatingTaskListPanel() {
        return floatingTaskListPanel;
    }

    public ResultDisplayHandle getResultDisplay() {
        return resultDisplay;
    }

    public CommandBoxHandle getCommandBox() {
        return commandBox;
    }

    public StatusBarFooterHandle getStatusBarFooter() {
        return statusBarFooter;
    }

    public MainMenuHandle getMainMenu() {
        return mainMenu;
    }

}
```
###### \java\guitests\HelpWindowTest.java
``` java
public class HelpWindowTest extends EntryBookGuiTest {

    @Test
    public void helpWindow_usingAcceleratorInCommandBox_open() {
        commandBox.clickOnTextField();
        assertHelpWindowOpen(mainMenu.openHelpWindowUsingAccelerator());
    }

    @Test
    public void helpWindow_usingAcceleratorInResultDisplay_open() {
        resultDisplay.clickOnTextArea();
        assertHelpWindowOpen(mainMenu.openHelpWindowUsingAccelerator());
    }

    @Test
    public void helpWindow_usingAcceleratorInEventListPanel_open() {
        eventListPanel.clickOnListView();
        assertHelpWindowOpen(mainMenu.openHelpWindowUsingAccelerator());
    }

    @Test
    public void helpWindow_usingAcceleratorInDeadlineListPanel_open() {
        deadlineListPanel.clickOnListView();
        assertHelpWindowOpen(mainMenu.openHelpWindowUsingAccelerator());
    }

    @Test
    public void helpWindow_usingAcceleratorInFloatingTaskListPanel_open() {
        floatingTaskListPanel.clickOnListView();
        assertHelpWindowOpen(mainMenu.openHelpWindowUsingAccelerator());
    }

    @Test
    public void helpWindow_usingMenuButton_open() {
        assertHelpWindowOpen(mainMenu.openHelpWindowUsingMenu());
    }

    @Test
    public void helpWindow_usingCommand_open() {
        assertHelpWindowOpen(commandBox.runHelpCommand());
    }

    @Test
    public void help_tabAutocompleteFromOneChar_failure() {
        assertHelpTabAutocompleteFailure(HelpCommand.COMMAND_WORD.substring(0, 1));
    }

    @Test
    public void help_tabAutocompleteFromTwoChars_success() {
        assertHelpTabAutocomplete(HelpCommand.COMMAND_WORD.substring(0, 2));
    }

    @Test
    public void help_unknownCommandName_errorMessage() {
        commandBox.runCommand("h");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand("hel");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand("helpp");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    /**
     * Confirms that the given input string will autocomplete to the correct help command word.
     */
    private void assertHelpTabAutocomplete(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(HelpCommand.COMMAND_WORD + " ");
    }

    private void assertHelpTabAutocompleteFailure(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(input);
    }

    private void assertHelpWindowOpen(HelpWindowHandle helpWindowHandle) {
        assertTrue(helpWindowHandle.isWindowOpen());
        helpWindowHandle.closeWindow();
    }

}
```
###### \java\seedu\multitasky\testutil\EntryUtil.java
``` java
/**
 * A utility class for Entry.
 */
public class EntryUtil {

    /**
     * Returns an add command string for adding the {@code entry} as an event.
     */
    public static String getEventAddCommand(Entry entry) {
        return AddCommand.COMMAND_WORD + " " + getEventDetailsForAdd(entry);
    }

    /**
     * Returns an add command string for adding the {@code entry} as a deadline.
     */
    public static String getDeadlineAddCommand(Entry entry) {
        return AddCommand.COMMAND_WORD + " " + getDeadlineDetailsForAdd(entry);
    }

    /**
     * Returns an add command string for adding the {@code entry} as a floating task.
     */
    public static String getFloatingTaskAddCommand(Entry entry) {
        return AddCommand.COMMAND_WORD + " " + getFloatingTaskDetailsForAdd(entry);
    }

    /**
     * Returns a delete command string for deleting an event by index.
     */
    public static String getEventDeleteByIndexCommand(Index index) {
        return DeleteCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_EVENT + " " + index.getOneBased();
    }

    /**
     * Returns a delete command string for deleting a deadline by index.
     */
    public static String getDeadlineDeleteByIndexCommand(Index index) {
        return DeleteCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_DEADLINE + " " + index.getOneBased();
    }

    /**
     * Returns a delete command string for deleting a floating task by index.
     */
    public static String getFloatingTaskDeleteByIndexCommand(Index index) {
        return DeleteCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_FLOATINGTASK + " " + index.getOneBased();
    }

    /**
     * Returns the part of command string for the given {@code entry}'s details
     * for adding an event.
     */
    public static String getEventDetailsForAdd(Entry entry) {
        assert entry instanceof Event;
        StringBuilder builder = new StringBuilder();
        builder.append(entry.getName().toString() + " ")
               .append(CliSyntax.PREFIX_FROM + " ")
               .append(getDateDetailsAsInputString(entry.getStartDateAndTime()) + " ")
               .append(CliSyntax.PREFIX_TO + " ")
               .append(getDateDetailsAsInputString(entry.getEndDateAndTime()) + " ");
        builder.append(CliSyntax.PREFIX_TAG + " ");
        entry.getTags().stream().forEach(s -> builder.append(s.tagName + " "));
        return builder.toString();
    }

    /**
     * Returns the part of command string for the given {@code entry}'s details
     * for adding an event.
     */
    public static String getDeadlineDetailsForAdd(Entry entry) {
        assert entry instanceof Deadline;
        StringBuilder builder = new StringBuilder();
        builder.append(entry.getName().toString() + " ")
               .append(CliSyntax.PREFIX_BY + " ")
               .append(getDateDetailsAsInputString(entry.getEndDateAndTime()) + " ");
        builder.append(CliSyntax.PREFIX_TAG + " ");
        entry.getTags().stream().forEach(s -> builder.append(s.tagName + " "));
        return builder.toString();
    }

    /**
     * Returns the part of command string for the given {@code entry}'s details
     * for adding a floating task.
     */
    public static String getFloatingTaskDetailsForAdd(Entry entry) {
        assert entry instanceof FloatingTask;
        StringBuilder builder = new StringBuilder();
        builder.append(entry.getName().toString() + " ");
        builder.append(CliSyntax.PREFIX_TAG + " ");
        entry.getTags().stream().forEach(s -> builder.append(s.tagName + " "));
        return builder.toString();
    }

    /**
     * Returns a string version of the calendar date that is ready for use in input
     */
    public static String getDateDetailsAsInputString(Calendar calendar) {
        assert calendar != null;
        StringBuilder builder = new StringBuilder();
        builder.append(calendar.get(Calendar.DAY_OF_MONTH) + "/")
               .append((calendar.get(Calendar.MONTH) + 1) + "/") // +1 due to MONTH being 0-based (JAN = 0)
               .append(calendar.get(Calendar.YEAR) + " ")
               .append(calendar.get(Calendar.HOUR_OF_DAY) + ":")
               .append(calendar.get(Calendar.MINUTE));
        return builder.toString();
    }
}
```
###### \java\seedu\multitasky\testutil\TypicalEntries.java
``` java

/**
 * Provides typical entries for use in testing.
 */
public class TypicalEntries {

    public static final Index INDEX_FIRST_ENTRY = Index.fromOneBased(1);
    public static final Index INDEX_SECOND_ENTRY = Index.fromOneBased(2);
    public static final Index INDEX_THIRD_ENTRY = Index.fromOneBased(3);

    // Events
    public final Entry dinner, cat, movie, opening;
    // Deadlines
    public final Entry tax, paper, submission, upgrade;
    // Floating tasks
    public final Entry cook, programming, hire, spectacles, clean, sell;

```
###### \java\seedu\multitasky\testutil\TypicalEntries.java
``` java
    public TypicalEntries() {
        try {
            // Events
            dinner = new EntryBuilder().withName("Dinner with family").withTags("cook")
                    .withStartDateAndTime(new GregorianCalendar(2017, Calendar.DECEMBER, 25, 19, 00))
                    .withEndDateAndTime(new GregorianCalendar(2017, Calendar.DECEMBER, 25, 21, 00)).build();
            cat = new EntryBuilder().withName("Feed the cat").withTags("dinner")
                  .withStartDateAndTime(new GregorianCalendar(2017, Calendar.JULY, 12, 19, 00))
                  .withEndDateAndTime(new GregorianCalendar(2017, Calendar.JULY, 12, 21, 00)).build();
            movie = new EntryBuilder().withName("Watch Spiderman").withTags("marvel")
                    .withStartDateAndTime(new GregorianCalendar(2017, Calendar.JULY, 15, 15, 00))
                    .withEndDateAndTime(new GregorianCalendar(2017, Calendar.JULY, 15, 17, 30)).build();
            opening = new EntryBuilder().withName("Attend exhibition opening").withTags("dressup")
                      .withStartDateAndTime(new GregorianCalendar(2017, Calendar.OCTOBER, 7, 18, 00))
                      .withEndDateAndTime(new GregorianCalendar(2017, Calendar.OCTOBER, 7, 21, 00)).build();

            // Deadlines
            tax = new EntryBuilder().withName("Submit taxes").withTags("money")
                      .withEndDateAndTime(new GregorianCalendar(2017, Calendar.JULY, 1, 00, 00)).build();
            paper = new EntryBuilder().withName("CS2103 finals").withTags("school", "study")
                    .withEndDateAndTime(new GregorianCalendar(2017, Calendar.JULY, 28, 10, 0)).build();
            submission = new EntryBuilder().withName("Submit assignment").withTags("school")
                         .withEndDateAndTime(new GregorianCalendar(2017, Calendar.JULY, 12, 16, 00)).build();
            upgrade = new EntryBuilder().withName("Upgrade computer").withTags("project")
                      .withEndDateAndTime(new GregorianCalendar(2017, Calendar.DECEMBER, 1, 00, 00)).build();

            // Floating tasks
            cook = new EntryBuilder().withName("Learn to cook").withTags("goals").build();
            programming = new EntryBuilder().withName("Learn programming")
                          .withTags("lessons", "computer").build();
            hire = new EntryBuilder().withName("Hire an assistant").withTags("help").build();
            spectacles = new EntryBuilder().withName("Make new spectacles")
                         .withTags("health", "eyesight").build();
            clean = new EntryBuilder().withName("Clean up room").withTags("never").build();
            sell = new EntryBuilder().withName("Sell old things").withTags("sale", "clutter").build();

        } catch (Exception e) {
            throw new AssertionError("Sample data cannot be invalid", e);
        }
    }
```
