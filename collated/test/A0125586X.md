# A0125586X
###### \java\guitests\AddCommandTest.java
``` java
public class AddCommandTest extends EntryBookGuiTest {

    /***************************
     * Adding to an empty list *
     **************************/
    @Test
    public void add_eventsToEmptyList_success() {
        assertCleared();
        Entry[] currentList = new Entry[0];
        Entry entryToAdd = SampleEntries.DINNER;
        currentList = assertAddEvent(entryToAdd, currentList);

        entryToAdd = SampleEntries.CAT;
        currentList = assertAddEvent(entryToAdd, currentList);
    }

    @Test
    public void add_deadlinesToEmptyList_success() {
        assertCleared();
        Entry[] currentList = new Entry[0];
        Entry entryToAdd = SampleEntries.PAPER;
        currentList = assertAddDeadline(entryToAdd, currentList);

        entryToAdd = SampleEntries.SUBMISSION;
        currentList = assertAddDeadline(entryToAdd, currentList);
    }

    @Test
    public void add_floatingTasksToEmptyList_success() {
        assertCleared();
        Entry[] currentList = new Entry[0];
        Entry entryToAdd = SampleEntries.SPECTACLES;
        currentList = assertAddFloatingTask(entryToAdd, currentList);

        entryToAdd = SampleEntries.CLEAN;
        currentList = assertAddFloatingTask(entryToAdd, currentList);
    }

    /***************************
     * Adding an existing list *
     **************************/
    @Test
    public void add_eventsToExistingList_success() {
        Entry[] currentList = SampleEntries.getSampleEvents();
        Entry entryToAdd = SampleEntries.MOVIE;
        currentList = assertAddEvent(entryToAdd, currentList);

        entryToAdd = SampleEntries.OPENING;
        currentList = assertAddEvent(entryToAdd, currentList);
    }

    @Test
    public void add_deadlinesToExistingList_success() {
        Entry[] currentList = SampleEntries.getSampleDeadlines();
        Entry entryToAdd = SampleEntries.SUBMISSION;
        currentList = assertAddDeadline(entryToAdd, currentList);

        entryToAdd = SampleEntries.UPGRADE;
        currentList = assertAddDeadline(entryToAdd, currentList);
    }

    @Test
    public void add_floatingTaskToExistingList_success() {
        Entry[] currentList = SampleEntries.getSampleFloatingTasks();
        Entry entryToAdd = SampleEntries.SPECTACLES;
        currentList = assertAddFloatingTask(entryToAdd, currentList);

        entryToAdd = SampleEntries.CLEAN;
        currentList = assertAddFloatingTask(entryToAdd, currentList);
    }

    /**************************************
     * Different types of invalid wording *
     **************************************/
    @Test
    public void add_unknownCommandName_errorMessage() {
        commandBox.runCommand(AddCommand.COMMAND_WORD.substring(0, AddCommand.COMMAND_WORD.length() - 1));
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand(AddCommand.COMMAND_WORD + "a");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void add_invalidCommandFormat_errorMessage() {
        commandBox.runCommand(AddCommand.COMMAND_WORD);
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
    }


    @Test
    public void add_invalidEntryName_errorMessage() {
        commandBox.runCommand(AddCommand.COMMAND_WORD + " $");
        assertResultMessage(Name.MESSAGE_NAME_CONSTRAINTS);

        commandBox.runCommand(AddCommand.COMMAND_WORD + " /");
        assertResultMessage(Name.MESSAGE_NAME_CONSTRAINTS);
    }

    @Test
    public void add_invalidTags_errorMessage() {
        commandBox.runCommand(AddCommand.COMMAND_WORD + " task " + CliSyntax.PREFIX_TAG);
        assertResultMessage(Tag.MESSAGE_TAG_CONSTRAINTS);

        commandBox.runCommand(AddCommand.COMMAND_WORD + " task " + CliSyntax.PREFIX_TAG + " $");
        assertResultMessage(Tag.MESSAGE_TAG_CONSTRAINTS);
    }

    /*******************************
     * Mixed-case and autocomplete *
     ******************************/
    /**
     * For all mixed-case tests only floating task entries are tested,
     * which should be suitable to test for all types since the type of task
     * doesn't affect the parsing of the command word.
     */
    @Test
    public void add_firstCharUppercase_success() {
        char[] commandWord = AddCommand.COMMAND_WORD.toCharArray();
        commandWord[0] = Character.toUpperCase(commandWord[0]);
        assertAddWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void add_lastCharUppercase_success() {
        char[] commandWord = AddCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length - 1] = Character.toUpperCase(commandWord[commandWord.length - 1]);
        assertAddWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void add_middleCharUppercase_success() {
        char[] commandWord = AddCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length / 2] = Character.toUpperCase(commandWord[commandWord.length / 2]);
        assertAddWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void add_allCharUppercase_success() {
        String commandWord = AddCommand.COMMAND_WORD.toUpperCase();
        assertAddWithCommandWord(commandWord);
    }

    @Test
    public void add_tabAutocomplete_success() {
        for (int i = 1; i < AddCommand.COMMAND_WORD.length(); ++i) {
            assertAddTabAutocomplete(AddCommand.COMMAND_WORD.substring(0, i));
        }
        assertAddTabAutocomplete(AddCommand.COMMAND_WORD + "a");
        assertAddTabAutocomplete(AddCommand.COMMAND_WORD + "aa");
        assertAddTabAutocomplete(AddCommand.COMMAND_WORD + "aaa");
    }

    /**
     * Confirms that the given input string will autocomplete to the correct command word.
     */
    private void assertAddTabAutocomplete(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(AddCommand.COMMAND_WORD + " ");
    }

    /**
     * Helps with the testing of command words with different character cases
     */
    private void assertAddWithCommandWord(String commandWord) {
        Entry[] currentList = SampleEntries.getSampleFloatingTasks();
        Entry entryToAdd = SampleEntries.SPECTACLES;
        commandBox.runCommand(commandWord + " " + CommandUtil.getFloatingTaskDetails(entryToAdd));
        assertFloatingTaskAdded(entryToAdd, currentList);
    }

    /**
     * Adds an event to the entry book as well as to the supplied array
     */
    private Entry[] assertAddEvent(Entry entryToAdd, Entry... currentList) {
        assertAddEventSuccess(entryToAdd, currentList);
        return TestUtil.addEntriesToSortedList(currentList, entryToAdd);
    }

    /**
     * Adds a deadline to the entry book as well as to the supplied array
     */
    private Entry[] assertAddDeadline(Entry entryToAdd, Entry... currentList) {
        assertAddDeadlineSuccess(entryToAdd, currentList);
        return TestUtil.addEntriesToSortedList(currentList, entryToAdd);
    }

    /**
     * Adds a floating task to the entry book as well as to the supplied array
     */
    private Entry[] assertAddFloatingTask(Entry entryToAdd, Entry... currentList) {
        assertAddFloatingTaskSuccess(entryToAdd, currentList);
        return TestUtil.addEntriesToList(currentList, entryToAdd);
    }

    /**
     * Clears all tasks and asserts that they have been cleared
     */
    private void assertCleared() {
        commandBox.runCommand(ClearCommand.COMMAND_WORD);
        //commandBox.runCommand(ClearCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_ARCHIVE);
        //commandBox.runCommand(ClearCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_BIN);
        assertTrue(eventListPanel.isEmpty());
        assertTrue(deadlineListPanel.isEmpty());
        assertTrue(floatingTaskListPanel.isEmpty());
    }

    /**
     * Attempts to add an entry as an event and confirms that it has been added.
     */
    private void assertAddEventSuccess(Entry entryToAdd, Entry... currentList) {
        commandBox.runCommand(CommandUtil.getAddEventCommand(entryToAdd));
        assertEventAdded(entryToAdd, currentList);
    }

    /**
     * Attempts to add an entry as a deadline and confirms that it has been added.
     */
    private void assertAddDeadlineSuccess(Entry entryToAdd, Entry... currentList) {
        commandBox.runCommand(CommandUtil.getAddDeadlineCommand(entryToAdd));
        assertDeadlineAdded(entryToAdd, currentList);
    }

    /**
     * Attempts to add an entry as a floating task and confirms that it has been added.
     */
    private void assertAddFloatingTaskSuccess(Entry entryToAdd, Entry... currentList) {
        commandBox.runCommand(CommandUtil.getAddFloatingTaskCommand(entryToAdd));
        assertFloatingTaskAdded(entryToAdd, currentList);
    }

    /**
     * Confirms that the added entry is in the expected list, and that the
     * expected list matches the displayed list.
     */
    private void assertEventAdded(Entry entryAdded, Entry... currentList) {
        EntryCardHandle addedCard = eventListPanel.navigateToEntry(entryAdded.getName().toString());
        assertMatching(entryAdded, addedCard);
        Entry[] expectedList = TestUtil.addEntriesToSortedList(currentList, entryAdded);
        assertTrue(eventListPanel.isListMatching(expectedList));
    }

    /**
     * Confirms that the added entry is in the expected list, and that the
     * expected list matches the displayed list.
     */
    private void assertDeadlineAdded(Entry entryAdded, Entry... currentList) {
        EntryCardHandle addedCard = deadlineListPanel.navigateToEntry(entryAdded.getName().toString());
        assertMatching(entryAdded, addedCard);
        Entry[] expectedList = TestUtil.addEntriesToSortedList(currentList, entryAdded);
        assertTrue(deadlineListPanel.isListMatching(expectedList));
    }

    /**
     * Confirms that the added entry is in the expected list, and that the
     * expected list matches the displayed list.
     */
    private void assertFloatingTaskAdded(Entry entryAdded, Entry... currentList) {
        EntryCardHandle addedCard = floatingTaskListPanel.navigateToEntry(entryAdded.getName().toString());
        assertMatching(entryAdded, addedCard);
        Entry[] expectedList = TestUtil.addEntriesToList(currentList, entryAdded);
        assertTrue(floatingTaskListPanel.isListMatching(expectedList));
    }

}
```
###### \java\guitests\ClearCommandTest.java
``` java
public class ClearCommandTest extends EntryBookGuiTest {

    /*********************
     * Clearing the list *
     ********************/
    @Test
    public void clearAll_emptyList_success() {
        assertClearAllCommandSuccess();
        assertClearAllCommandSuccess();
    }

    /*************************************
     * Adding after clearing all entries *
     *************************************/
    @Test
    public void clear_addEventAfterClearAll_success() {
        assertClearAllCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddEventCommand(SampleEntries.CAT));
        assertTrue(eventListPanel.isListMatching(SampleEntries.CAT));
    }

    @Test
    public void clear_addDeadlineAfterClearAll_success() {
        assertClearAllCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddDeadlineCommand(SampleEntries.SUBMISSION));
        assertTrue(deadlineListPanel.isListMatching(SampleEntries.SUBMISSION));
    }

    @Test
    public void clear_addFloatingTaskAfterClearAll_success() {
        assertClearAllCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddFloatingTaskCommand(SampleEntries.CLEAN));
        assertTrue(floatingTaskListPanel.isListMatching(SampleEntries.CLEAN));
    }

    /********************************************
     * Adding after clearing all active entries *
     ********************************************/
    @Test
    public void clear_addEventAfterClearActive_success() {
        assertClearActiveCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddEventCommand(SampleEntries.CAT));
        assertTrue(eventListPanel.isListMatching(SampleEntries.CAT));
    }

    @Test
    public void clear_addDeadlineAfterClearActive_success() {
        assertClearActiveCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddDeadlineCommand(SampleEntries.SUBMISSION));
        assertTrue(deadlineListPanel.isListMatching(SampleEntries.SUBMISSION));
    }

    @Test
    public void clear_addFloatingTaskAfterClearActive_success() {
        assertClearActiveCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddFloatingTaskCommand(SampleEntries.CLEAN));
        assertTrue(floatingTaskListPanel.isListMatching(SampleEntries.CLEAN));
    }

    /**************************************
     * Different types of invalid wording *
     **************************************/
    @Test
    public void clear_unknownCommandName_errorMessage() {
        commandBox.runCommand(ClearCommand.COMMAND_WORD.substring(0, ClearCommand.COMMAND_WORD.length() - 1));
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand(ClearCommand.COMMAND_WORD + "a");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    /*******************************
     * Mixed-case and autocomplete *
     ******************************/
    @Test
    public void clear_firstCharUppercase_success() {
        char[] commandWord = ClearCommand.COMMAND_WORD.toCharArray();
        commandWord[0] = Character.toUpperCase(commandWord[0]);
        commandBox.runCommand(String.copyValueOf(commandWord));
        assertCleared();
    }

    @Test
    public void clear_lastCharUppercase_success() {
        char[] commandWord = ClearCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length - 1] = Character.toUpperCase(commandWord[commandWord.length - 1]);
        commandBox.runCommand(String.copyValueOf(commandWord));
        assertCleared();
    }

    @Test
    public void clear_middleCharUppercase_success() {
        char[] commandWord = ClearCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length / 2] = Character.toUpperCase(commandWord[commandWord.length / 2]);
        commandBox.runCommand(String.copyValueOf(commandWord));
        assertCleared();
    }

    @Test
    public void clear_allCharUppercase_success() {
        String commandWord = ClearCommand.COMMAND_WORD.toUpperCase();
        commandBox.runCommand(commandWord);
        assertCleared();
    }

    @Test
    public void clear_tabAutocomplete_success() {
        assertClearTabAutocompleteFailure(ClearCommand.COMMAND_WORD.substring(0, 1));
        for (int i = 2; i < ClearCommand.COMMAND_WORD.length(); ++i) {
            assertClearTabAutocomplete(ClearCommand.COMMAND_WORD.substring(0, i));
        }
        assertClearTabAutocomplete(ClearCommand.COMMAND_WORD + "a");
    }

    /**
     * Confirms that the given input string will autocomplete to the correct command word.
     */
    private void assertClearTabAutocomplete(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(ClearCommand.COMMAND_WORD + " ");
    }

    private void assertClearTabAutocompleteFailure(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(input);
    }

    private void assertCleared() {
        assertTrue(eventListPanel.isEmpty());
        assertTrue(deadlineListPanel.isEmpty());
        assertTrue(floatingTaskListPanel.isEmpty());
    }

    private void assertClearAllCommandSuccess() {
        commandBox.runCommand(ClearCommand.COMMAND_WORD + " all");
        assertCleared();
        assertResultMessage("Entry book has been cleared!");
    }

    private void assertClearActiveCommandSuccess() {
        commandBox.runCommand(ClearCommand.COMMAND_WORD);
        assertCleared();
        assertResultMessage(ClearCommand.MESSAGE_ACTIVE_SUCCESS);
    }
}
```
###### \java\guitests\CommandBoxTest.java
``` java
public class CommandBoxTest extends EntryBookGuiTest {

    private static final String COMMAND_THAT_SUCCEEDS = ListCommand.COMMAND_WORD;
    private static final String COMMAND_THAT_FAILS = "invalid command";
    private static final String COMMAND_THAT_CANNOT_AUTOCOMPLETE = "arstarstarst";

    private static final String[] DUMMY_COMMANDS = {
        "dummy command 1",
        "dummy command 2"
    };

    private ArrayList<String> defaultStyleOfCommandBox;
    private ArrayList<String> errorStyleOfCommandBox;

    @Before
    public void setUp() {
        defaultStyleOfCommandBox = new ArrayList<>(commandBox.getStyleClass());
        assertFalse("CommandBox default style classes should not contain error style class.",
                    defaultStyleOfCommandBox.contains(CommandBox.ERROR_STYLE_CLASS));

        // build style class for error
        errorStyleOfCommandBox = new ArrayList<>(defaultStyleOfCommandBox);
        errorStyleOfCommandBox.add(CommandBox.ERROR_STYLE_CLASS);
    }

    /**********************
     * Command box styles *
     *********************/
    @Test
    public void commandBox_successfulThenFailedCommand_errorStyle() {
        // Reset style
        assertBehaviorForSuccessfulCommand();
        // Test for error style with failed command
        assertBehaviorForFailedCommand();
    }

    @Test
    public void commandBox_failedThenSuccessfulCommand_noErrorStyle() {
        // Error style
        assertBehaviorForFailedCommand();
        // Test for no error style with successful command
        assertBehaviorForSuccessfulCommand();
    }

    @Test
    public void commandBox_mixFailedSuccessfulCommand_correctStyle() {
        assertBehaviorForSuccessfulCommand();
        assertBehaviorForFailedCommand();
        assertBehaviorForSuccessfulCommand();
        assertBehaviorForFailedCommand();
        assertBehaviorForSuccessfulCommand();
    }

    /****************************************
     * Command history using up/down arrows *
     ***************************************/
    /**
     * Using dummy command names as this test is only concerned with the
     * proper retrieval of previously entered commands.
     */
    @Test
    public void commandBox_upKey_retrievePreviousCommand() {
        commandBox.runCommand(DUMMY_COMMANDS[0]);
        commandBox.pressUpKey();
        assertCommandBox(DUMMY_COMMANDS[0]);
    }

    @Test
    public void commandBox_downKey_retrievePreviousCommand() {
        commandBox.runCommand(DUMMY_COMMANDS[0]);
        commandBox.runCommand(DUMMY_COMMANDS[1]);
        commandBox.pressUpKey();
        commandBox.pressUpKey();
        commandBox.pressDownKey();
        assertCommandBox(DUMMY_COMMANDS[1]);
    }

    @Test
    public void commandBox_downKey_retrievedTypedCommand() {
        commandBox.runCommand(DUMMY_COMMANDS[0]);
        commandBox.enterCommand(DUMMY_COMMANDS[1]);
        commandBox.pressUpKey();
        commandBox.pressDownKey();
        assertCommandBox(DUMMY_COMMANDS[1]);
    }

    /************************
     * Command autocomplete *
     ***********************/
    @Test
    public void commandBox_nonMatchingKeyword_noAutocompleteChange() {
        commandBox.enterCommand(COMMAND_THAT_CANNOT_AUTOCOMPLETE);
        commandBox.pressTabKey();
        assertCommandBox(COMMAND_THAT_CANNOT_AUTOCOMPLETE);
    }

    /*********************
     * Command box focus *
     ********************/
    @Test
    public void commandBox_shortcutFocus_focus() {
        resultDisplay.clickOnTextArea();
        resultDisplay.pressKeyCombination(new KeyCodeCombination(KeyCode.F6));
        guiRobot.type(KeyCode.A);
        assertCommandBox(KeyCode.A.getName().toLowerCase());
    }

    /**
     * Runs a command that fails, then verifies that
     * - the return value of runCommand(...) is false,
     * - the text is cleared,
     * - the command box has only one ERROR_STYLE_CLASS, with other style classes untouched.
     */
    private void assertBehaviorForFailedCommand() {
        assertFalse(commandBox.runCommand(COMMAND_THAT_FAILS));
        assertCommandBox("");
        assertEquals(errorStyleOfCommandBox, commandBox.getStyleClass());
    }

    /**
     * Runs a command that succeeds, then verifies that
     * - the return value of runCommand(...) is true,
     * - the text is cleared,
     * - the command box does not have any ERROR_STYLE_CLASS, with style classes the same as default.
     */
    private void assertBehaviorForSuccessfulCommand() {
        assertTrue(commandBox.runCommand(COMMAND_THAT_SUCCEEDS));
        assertCommandBox("");
        assertEquals(defaultStyleOfCommandBox, commandBox.getStyleClass());
    }

}
```
###### \java\guitests\DeleteCommandTest.java
``` java
public class DeleteCommandTest extends EntryBookGuiTest {

    /*********************
     * Deleting by Index *
     ********************/
    @Test
    public void delete_firstEventByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleEvents();
        Index targetIndex = SampleEntries.INDEX_FIRST_ENTRY;
        assertDeleteEventByIndexSuccess(targetIndex, currentList);
    }

    @Test
    public void delete_lastEventByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleEvents();
        Index targetIndex = Index.fromOneBased(currentList.length);
        assertDeleteEventByIndexSuccess(targetIndex, currentList);
    }

    @Test
    public void delete_invalidEventIndex_errorMessage() {
        Entry[] currentList = SampleEntries.getSampleEvents();
        Index targetIndex = Index.fromOneBased(currentList.length + 1);
        commandBox.runCommand(CommandUtil.getDeleteEventByIndexCommand(targetIndex));
        assertResultMessage(Messages.MESSAGE_INVALID_ENTRY_DISPLAYED_INDEX);
    }

    @Test
    public void delete_firstDeadlineByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleDeadlines();
        Index targetIndex = SampleEntries.INDEX_FIRST_ENTRY;
        assertDeleteDeadlineByIndexSuccess(targetIndex, currentList);
    }

    @Test
    public void delete_lastDeadlineByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleDeadlines();
        Index targetIndex = Index.fromOneBased(currentList.length);
        assertDeleteDeadlineByIndexSuccess(targetIndex, currentList);
    }

    @Test
    public void delete_invalidDeadlineIndex_errorMessage() {
        Entry[] currentList = SampleEntries.getSampleDeadlines();
        Index targetIndex = Index.fromOneBased(currentList.length + 1);
        commandBox.runCommand(CommandUtil.getDeleteDeadlineByIndexCommand(targetIndex));
        assertResultMessage(Messages.MESSAGE_INVALID_ENTRY_DISPLAYED_INDEX);
    }

    @Test
    public void delete_firstFloatingTaskByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleFloatingTasks();
        Index targetIndex = SampleEntries.INDEX_FIRST_ENTRY;
        assertDeleteFloatingTaskByIndexSuccess(targetIndex, currentList);
    }

    @Test
    public void delete_lastFloatingTaskByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleFloatingTasks();
        Index targetIndex = Index.fromOneBased(currentList.length);
        assertDeleteFloatingTaskByIndexSuccess(targetIndex, currentList);
    }

    @Test
    public void delete_invalidFloatingTaskIndex_errorMessage() {
        Entry[] currentList = SampleEntries.getSampleFloatingTasks();
        Index targetIndex = Index.fromOneBased(currentList.length + 1);
        commandBox.runCommand(CommandUtil.getDeleteFloatingTaskByIndexCommand(targetIndex));
        assertResultMessage(Messages.MESSAGE_INVALID_ENTRY_DISPLAYED_INDEX);
    }

    /***********************
     * Deleting by Keyword *
     **********************/
    @Test
    public void delete_eventKeyword_success() {
        Entry[] currentList = SampleEntries.getSampleEvents();
        Entry entryToDelete = SampleEntries.DINNER;
        commandBox.runCommand(DeleteCommand.COMMAND_WORD + " dinner");
        assertEventDeletedByKeyword(entryToDelete, currentList);
    }

    @Test
    public void delete_deadlineKeyword_success() {
        Entry[] currentList = SampleEntries.getSampleDeadlines();
        Entry entryToDelete = SampleEntries.TAX;
        commandBox.runCommand(DeleteCommand.COMMAND_WORD + " tax");
        assertDeadlineDeletedByKeyword(entryToDelete, currentList);
    }

    @Test
    public void delete_floatingTaskKeyword_success() {
        Entry[] currentList = SampleEntries.getSampleFloatingTasks();
        Entry entryToDelete = SampleEntries.PROGRAMMING;
        commandBox.runCommand(DeleteCommand.COMMAND_WORD + " programming");
        assertFloatingTaskDeletedByKeyword(entryToDelete, currentList);
    }

    /**************************************
     * Different types of invalid wording *
     *************************************/
    @Test
    public void delete_unknownCommandName_errorMessage() {
        commandBox.runCommand(DeleteCommand.COMMAND_WORD
                              .substring(0, DeleteCommand.COMMAND_WORD.length() - 1));
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand(DeleteCommand.COMMAND_WORD + "a");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void delete_invalidCommandFormat_errorMessage() {
        commandBox.runCommand(DeleteCommand.COMMAND_WORD);
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT,
                                          DeleteCommand.MESSAGE_USAGE));
    }

    /*******************************
     * Mixed-case and autocomplete *
     ******************************/
    /**
     * For all mixed-case tests only floating task entries are tested,
     * which should be suitable to test for all types since the type of task
     * doesn't affect the parsing of the command word.
     */
    @Test
    public void delete_firstCharUppercase_success() {
        char[] commandWord = DeleteCommand.COMMAND_WORD.toCharArray();
        commandWord[0] = Character.toUpperCase(commandWord[0]);
        assertDeleteWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void delete_lastCharUppercase_success() {
        char[] commandWord = DeleteCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length - 1] = Character.toUpperCase(commandWord[commandWord.length - 1]);
        assertDeleteWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void delete_middleCharUppercase_success() {
        char[] commandWord = DeleteCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length / 2] = Character.toUpperCase(commandWord[commandWord.length / 2]);
        assertDeleteWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void delete_allCharUppercase_success() {
        String commandWord = DeleteCommand.COMMAND_WORD.toUpperCase();
        assertDeleteWithCommandWord(commandWord);
    }

    @Test
    public void delete_tabAutocomplete_success() {
        for (int i = 1; i < DeleteCommand.COMMAND_WORD.length(); ++i) {
            assertDeleteTabAutocomplete(DeleteCommand.COMMAND_WORD.substring(0, i));
        }
    }

    /**
     * Confirms that the given input string will autocomplete to the correct delete command word.
     */
    private void assertDeleteTabAutocomplete(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(DeleteCommand.COMMAND_WORD + " ");
    }

    private void assertDeleteWithCommandWord(String commandWord) {
        Entry[] currentList = SampleEntries.getSampleFloatingTasks();
        Index targetIndex = SampleEntries.INDEX_FIRST_ENTRY;
        Entry entryToDelete = currentList[targetIndex.getZeroBased()];
        commandBox.runCommand(commandWord + " " + CliSyntax.PREFIX_FLOATINGTASK
                + " " + targetIndex.getOneBased());
        assertFloatingTaskDeleted(entryToDelete, currentList);
    }

    /**
     * Runs the delete command to delete the event at {@code index} and confirms the result is correct.
     * @param currentList A copy of the current list of events (before deletion).
     */
    private void assertDeleteEventByIndexSuccess(Index index, final Entry[] currentList) {
        Entry entryToDelete = currentList[index.getZeroBased()];
        commandBox.runCommand(CommandUtil.getDeleteEventByIndexCommand(index));
        assertEventDeleted(entryToDelete, currentList);
    }

    /**
     * Runs the delete command to delete the deadline at {@code index} and confirms the result is correct.
     * @param currentList A copy of the current list of deadlines (before deletion).
     */
    private void assertDeleteDeadlineByIndexSuccess(Index index, final Entry[] currentList) {
        Entry entryToDelete = currentList[index.getZeroBased()];
        commandBox.runCommand(CommandUtil.getDeleteDeadlineByIndexCommand(index));
        assertDeadlineDeleted(entryToDelete, currentList);
    }

    /**
     * Runs the delete command to delete the floating task at {@code index} and confirms the result is correct.
     * @param currentList A copy of the current list of floating tasks (before deletion).
     */
    private void assertDeleteFloatingTaskByIndexSuccess(Index index, final Entry[] currentList) {
        Entry entryToDelete = currentList[index.getZeroBased()];
        commandBox.runCommand(CommandUtil.getDeleteFloatingTaskByIndexCommand(index));
        assertFloatingTaskDeleted(entryToDelete, currentList);
    }

    private void assertEventDeleted(Entry entryDeleted, final Entry[] currentList) {
        assertEventRemovedFromList(entryDeleted, currentList);
        assertResultMessage(String.format(DeleteCommand.MESSAGE_SUCCESS, entryDeleted));
    }

    private void assertEventDeletedByKeyword(Entry entryDeleted, final Entry[] currentList) {
        assertEventRemovedFromList(entryDeleted, currentList);
        assertResultMessage(String.format(DeleteByFindCommand.MESSAGE_SUCCESS, entryDeleted));
    }

    private void assertDeadlineDeleted(Entry entryDeleted, final Entry[] currentList) {
        assertDeadlineRemovedFromList(entryDeleted, currentList);
        assertResultMessage(String.format(DeleteCommand.MESSAGE_SUCCESS, entryDeleted));
    }

    private void assertDeadlineDeletedByKeyword(Entry entryDeleted, final Entry[] currentList) {
        assertDeadlineRemovedFromList(entryDeleted, currentList);
        assertResultMessage(String.format(DeleteByFindCommand.MESSAGE_SUCCESS, entryDeleted));
    }

    private void assertFloatingTaskDeleted(Entry entryDeleted, final Entry[] currentList) {
        assertFloatingTaskRemovedFromList(entryDeleted, currentList);
        assertResultMessage(String.format(DeleteCommand.MESSAGE_SUCCESS, entryDeleted));
    }

    private void assertFloatingTaskDeletedByKeyword(Entry entryDeleted, final Entry[] currentList) {
        assertFloatingTaskRemovedFromList(entryDeleted, currentList);
        assertResultMessage(String.format(DeleteByFindCommand.MESSAGE_SUCCESS, entryDeleted));
    }

    private void assertEventRemovedFromList(Entry entryDeleted, final Entry[] currentList) {
        Entry[] expectedList = TestUtil.removeEntriesFromList(currentList, entryDeleted);
        assertTrue(eventListPanel.isListMatching(expectedList));
    }

    private void assertDeadlineRemovedFromList(Entry entryDeleted, final Entry[] currentList) {
        Entry[] expectedList = TestUtil.removeEntriesFromList(currentList, entryDeleted);
        assertTrue(deadlineListPanel.isListMatching(expectedList));
    }

    private void assertFloatingTaskRemovedFromList(Entry entryDeleted, final Entry[] currentList) {
        Entry[] expectedList = TestUtil.removeEntriesFromList(currentList, entryDeleted);
        assertTrue(floatingTaskListPanel.isListMatching(expectedList));
    }

}
```
###### \java\guitests\EditCommandTest.java
``` java
public class EditCommandTest extends EntryBookGuiTest {

    /********************
     * Editing by Index *
     *******************/
    @Test
    public void edit_firstEventByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleEvents();
        Index targetIndex = SampleEntries.INDEX_FIRST_ENTRY;
        assertEditEventByIndexSuccess(targetIndex, currentList, SampleEntries.OPENING);
    }

    @Test
    public void edit_firstDeadlineByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleDeadlines();
        Index targetIndex = SampleEntries.INDEX_FIRST_ENTRY;
        assertEditDeadlineByIndexSuccess(targetIndex, currentList, SampleEntries.UPGRADE);
    }

    @Test
    public void edit_firstFloatingTaskByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleFloatingTasks();
        Index targetIndex = SampleEntries.INDEX_FIRST_ENTRY;
        assertEditFloatingTaskByIndexSuccess(targetIndex, currentList, SampleEntries.SELL);
    }

    /***************************
     * Editing by keyword find *
     **************************/
    @Test
    public void edit_eventKeyword_success() {
        Entry[] currentList = SampleEntries.getSampleEvents();
        assertEditEventByKeywordSuccess("dinner", currentList, SampleEntries.DINNER, SampleEntries.OPENING);
    }

    @Test
    public void edit_deadlineKeyword_success() {
        Entry[] currentList = SampleEntries.getSampleDeadlines();
        assertEditDeadlineByKeywordSuccess("tax", currentList, SampleEntries.TAX, SampleEntries.UPGRADE);
    }

    /*******************************
     * Mixed-case and autocomplete *
     ******************************/
    @Test
    public void edit_keyboardShortcut_success() {
        commandBox.pressKey(KeyCode.F2);
        assertTrue(commandBox.getCommandInput().equals(EditCommand.COMMAND_WORD + " "));
    }

    /*******************
     * Utility methods *
     ******************/
    private void assertEditEventByIndexSuccess(Index index, Entry[] currentList, Entry editedEntry) {
        commandBox.runCommand(CommandUtil.getEditEventByIndexCommand(index, editedEntry));
        ArrayList<Entry> expectedList = new ArrayList<>(Arrays.asList(currentList));
        expectedList.set(index.getZeroBased(), editedEntry);
        Collections.sort(expectedList, Comparators.EVENT_DEFAULT);
        commandBox.runCommand(ListCommand.COMMAND_WORD);
        assertTrue(eventListPanel.isListMatching(expectedList.toArray(new Entry[expectedList.size()])));
    }

    private void assertEditDeadlineByIndexSuccess(Index index, Entry[] currentList, Entry editedEntry) {
        commandBox.runCommand(CommandUtil.getEditDeadlineByIndexCommand(index, editedEntry));
        ArrayList<Entry> expectedList = new ArrayList<>(Arrays.asList(currentList));
        expectedList.set(index.getZeroBased(), editedEntry);
        Collections.sort(expectedList, Comparators.DEADLINE_DEFAULT);
        commandBox.runCommand(ListCommand.COMMAND_WORD);
        assertTrue(deadlineListPanel.isListMatching(expectedList.toArray(new Entry[expectedList.size()])));
    }

    private void assertEditFloatingTaskByIndexSuccess(Index index, Entry[] currentList, Entry editedEntry) {
        commandBox.runCommand(CommandUtil.getEditFloatingTaskByIndexCommand(index, editedEntry));
        ArrayList<Entry> expectedList = new ArrayList<>(Arrays.asList(currentList));
        expectedList.set(index.getZeroBased(), editedEntry);
        Collections.sort(expectedList, Comparators.FLOATING_TASK_DEFAULT);
        commandBox.runCommand(ListCommand.COMMAND_WORD);
        assertTrue(floatingTaskListPanel.isListMatching(expectedList.toArray(new Entry[expectedList.size()])));
    }

    private void assertEditEventByKeywordSuccess(String keywords, Entry[] currentList, Entry entryToEdit,
                                                 Entry editedEntry) {
        commandBox.runCommand(CommandUtil.getEditEventByKeywordCommand(keywords, editedEntry));
        Entry[] expectedList = TestUtil.removeEntriesFromList(currentList, entryToEdit);
        expectedList = TestUtil.addEntriesToList(expectedList, editedEntry);
        ArrayList<Entry> expected = new ArrayList<>(Arrays.asList(expectedList));
        Collections.sort(expected, Comparators.EVENT_DEFAULT);
        commandBox.runCommand(ListCommand.COMMAND_WORD);
        assertTrue(eventListPanel.isListMatching(expected.toArray(new Entry[expected.size()])));
    }

    private void assertEditDeadlineByKeywordSuccess(String keywords, Entry[] currentList, Entry entryToEdit,
                                                    Entry editedEntry) {
        commandBox.runCommand(CommandUtil.getEditDeadlineByKeywordCommand(keywords, editedEntry));
        Entry[] expectedList = TestUtil.removeEntriesFromList(currentList, entryToEdit);
        expectedList = TestUtil.addEntriesToList(expectedList, editedEntry);
        ArrayList<Entry> expected = new ArrayList<>(Arrays.asList(expectedList));
        Collections.sort(expected, Comparators.DEADLINE_DEFAULT);
        commandBox.runCommand(ListCommand.COMMAND_WORD);
        assertTrue(deadlineListPanel.isListMatching(expected.toArray(new Entry[expected.size()])));
    }

}
```
###### \java\guitests\EntryBookGuiTest.java
``` java
/**
 * A GUI Test class for EntryBook.
 */
public abstract class EntryBookGuiTest {

    /* The TestName Rule makes the current test name available inside test methods */
    @Rule
    public TestName name = new TestName();

    /*
     *   Handles to GUI elements present at the start up are created in advance
     *   for easy access from child classes.
     */
    protected MainWindowHandle mainGui;
    protected MainMenuHandle mainMenu;
    protected EventListPanelHandle eventListPanel;
    protected DeadlineListPanelHandle deadlineListPanel;
    protected FloatingTaskListPanelHandle floatingTaskListPanel;
    protected ResultDisplayHandle resultDisplay;
    protected CommandBoxHandle commandBox;
    protected StatusBarFooterHandle statusBarFooter;

    protected Stage stage;

    protected GuiRobot guiRobot;

    @BeforeClass
    public static void setupSpec() {
        try {
            FxToolkit.registerPrimaryStage();
            FxToolkit.hideStage();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }

    @Before
    public void setup() throws Exception {
        FxToolkit.setupStage((stage) -> {
            guiRobot = new GuiRobot();
            mainGui = new MainWindowHandle(guiRobot, stage);
            mainMenu = mainGui.getMainMenu();
            eventListPanel = mainGui.getEventListPanel();
            deadlineListPanel = mainGui.getDeadlineListPanel();
            floatingTaskListPanel = mainGui.getFloatingTaskListPanel();
            resultDisplay = mainGui.getResultDisplay();
            commandBox = mainGui.getCommandBox();
            statusBarFooter = mainGui.getStatusBarFooter();
            this.stage = stage;
        });
        EventsCenter.clearSubscribers();
        FxToolkit.setupApplication(() -> new TestApp(this::getInitialData, getDataFileLocation()));
        FxToolkit.showStage();
        while (!stage.isShowing());
        mainGui.focusOnMainApp();
    }

    /**
     * Override this in child classes to set the initial local data.
     * Return null to use the data in the file specified in {@link #getDataFileLocation()}
     */
    protected EntryBook getInitialData() {
        return SampleEntries.getSampleEntryBook();
    }

    /**
     * Override this in child classes to set the data file location.
     */
    protected String getDataFileLocation() {
        return TestApp.TESTING_SAVE_LOCATION;
    }

    @After
    public void cleanup() throws TimeoutException {
        FxToolkit.cleanupStages();
    }

    /**
     * Asserts the entry shown in the card is same as the given entry
     */
    public void assertMatching(ReadOnlyEntry entry, EntryCardHandle card) {
        assertTrue(TestUtil.compareCardAndEntry(card, entry));
    }

    /**
     * Asserts the size of the event list is equal to the given number.
     */
    protected void assertEventListSize(int size) {
        int numberOfEntries = eventListPanel.getNumberOfEntries();
        assertEquals(size, numberOfEntries);
    }

    /**
     * Asserts the size of the deadline list is equal to the given number.
     */
    protected void assertDeadlineListSize(int size) {
        int numberOfEntries = deadlineListPanel.getNumberOfEntries();
        assertEquals(size, numberOfEntries);
    }

    /**
     * Asserts the size of the floating task list is equal to the given number.
     */
    protected void assertFloatingTaskListSize(int size) {
        int numberOfEntries = floatingTaskListPanel.getNumberOfEntries();
        assertEquals(size, numberOfEntries);
    }

    /**
     * Asserts the message shown in the Result Display area is same as the given string.
     */
    protected void assertResultMessage(String expected) {
        assertEquals(expected, resultDisplay.getText());
    }

    /**
     * Asserts the message shown in the Command Box area is same as the given string.
     */
    protected void assertCommandBox(String expected) {
        assertEquals(expected, commandBox.getCommandInput());
    }

    public void raise(BaseEvent e) {
        //JUnit doesn't run its test cases on the UI thread. Platform.runLater is used to post event on the UI thread.
        Platform.runLater(() -> EventsCenter.getInstance().post(e));
    }
}
```
###### \java\guitests\ExitCommandTest.java
``` java
public class ExitCommandTest extends EntryBookGuiTest {
    /*******************************
     * Mixed-case and autocomplete *
     ******************************/
    @Test
    public void exit_keyboardShortcut_success() {
        commandBox.pressKey(KeyCode.F4);
        assertTrue(commandBox.getCommandInput().equals(ExitCommand.COMMAND_WORD + " "));
    }

}
```
###### \java\guitests\FindCommandTest.java
``` java
public class FindCommandTest extends EntryBookGuiTest {

    /**************
     * No matches *
     *************/
    @Test
    public void find_nonMatchingKeyword_noResult() {
        commandBox.runCommand(FindCommand.COMMAND_WORD + " " + "arstatrs");
        assertFindEventListMessage(0);
        assertFindDeadlineListMessage(0);
        assertFindFloatingTaskListMessage(0);
    }

    @Test
    public void find_emptyList_noResult() {
        commandBox.runCommand(ClearCommand.COMMAND_WORD);
        commandBox.runCommand(FindCommand.COMMAND_WORD + " " + "e");
        assertFindEventListMessage(0);
        assertFindDeadlineListMessage(0);
        assertFindFloatingTaskListMessage(0);
    }

    /*******************************
     * Single result for each type *
     ******************************/
    @Test
    public void find_matchingPartialKeyword_singleEventResult() {
        assertFindEventResult("nne", 1, SampleEntries.DINNER);
    }

    @Test
    public void find_matchingFullKeyword_singleEventResult() {
        assertFindEventResult("dinner", 1, SampleEntries.DINNER);
    }

    @Test
    public void find_matchingPartialKeyword_singleDeadlineResult() {
        assertFindDeadlineResult("rms", 1, SampleEntries.TAX);
    }

    @Test
    public void find_matchingFullKeyword_singleDeadlineResult() {
        assertFindDeadlineResult("forms", 1, SampleEntries.TAX);
    }

    @Test
    public void find_matchingPartialKeyword_singleFloatingTaskResult() {
        assertFindFloatingTaskResult("gra", 1, SampleEntries.PROGRAMMING);
    }

    @Test
    public void find_matchingFullKeyword_singleFloatingTaskResult() {
        assertFindFloatingTaskResult("programming", 1, SampleEntries.PROGRAMMING);
    }

    /**********************************
     * Multiple results for each type *
     *********************************/
    @Test
    public void find_matchingPartialKeyword_multipleDeadlineResults() {
        assertFindDeadlineResult("s", 4, SampleEntries.TAX, SampleEntries.PAPER);
    }

    @Test
    public void find_matchingFullKeyword_multipleFloatingTaskResults() {
        assertFindFloatingTaskResult("learn", 2, SampleEntries.COOK, SampleEntries.PROGRAMMING);
    }

    /**************************************
     * Different types of invalid wording *
     **************************************/
    @Test
    public void find_unknownCommandName_errorMessage() {
        commandBox.runCommand(FindCommand.COMMAND_WORD.substring(0, FindCommand.COMMAND_WORD.length() - 1));
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand(FindCommand.COMMAND_WORD + "a");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void find_invalidCommandFormat_errorMessage() {
        commandBox.runCommand(FindCommand.COMMAND_WORD);
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT,
                                          FindCommand.MESSAGE_USAGE));
    }

    /*******************************
     * Mixed-case and autocomplete *
     ******************************/
    /**
     * For all mixed-case tests only floating task entries are tested,
     * which should be suitable to test for all types since the type of task
     * doesn't affect the parsing of the command word.
     */
    @Test
    public void find_firstCharUppercase_success() {
        char[] commandWord = FindCommand.COMMAND_WORD.toCharArray();
        commandWord[0] = Character.toUpperCase(commandWord[0]);
        assertFindWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void find_lastCharUppercase_success() {
        char[] commandWord = FindCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length - 1] = Character.toUpperCase(commandWord[commandWord.length - 1]);
        assertFindWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void find_middleCharUppercase_success() {
        char[] commandWord = FindCommand.COMMAND_WORD.toCharArray();
        commandWord[commandWord.length / 2] = Character.toUpperCase(commandWord[commandWord.length / 2]);
        assertFindWithCommandWord(String.copyValueOf(commandWord));
    }

    @Test
    public void find_allCharUppercase_success() {
        String commandWord = FindCommand.COMMAND_WORD.toUpperCase();
        assertFindWithCommandWord(commandWord);
    }

    @Test
    public void find_tabAutocomplete_success() {
        for (int i = 1; i < FindCommand.COMMAND_WORD.length(); ++i) {
            assertFindTabAutocomplete(FindCommand.COMMAND_WORD.substring(0, i));
        }
        assertFindTabAutocomplete(FindCommand.COMMAND_WORD + "a");
        assertFindTabAutocomplete(FindCommand.COMMAND_WORD + "aa");
    }

    @Test
    public void find_keyboardShortcut_success() {
        commandBox.pressKey(KeyCode.F3);
        assertTrue(commandBox.getCommandInput().equals(FindCommand.COMMAND_WORD + " "));
    }

    /*******************
     * Utility methods *
     ******************/
    /**
     * Confirms that the given input string will autocomplete to the correct find command word.
     */
    private void assertFindTabAutocomplete(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(FindCommand.COMMAND_WORD + " ");
    }

    private void assertFindWithCommandWord(String commandWord) {
        commandBox.runCommand(commandWord + " programming");
        assertFindFloatingTaskListMessage(1, SampleEntries.PROGRAMMING);
    }

    private void assertFindEventResult(String keywords, int numExpectedTotalResults,
                                       Entry... expectedEventResults) {
        commandBox.runCommand(FindCommand.COMMAND_WORD + " " + keywords);
        assertFindEventListMessage(numExpectedTotalResults, expectedEventResults);
    }

    private void assertFindDeadlineResult(String keywords, int numExpectedTotalResults,
                                           Entry... expectedDeadlineResults) {
        commandBox.runCommand(FindCommand.COMMAND_WORD + " " + keywords);
        assertFindDeadlineListMessage(numExpectedTotalResults, expectedDeadlineResults);
    }

    private void assertFindFloatingTaskResult(String keywords, int numExpectedTotalResults,
                                              Entry... expectedFloatingTaskResults) {
        commandBox.runCommand(FindCommand.COMMAND_WORD + " " + keywords);
        assertFindFloatingTaskListMessage(numExpectedTotalResults, expectedFloatingTaskResults);
    }

    private void assertFindEventListMessage(int numExpectedTotalResults, Entry... expectedEventResults) {
        assertEventListSize(expectedEventResults.length);
        assertResultMessage(numExpectedTotalResults + " entries listed!");
        assertTrue(eventListPanel.isListMatching(expectedEventResults));
    }

    private void assertFindDeadlineListMessage(int numExpectedTotalResults,
                                               Entry... expectedDeadlineResults) {
        assertDeadlineListSize(expectedDeadlineResults.length);
        assertResultMessage(numExpectedTotalResults + " entries listed!");
        assertTrue(deadlineListPanel.isListMatching(expectedDeadlineResults));
    }

    private void assertFindFloatingTaskListMessage(int numExpectedTotalResults,
                                                   Entry... expectedFloatingTaskResults) {
        assertFloatingTaskListSize(expectedFloatingTaskResults.length);
        assertResultMessage(numExpectedTotalResults + " entries listed!");
        assertTrue(floatingTaskListPanel.isListMatching(expectedFloatingTaskResults));
    }

}
```
###### \java\guitests\guihandles\DeadlineListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the deadline list.
 */
public class DeadlineListPanelHandle extends EntryListPanelHandle {

    public DeadlineListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage);
        listViewId = "#deadlineListView";
    }

    /**
     * Gets an entry handle for a deadline entry in the list by index
     */
    @Override
    public EntryCardHandle getEntryCardHandle(int index) {
        return getEntryCardHandle(new Deadline(getListView().getItems().get(index)));
    }
}
```
###### \java\guitests\guihandles\EntryCardHandle.java
``` java
/**
 * Provides a handle to a entry card in the entry list panel.
 */
public class EntryCardHandle extends GuiHandle {
    private static final String NAME_FIELD_ID = "#name";
    private static final String START_DATE_TIME_ID = "#startDateTime";
    private static final String END_DATE_TIME_ID = "#endDateTime";
    private static final String ADDITIONAL_INFO_ID = "#additionalInfo";
    private static final String TAGS_FIELD_ID = "#tags";

    private Node node;

    public EntryCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node) {
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getName() {
        return getTextFromLabel(NAME_FIELD_ID);
    }

    public String getStartDateTime() {
        return getTextFromLabel(START_DATE_TIME_ID);
    }

    public String getEndDateTime() {
        return getTextFromLabel(END_DATE_TIME_ID);
    }

    public String getAdditionalInfo() {
        return getTextFromLabel(ADDITIONAL_INFO_ID);
    }

    public List<String> getTags() {
        return getTags(getTagsContainer());
    }

    private List<String> getTags(Region tagsContainer) {
        return tagsContainer
                .getChildrenUnmodifiable()
                .stream()
                .map(node -> ((Labeled) node).getText())
                .collect(Collectors.toList());
    }

    private List<String> getTags(Set<Tag> tags) {
        return tags
                .stream()
                .map(tag -> tag.tagName)
                .collect(Collectors.toList());
    }

    private Region getTagsContainer() {
        return guiRobot.from(node).lookup(TAGS_FIELD_ID).query();
    }

    public boolean isSameEntry(ReadOnlyEntry entry) {
        //TODO add more checks once other Entry fields are ready
        return getName().equals(entry.getName().toString())
                && getTags().equals(getTags(entry.getTags()));
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof EntryCardHandle) {
            EntryCardHandle handle = (EntryCardHandle) obj;
            return getName().equals(handle.getName())
                && getTags().equals(handle.getTags());
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getName();
    }
}
```
###### \java\guitests\guihandles\EntryListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the event entry list.
 */
public abstract class EntryListPanelHandle extends GuiHandle {

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#cardPane";

    protected String listViewId;

    public EntryListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
        listViewId = "#entryListView";
    }

    public List<ReadOnlyEntry> getSelectedEntries() {
        ListView<ReadOnlyEntry> entryList = getListView();
        return entryList.getSelectionModel().getSelectedItems();
    }

    public ListView<ReadOnlyEntry> getListView() {
        return getNode(listViewId);
    }

    /**
     * Returns true if the list is showing the entry details correctly and in correct order.
     * @param entries A list of entries in the correct order.
     */
    public boolean isListMatching(ReadOnlyEntry... entries) {
        return this.isListMatching(0, entries);
    }

    /**
     * Returns true if the list is showing the entry details correctly and in correct order.
     * @param startPosition The starting position of the sub list.
     * @param entries A list of entries in the correct order.
     */
    public boolean isListMatching(int startPosition, ReadOnlyEntry... entries) throws IllegalArgumentException {
        if (entries.length + startPosition != getListView().getItems().size()) {
            throw new IllegalArgumentException("List size mismatched\n"
                    + "Expected " + (getListView().getItems().size() - 1) + " entries, "
                    + "got " + (entries.length + startPosition - 1));
        }
        assertTrue(this.containsInOrder(startPosition, entries));
        for (int i = 0; i < entries.length; i++) {
            final int scrollTo = i + startPosition;
            guiRobot.interact(() -> getListView().scrollTo(scrollTo));
            guiRobot.sleep(200);
            if (!TestUtil.compareCardAndEntry(getEntryCardHandle(scrollTo), entries[i])) {
                return false;
            }
        }
        return true;
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point = TestUtil.getScreenMidPoint(getListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code entries} appear as the sub list (in that order) at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ReadOnlyEntry... entries) {
        List<ReadOnlyEntry> entriesInList = getListView().getItems();

        // Return false if the list in panel is too short to contain the given list
        if (startPosition + entries.length > entriesInList.size()) {
            return false;
        }

        // Return false if any of the entries doesn't match
        for (int i = 0; i < entries.length; i++) {
            if (!entriesInList.get(startPosition + i).getName().toString().equals(entries[i].getName().toString())) {
                return false;
            }
        }

        return true;
    }

    /**
     * Navigates the listview to display and select the entry that matches the {@code name}.
     */
    public EntryCardHandle navigateToEntry(String name) {
        guiRobot.sleep(500); //Allow a bit of time for the list to be updated
        final Optional<ReadOnlyEntry> entry = getListView().getItems().stream()
                                                .filter(p -> p.getName().toString().equals(name))
                                                .findAny();
        if (!entry.isPresent()) {
            throw new IllegalStateException("Name of entry not found: " + name);
        }

        return navigateToEntry(entry.get());
    }

    /**
     * Navigates the listview to display and select the entry.
     */
    public EntryCardHandle navigateToEntry(ReadOnlyEntry entry) {
        int index = getEntryIndex(entry);

        guiRobot.interact(() -> {
            getListView().scrollTo(index);
            guiRobot.sleep(150);
            getListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(100);
        return getEntryCardHandle(entry);
    }


    /**
     * Returns the position index of the entry given, {@code NOT_FOUND} if not found in the list.
     */
    public int getEntryIndex(ReadOnlyEntry target) {
        List<ReadOnlyEntry> entriesInList = getListView().getItems();
        for (int i = 0; i < entriesInList.size(); i++) {
            if (entriesInList.get(i).getName().equals(target.getName())) {
                return i;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets an entry from the list by index
     */
    public ReadOnlyEntry getEntry(int index) {
        return getListView().getItems().get(index);
    }

    /**
     * Gets an entry handle for an entry in the list by index
     */
    public EntryCardHandle getEntryCardHandle(int index) {
        assert false : "EntryListPanelHandle::getEntryCardHandle should not be called";
        return null;
    }

    /**
     * Gets an entry handle for an entry in the list
     */
    public EntryCardHandle getEntryCardHandle(ReadOnlyEntry entry) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> entryCardNode = nodes.stream()
                .filter(n -> new EntryCardHandle(guiRobot, primaryStage, n).isSameEntry(entry))
                .findFirst();
        if (entryCardNode.isPresent()) {
            return new EntryCardHandle(guiRobot, primaryStage, entryCardNode.get());
        } else {
            return null;
        }
    }

    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(CARD_PANE_ID).queryAll();
    }

    public int getNumberOfEntries() {
        return getListView().getItems().size();
    }

    public boolean isEmpty() {
        return getListView().getItems().size() == 0;
    }
}
```
###### \java\guitests\guihandles\EventListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the event list.
 */
public class EventListPanelHandle extends EntryListPanelHandle {

    public EventListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage);
        listViewId = "#eventListView";
    }

    /**
     * Gets an entry handle for a event entry in the list by index
     */
    @Override
    public EntryCardHandle getEntryCardHandle(int index) {
        return getEntryCardHandle(new Event(getListView().getItems().get(index)));
    }
}
```
###### \java\guitests\guihandles\FloatingTaskListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the floating task list.
 */
public class FloatingTaskListPanelHandle extends EntryListPanelHandle {

    public FloatingTaskListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage);
        listViewId = "#floatingTaskListView";
    }

    /**
     * Gets an entry handle for a floating list entry in the list by index
     */
    @Override
    public EntryCardHandle getEntryCardHandle(int index) {
        return getEntryCardHandle(new FloatingTask(getListView().getItems().get(index)));
    }
}
```
###### \java\guitests\guihandles\GuiHandle.java
``` java
    public void pressUpKey() {
        guiRobot.type(KeyCode.UP).sleep(250);
    }

    public void pressDownKey() {
        guiRobot.type(KeyCode.DOWN).sleep(250);
    }

    public void pressTabKey() {
        guiRobot.type(KeyCode.TAB).sleep(250);
    }

    public void pressKey(KeyCode keycode) {
        guiRobot.type(keycode).sleep(250);
    }

    public void pressKeyCombination(KeyCodeCombination keyCodeCombination) {
        guiRobot.push(keyCodeCombination).sleep(250);
    }
```
###### \java\guitests\guihandles\MainWindowHandle.java
``` java
/**
 * Provides a handle for {@code MainWindow}.
 */
public class MainWindowHandle extends GuiHandle {

    private final EventListPanelHandle eventListPanel;
    private final DeadlineListPanelHandle deadlineListPanel;
    private final FloatingTaskListPanelHandle floatingTaskListPanel;
    private final ResultDisplayHandle resultDisplay;
    private final CommandBoxHandle commandBox;
    private final StatusBarFooterHandle statusBarFooter;
    private final MainMenuHandle mainMenu;

    public MainWindowHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);

        eventListPanel = new EventListPanelHandle(guiRobot, primaryStage);
        deadlineListPanel = new DeadlineListPanelHandle(guiRobot, primaryStage);
        floatingTaskListPanel = new FloatingTaskListPanelHandle(guiRobot, primaryStage);

        resultDisplay = new ResultDisplayHandle(guiRobot, primaryStage);
        commandBox = new CommandBoxHandle(guiRobot, primaryStage, TestApp.APP_TITLE);
        statusBarFooter = new StatusBarFooterHandle(guiRobot, primaryStage);
        mainMenu = new MainMenuHandle(guiRobot, primaryStage);
    }

    public EventListPanelHandle getEventListPanel() {
        return eventListPanel;
    }

    public DeadlineListPanelHandle getDeadlineListPanel() {
        return deadlineListPanel;
    }

    public FloatingTaskListPanelHandle getFloatingTaskListPanel() {
        return floatingTaskListPanel;
    }

    public ResultDisplayHandle getResultDisplay() {
        return resultDisplay;
    }

    public CommandBoxHandle getCommandBox() {
        return commandBox;
    }

    public StatusBarFooterHandle getStatusBarFooter() {
        return statusBarFooter;
    }

    public MainMenuHandle getMainMenu() {
        return mainMenu;
    }

}
```
###### \java\guitests\HelpWindowTest.java
``` java
public class HelpWindowTest extends EntryBookGuiTest {

    /*********************
     * Using accelerator *
     ********************/
    @Test
    public void helpWindow_usingAcceleratorInCommandBox_open() {
        commandBox.clickOnTextField();
        assertHelpWindowOpen(mainMenu.openHelpWindowUsingAccelerator());
    }

    @Test
    public void helpWindow_usingAcceleratorInResultDisplay_open() {
        resultDisplay.clickOnTextArea();
        assertHelpWindowOpen(mainMenu.openHelpWindowUsingAccelerator());
    }

    @Test
    public void helpWindow_usingAcceleratorInEventListPanel_open() {
        eventListPanel.clickOnListView();
        assertHelpWindowOpen(mainMenu.openHelpWindowUsingAccelerator());
    }

    @Test
    public void helpWindow_usingAcceleratorInDeadlineListPanel_open() {
        deadlineListPanel.clickOnListView();
        assertHelpWindowOpen(mainMenu.openHelpWindowUsingAccelerator());
    }

    @Test
    public void helpWindow_usingAcceleratorInFloatingTaskListPanel_open() {
        floatingTaskListPanel.clickOnListView();
        assertHelpWindowOpen(mainMenu.openHelpWindowUsingAccelerator());
    }

    /*********************
     * Using help button *
     ********************/
    @Test
    public void helpWindow_usingMenuButton_open() {
        assertHelpWindowOpen(mainMenu.openHelpWindowUsingMenu());
    }

    /*****************
     * Using command *
     ****************/
    @Test
    public void helpWindow_usingCommand_open() {
        assertHelpWindowOpen(commandBox.runHelpCommand());
    }

    /**************************************
     * Different types of invalid wording *
     *************************************/
    @Test
    public void help_unknownCommandName_errorMessage() {
        commandBox.runCommand(HelpCommand.COMMAND_WORD.substring(0, HelpCommand.COMMAND_WORD.length() - 1));
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand(HelpCommand.COMMAND_WORD + "a");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    /*******************************
     * Mixed-case and autocomplete *
     ******************************/
    @Test
    public void help_tabAutocomplete_success() {
        assertHelpTabAutocompleteFailure(HelpCommand.COMMAND_WORD.substring(0, 1));
        for (int i = 2; i < HelpCommand.COMMAND_WORD.length(); ++i) {
            assertHelpTabAutocomplete(HelpCommand.COMMAND_WORD.substring(0, i));
        }
        assertHelpTabAutocomplete(HelpCommand.COMMAND_WORD + "a");
        assertHelpTabAutocomplete(HelpCommand.COMMAND_WORD + "aa");
    }

    /**
     * Confirms that the given input string will autocomplete to the correct help command word.
     */
    private void assertHelpTabAutocomplete(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(HelpCommand.COMMAND_WORD + " ");
    }

    private void assertHelpTabAutocompleteFailure(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(input);
    }

    private void assertHelpWindowOpen(HelpWindowHandle helpWindowHandle) {
        assertTrue(helpWindowHandle.isWindowOpen());
        helpWindowHandle.closeWindow();
    }

}
```
###### \java\guitests\ListCommandTest.java
``` java
public class ListCommandTest extends EntryBookGuiTest {

    /********************************
     * Listing the different states *
     *******************************/
    @Test
    public void list_active_showEverything() {
        commandBox.runCommand(ListCommand.COMMAND_WORD);
        assertTrue(eventListPanel.isListMatching(SampleEntries.getSampleEvents()));
        assertTrue(deadlineListPanel.isListMatching(SampleEntries.getSampleDeadlines()));
        assertTrue(floatingTaskListPanel.isListMatching(SampleEntries.getSampleFloatingTasks()));
    }

    @Test
    public void list_archive_empty() {
        commandBox.runCommand(ListCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_ARCHIVE);
        assertTrue(eventListPanel.isListMatching(new Entry[0]));
        assertTrue(deadlineListPanel.isListMatching(new Entry[0]));
        assertTrue(floatingTaskListPanel.isListMatching(new Entry[0]));
    }

    @Test
    public void list_bin_empty() {
        commandBox.runCommand(ListCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_BIN);
        assertTrue(eventListPanel.isListMatching(new Entry[0]));
        assertTrue(deadlineListPanel.isListMatching(new Entry[0]));
        assertTrue(floatingTaskListPanel.isListMatching(new Entry[0]));
    }

    /********************************
     * Listing the different orders *
     *******************************/
    @Test
    public void list_activeReverse_success() {
        commandBox.runCommand(ListCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_REVERSE);
        assertTrue(eventListPanel.isListMatching(reverse(SampleEntries.getSampleEvents())));
        assertTrue(deadlineListPanel.isListMatching(reverse(SampleEntries.getSampleDeadlines())));
        assertTrue(floatingTaskListPanel.isListMatching(SampleEntries.getSampleFloatingTasks()));
    }

    @Test
    public void list_activeUpcoming_success() {
        commandBox.runCommand(ListCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_UPCOMING);
        assertTrue(floatingTaskListPanel.isListMatching(SampleEntries.getSampleFloatingTasks()));
    }

    /*****************************************
     * Deleting an entry and listing the bin *
     ****************************************/
    @Test
    public void list_deleteEvent_listedInBin() {
        Index index = SampleEntries.INDEX_FIRST_ENTRY;
        Entry[] currentList = SampleEntries.getSampleEvents();
        Entry entryToDelete = currentList[index.getZeroBased()];
        commandBox.runCommand(CommandUtil.getDeleteEventByIndexCommand(index));
        commandBox.runCommand(ListCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_BIN);
        assertTrue(eventListPanel.isListMatching(entryToDelete));
    }

    @Test
    public void list_deleteDeadline_listedInBin() {
        Index index = SampleEntries.INDEX_FIRST_ENTRY;
        Entry[] currentList = SampleEntries.getSampleDeadlines();
        Entry entryToDelete = currentList[index.getZeroBased()];
        commandBox.runCommand(CommandUtil.getDeleteDeadlineByIndexCommand(index));
        commandBox.runCommand(ListCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_BIN);
        assertTrue(deadlineListPanel.isListMatching(entryToDelete));
    }

    @Test
    public void list_deleteFloatingTask_listedInBin() {
        Index index = SampleEntries.INDEX_FIRST_ENTRY;
        Entry[] currentList = SampleEntries.getSampleFloatingTasks();
        Entry entryToDelete = currentList[index.getZeroBased()];
        commandBox.runCommand(CommandUtil.getDeleteFloatingTaskByIndexCommand(index));
        commandBox.runCommand(ListCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_BIN);
        assertTrue(floatingTaskListPanel.isListMatching(entryToDelete));
    }

    @Test
    public void list_keyboardShortcut_success() {
        commandBox.pressKey(KeyCode.F5);
        assertTrue(commandBox.getCommandInput().equals(ListCommand.COMMAND_WORD + " "));
    }

    /*******************************
     * Mixed-case and autocomplete *
     ******************************/
    @Test
    public void list_tabAutocomplete_success() {
        for (int i = 1; i < ListCommand.COMMAND_WORD.length(); ++i) {
            assertListTabAutocomplete(ListCommand.COMMAND_WORD.substring(0, i));
        }
        assertListTabAutocomplete(ListCommand.COMMAND_WORD + "a");
        assertListTabAutocomplete(ListCommand.COMMAND_WORD + "aa");
    }

    @Test
    public void list_tabAutocompleteKeyword_success() {
        commandBox.enterCommand("l r");
        commandBox.pressTabKey();
        assertCommandBox("list reverse ");

        commandBox.enterCommand("l u f");
        commandBox.pressTabKey();
        assertCommandBox("list upcoming from ");
    }


    /*******************
     * Utility methods *
     ******************/
    private Entry[] reverse(Entry... entries) {
        Entry[] reversed = new Entry[entries.length];
        for (int i = 0; i < entries.length; ++i) {
            reversed[i] = EntryBuilder.build(entries[entries.length - 1 - i]);
        }
        return reversed;
    }

    /**
     * Confirms that the given input string will autocomplete to the correct command word.
     */
    private void assertListTabAutocomplete(String input) {
        commandBox.enterCommand(input);
        commandBox.pressTabKey();
        assertCommandBox(ListCommand.COMMAND_WORD + " ");
    }
}
```
###### \java\guitests\UndoRedoCommandTest.java
``` java
public class UndoRedoCommandTest extends EntryBookGuiTest {

    /************************
     * Nothing to undo/redo *
     ***********************/
    @Test
    public void undo_shortcutNoSnapshot_errorMessage() {
        commandBox.pressKeyCombination(new KeyCodeCombination(KeyCode.Z, KeyCombination.CONTROL_DOWN));
        assertResultMessage(UndoCommand.MESSAGE_FAILURE);
    }

    @Test
    public void redo_shortcutNoSnapshot_errorMessage() {
        commandBox.pressKeyCombination(new KeyCodeCombination(KeyCode.R, KeyCombination.CONTROL_DOWN));
        assertResultMessage(RedoCommand.MESSAGE_FAILURE);
    }

    /*************************
     * Undo/redo add command *
     ************************/
    @Test
    public void undoRedo_addEvents_success() {
        Entry[] currentList = SampleEntries.getSampleEvents();
        Entry[] startingList = currentList.clone();
        Entry entryToAdd = SampleEntries.MOVIE;
        commandBox.runCommand(CommandUtil.getAddEventCommand(entryToAdd));
        assertEventAdded(entryToAdd, currentList);
        currentList = TestUtil.addEntriesToSortedList(currentList, entryToAdd);

        Entry[] middleList = currentList.clone();
        entryToAdd = SampleEntries.OPENING;
        commandBox.runCommand(CommandUtil.getAddEventCommand(entryToAdd));
        assertEventAdded(entryToAdd, currentList);
        currentList = TestUtil.addEntriesToSortedList(currentList, entryToAdd);

        commandBox.runCommand(UndoCommand.COMMAND_WORD);
        assertTrue(eventListPanel.isListMatching(middleList));

        commandBox.runCommand(UndoCommand.COMMAND_WORD);
        assertTrue(eventListPanel.isListMatching(startingList));

        commandBox.runCommand(RedoCommand.COMMAND_WORD);
        assertTrue(eventListPanel.isListMatching(middleList));

        commandBox.runCommand(RedoCommand.COMMAND_WORD);
        assertTrue(eventListPanel.isListMatching(currentList));
    }

    /**
     * Confirms that the added entry is in the expected list, and that the
     * expected list matches the displayed list.
     */
    private void assertEventAdded(Entry entryAdded, Entry... currentList) {
        EntryCardHandle addedCard = eventListPanel.navigateToEntry(entryAdded.getName().toString());
        assertMatching(entryAdded, addedCard);
        Entry[] expectedList = TestUtil.addEntriesToSortedList(currentList, entryAdded);
        assertTrue(eventListPanel.isListMatching(expectedList));
    }
}
```
###### \java\seedu\multitasky\commons\util\PowerMatchTest.java
``` java
public class PowerMatchTest {

    /****************************************
     * Level 0 - substring, prefix, acronym *
     ***************************************/
    @Test
    public void powerMatch_matchLevel0Substring_match() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_0, "abc", "xyzabcxyz").equals("xyzabcxyz"));
    }

    @Test
    public void powerMatch_matchLevel0Substring_noMatch() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_0, "abc", "xyzxyz") == null);
    }

    @Test
    public void powerMatch_matchLevel0Prefix_match() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_0, "abc", "abcxyz").equals("abcxyz"));
    }

    @Test
    public void powerMatch_matchLevel0Prefix_noMatch() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_0, "abc", "xyzxyz") == null);
    }

    @Test
    public void powerMatch_matchLevel0Acronym_match() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_0, "abc", "axbycz").equals("axbycz"));
    }

    @Test
    public void powerMatch_matchLevel0Acronym_noMatch() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_0, "abc", "xyzxyz") == null);
    }

    @Test
    public void powerMatch_isMatchLevel0Substring_match() {
        assertTrue(PowerMatch.isMatch(PowerMatch.Level.LEVEL_0, "abc", "xyzabcxyz"));
    }

    @Test
    public void powerMatch_isMatchLevel0Substring_noMatch() {
        assertFalse(PowerMatch.isMatch(PowerMatch.Level.LEVEL_0, "abc", "xyzxyz"));
    }

    @Test
    public void powerMatch_isMatchLevel0Prefix_match() {
        assertTrue(PowerMatch.isMatch(PowerMatch.Level.LEVEL_0, "abc", "abcxyz"));
    }

    @Test
    public void powerMatch_isMatchLevel0Prefix_noMatch() {
        assertFalse(PowerMatch.isMatch(PowerMatch.Level.LEVEL_0, "abc", "xyzxyz"));
    }

    @Test
    public void powerMatch_isMatchLevel0Acronym_match() {
        assertTrue(PowerMatch.isMatch(PowerMatch.Level.LEVEL_0, "abc", "axbycz"));
    }

    @Test
    public void powerMatch_isMatchLevel0Acronym_noMatch() {
        assertFalse(PowerMatch.isMatch(PowerMatch.Level.LEVEL_0, "abc", "xyzxyz"));
    }

    /*************************
     * Level 1 - permutation *
     ************************/
    @Test
    public void powerMatch_matchLevel1Permutation_match() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_1, "acb", "abcxyz").equals("abcxyz"));
    }

    @Test
    public void powerMatch_matchLevel1Permutation_noMatch() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_1, "acb", "xyzxyz") == null);
    }

    @Test
    public void powerMatch_isMatchLevel1Permutation_match() {
        assertTrue(PowerMatch.isMatch(PowerMatch.Level.LEVEL_1, "acb", "abcxyz"));
    }

    @Test
    public void powerMatch_isMatchLevel1Permutation_noMatch() {
        assertFalse(PowerMatch.isMatch(PowerMatch.Level.LEVEL_1, "acb", "xyzxyz"));
    }

    /*********************
     * Level 2 - missing *
     ********************/
    @Test
    public void powerMatch_matchLevel2Missing_match() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_2, "ac", "abcxyz").equals("abcxyz"));
    }

    @Test
    public void powerMatch_matchLevel2Missing_noMatch() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_2, "ac", "xyzxyz") == null);
    }

    @Test
    public void powerMatch_isMatchLevel2Missing_match() {
        assertTrue(PowerMatch.isMatch(PowerMatch.Level.LEVEL_2, "ac", "abcxyz"));
    }

    @Test
    public void powerMatch_isMatchLevel2Missing_noMatch() {
        assertFalse(PowerMatch.isMatch(PowerMatch.Level.LEVEL_2, "ac", "xyzxyz"));
    }

    /***************************
     * Level 3 - 1 wrong/extra *
     **************************/
    @Test
    public void powerMatch_matchLevel3WrongExtra1_match() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_3, "abdc", "abcxyz").equals("abcxyz"));
    }

    @Test
    public void powerMatch_matchLevel3WrongExtra1_noMatch() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_3, "abdc", "xyzxyz") == null);
    }

    @Test
    public void powerMatch_isMatchLevel3WrongExtra1_match() {
        assertTrue(PowerMatch.isMatch(PowerMatch.Level.LEVEL_3, "abdc", "abcxyz"));
    }

    @Test
    public void powerMatch_isMatchLevel3WrongExtra1_noMatch() {
        assertFalse(PowerMatch.isMatch(PowerMatch.Level.LEVEL_3, "abdc", "xyzxyz"));
    }

    /***************************
     * Level 4 - 2 wrong/extra *
     **************************/
    @Test
    public void powerMatch_matchLevel4WrongExtra2_match() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_4, "adbec", "abcxyz").equals("abcxyz"));
    }

    @Test
    public void powerMatch_matchLevel4WrongExtra2_noMatch() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_4, "adbec", "xyzxyz") == null);
    }

    @Test
    public void powerMatch_isMatchLevel4WrongExtra2_match() {
        assertTrue(PowerMatch.isMatch(PowerMatch.Level.LEVEL_4, "adbec", "abcxyz"));
    }

    @Test
    public void powerMatch_isMatchLevel4WrongExtra2_noMatch() {
        assertFalse(PowerMatch.isMatch(PowerMatch.Level.LEVEL_4, "adbec", "xyzxyz"));
    }

    /***************************
     * Level 5 - 3 wrong/extra *
     **************************/
    @Test
    public void powerMatch_matchLevel5WrongExtra3_match() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_5, "adbecf", "abcxyz").equals("abcxyz"));
    }

    @Test
    public void powerMatch_matchLevel5WrongExtra3_noMatch() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_5, "adbecf", "xyzxyz") == null);
    }

    @Test
    public void powerMatch_isMatchLevel5WrongExtra3_match() {
        assertTrue(PowerMatch.isMatch(PowerMatch.Level.LEVEL_5, "adbecf", "abcxyz"));
    }

    @Test
    public void powerMatch_isMatchLevel5WrongExtra3_noMatch() {
        assertFalse(PowerMatch.isMatch(PowerMatch.Level.LEVEL_5, "adbecf", "xyzxyz"));
    }

    /*********************************
     * Level 6 - acronym permutation *
     ********************************/
    @Test
    public void powerMatch_matchLevel6AcronymPermutation_match() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_6, "abcd", "aefbghcid").equals("aefbghcid"));
    }

    @Test
    public void powerMatch_matchLevel6AcronymPermutation_noMatch() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_6, "abcd", "xyzxyz") == null);
    }

    @Test
    public void powerMatch_isMatchLevel6AcronymPermutation_match() {
        assertTrue(PowerMatch.isMatch(PowerMatch.Level.LEVEL_6, "abcd", "aefbghcid"));
    }

    @Test
    public void powerMatch_isMatchLevel6AcronymPermutation_noMatch() {
        assertFalse(PowerMatch.isMatch(PowerMatch.Level.LEVEL_6, "abcd", "xyzxyz"));
    }

    /*******************
     * Null conditions *
     ******************/
    @Test
    public void powerMatch_matchNullEmptyArguments_nullResult() {
        assertTrue(PowerMatch.match(null, null, (String[]) null) == null);
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_6, null, (String[]) null) == null);
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_6, null) == null);
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_6, "", "xyz", "abc") == null);
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_6, "abc", (String[]) null) == null);
        assertTrue(PowerMatch.match(null, (String[]) null) == null);
        assertTrue(PowerMatch.match(null) == null);
        assertTrue(PowerMatch.match("abc", (String[]) null) == null);
    }

    @Test
    public void powerMatch_isMatchNullArguments_falseResult() {
        assertFalse(PowerMatch.isMatch(PowerMatch.Level.LEVEL_6, null, null));
        assertFalse(PowerMatch.isMatch(PowerMatch.Level.LEVEL_6, null, ""));
    }

    @Test
    public void powerMatch_matchEmptyInputOnePotential_notNullResult() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_6, "", "xyzabc").equals("xyzabc"));
        assertTrue(PowerMatch.match("", "xyzabc").equals("xyzabc"));
    }

    @Test
    public void powerMatch_isMatchEmptyInput_trueResult() {
        assertTrue(PowerMatch.isMatch(PowerMatch.Level.LEVEL_6, "", "xyzabcxyz"));
    }

    @Test
    public void powerMatch_match_noMatches() {
        assertTrue(PowerMatch.match(PowerMatch.Level.LEVEL_6, "abcdef", "lmnopq") == null);
    }

    @Test
    public void powerMatch_isMatch_noMatches() {
        assertFalse(PowerMatch.isMatch(PowerMatch.Level.LEVEL_6, "abcdef", "lmnopq"));
    }

}
```
###### \java\seedu\multitasky\model\util\EntryBuilderTest.java
``` java
    @Test
    public void wrongName_illegalValueException() {
        boolean thrown = false;
        try {
            EntryBuilder.build("$event",
                               new GregorianCalendar(2000, Calendar.JANUARY, 1, 00, 00),
                               new GregorianCalendar(2000, Calendar.JANUARY, 1, 02, 00),
                               "party", "fun");
        } catch (IllegalValueException e) {
            thrown = true;
        }
        assertTrue(thrown);
        thrown = false;

        try {
            EntryBuilder.build("$deadline",
                               null,
                               new GregorianCalendar(2005, Calendar.MAY, 5, 17, 00),
                               "tag1", "tag2");
            EntryBuilder.build("$deadline",
                               new GregorianCalendar(2005, Calendar.MAY, 5, 17, 00),
                               "tag1", "tag2");
        } catch (IllegalValueException e) {
            thrown = true;
        }

        try {
            EntryBuilder.build("$float",
                               "tag1", "tag2");
        } catch (IllegalValueException e) {
            thrown = true;
        }
        assertTrue(thrown);
        thrown = false;
    }

```
###### \java\seedu\multitasky\model\util\EntryBuilderTest.java
``` java
    @Test
    public void buildEvent() {
        Entry entry = null;
        try {
            entry = EntryBuilder.build("Event1",
                                       new GregorianCalendar(2000, Calendar.JANUARY, 1, 00, 00),
                                       new GregorianCalendar(2000, Calendar.JANUARY, 1, 02, 00),
                                       "party", "fun");
        } catch (IllegalValueException e) {
            fail("Error in EntryBuilderTest.buildEvent() sample data");
        }
        assertTrue(entry instanceof Event);
        Entry entry2 = EntryBuilder.build(entry);
        assertTrue(entry2 instanceof Event);
        assertTrue(entry.equals(entry2));
    }

```
###### \java\seedu\multitasky\model\util\EntryBuilderTest.java
``` java
    @Test
    public void buildDeadline() {
        Entry[] entries = new Entry[2];
        try {
            entries[0] = EntryBuilder.build("Deadline1",
                                            null,
                                            new GregorianCalendar(2005, Calendar.MAY, 5, 17, 00),
                                            "tag1", "tag2");
            entries[1] = EntryBuilder.build("Deadline2",
                                            new GregorianCalendar(2005, Calendar.MAY, 5, 17, 00),
                                            "tag1", "tag2");
        } catch (IllegalValueException e) {
            fail("Error in EntryBuilderTest.buildDeadline() sample data");
        }
        assertTrue(entries[0] instanceof Deadline);
        assertTrue(entries[1] instanceof Deadline);
        Entry entry = EntryBuilder.build(entries[0]);
        assertTrue(entry instanceof Deadline);
        assertTrue(entry.equals(entries[0]));
    }

```
###### \java\seedu\multitasky\model\util\EntryBuilderTest.java
``` java
    @Test
    public void buildFloatingTask() {
        Entry entry = null;
        try {
            entry = EntryBuilder.build("Float1",
                                       "tag1", "tag2");
        } catch (IllegalValueException e) {
            fail("Error in EntryBuilderTest.buildFloatingTask() sample data");
        }
        assertTrue(entry instanceof FloatingTask);
        Entry entry2 = EntryBuilder.build(entry);
        assertTrue(entry instanceof FloatingTask);
        assertTrue(entry.equals(entry2));
    }
}
```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
/**
 * A utility class for commands, to get the correct command phrase for testing.
 */
public class CommandUtil {

    /**
     * Returns an add command string for adding an event.
     */
    public static String getAddEventCommand(Entry entry) {
        return AddCommand.COMMAND_WORD + " " + getEventDetails(entry);
    }

    /**
     * Returns an add command string for adding a deadline.
     */
    public static String getAddDeadlineCommand(Entry entry) {
        return AddCommand.COMMAND_WORD + " " + getDeadlineDetails(entry);
    }

    /**
     * Returns an add command string for adding a floating task.
     */
    public static String getAddFloatingTaskCommand(Entry entry) {
        return AddCommand.COMMAND_WORD + " " + getFloatingTaskDetails(entry);
    }

    /**
     * Returns a delete command string for deleting an event by index.
     */
    public static String getDeleteEventByIndexCommand(Index index) {
        return DeleteCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_EVENT + " " + index.getOneBased();
    }

    /**
     * Returns a delete command string for deleting a deadline by index.
     */
    public static String getDeleteDeadlineByIndexCommand(Index index) {
        return DeleteCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_DEADLINE + " " + index.getOneBased();
    }

    /**
     * Returns a delete command string for deleting a floating task by index.
     */
    public static String getDeleteFloatingTaskByIndexCommand(Index index) {
        return DeleteCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_FLOATINGTASK + " " + index.getOneBased();
    }

    /**
     * Returns an edit command string for editing an event by index.
     */
    public static String getEditEventByIndexCommand(Index index, Entry editedEntry) {
        return EditCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_EVENT + " " + index.getOneBased() + " "
               + CliSyntax.PREFIX_NAME + " " + getEventDetails(editedEntry);
    }

    /**
     * Returns an edit command string for editing a deadline by index.
     */
    public static String getEditDeadlineByIndexCommand(Index index, Entry editedEntry) {
        return EditCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_DEADLINE + " " + index.getOneBased() + " "
               + CliSyntax.PREFIX_NAME + " " + getDeadlineDetails(editedEntry);
    }

    /**
     * Returns an edit command string for editing a floating task by index.
     */
    public static String getEditFloatingTaskByIndexCommand(Index index, Entry editedEntry) {
        return EditCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_FLOATINGTASK + " " + index.getOneBased() + " "
               + CliSyntax.PREFIX_NAME + " " + getFloatingTaskDetails(editedEntry);
    }

    /**
     * Returns an edit command string for editing an event by keyword.
     */
    public static String getEditEventByKeywordCommand(String keywords, Entry editedEntry) {
        return EditCommand.COMMAND_WORD + " " + keywords + " "
               + CliSyntax.PREFIX_NAME + " " + getEventDetails(editedEntry);
    }

    /**
     * Returns an edit command string for editing a deadline by keyword.
     */
    public static String getEditDeadlineByKeywordCommand(String keywords, Entry editedEntry) {
        return EditCommand.COMMAND_WORD + " " + keywords + " "
               + CliSyntax.PREFIX_NAME + " " + getDeadlineDetails(editedEntry);
    }

    /**
     * Returns an edit command string for editing a deadline by keyword.
     */
    public static String getEditFloatingTaskByKeywordCommand(String keywords, Entry editedEntry) {
        return EditCommand.COMMAND_WORD + " " + keywords + " "
               + CliSyntax.PREFIX_NAME + " " + getFloatingTaskDetails(editedEntry);
    }

    /**
     * Returns the part of command string for the given {@code entry}'s details.
     */
    public static String getEventDetails(Entry entry) {
        assert entry instanceof Event;
        StringBuilder builder = new StringBuilder();
        builder.append(entry.getName().toString()).append(" ")
               .append(CliSyntax.PREFIX_FROM).append(" ")
               .append(getDateDetailsAsInputString(entry.getStartDateAndTime())).append(" ")
               .append(CliSyntax.PREFIX_TO).append(" ")
               .append(getDateDetailsAsInputString(entry.getEndDateAndTime())).append(" ");
        builder.append(CliSyntax.PREFIX_TAG).append(" ");
        entry.getTags().stream().forEach(s -> builder.append(s.tagName).append(" "));
        return builder.toString();
    }

    /**
     * Returns the part of command string for the given {@code entry}'s details.
     */
    public static String getDeadlineDetails(Entry entry) {
        assert entry instanceof Deadline;
        StringBuilder builder = new StringBuilder();
        builder.append(entry.getName().toString()).append(" ")
               .append(CliSyntax.PREFIX_BY).append(" ")
               .append(getDateDetailsAsInputString(entry.getEndDateAndTime())).append(" ");
        builder.append(CliSyntax.PREFIX_TAG).append(" ");
        entry.getTags().stream().forEach(s -> builder.append(s.tagName).append(" "));
        return builder.toString();
    }

    /**
     * Returns the part of command string for the given {@code entry}'s details.
     */
    public static String getFloatingTaskDetails(Entry entry) {
        assert entry instanceof FloatingTask;
        StringBuilder builder = new StringBuilder();
        builder.append(entry.getName().toString()).append(" ");
        builder.append(CliSyntax.PREFIX_TAG).append(" ");
        entry.getTags().stream().forEach(s -> builder.append(s.tagName).append(" "));
        return builder.toString();
    }

    /**
     * Returns a string version of the calendar date that is ready for use in input
     */
    public static String getDateDetailsAsInputString(Calendar calendar) {
        assert calendar != null;
        StringBuilder builder = new StringBuilder();
        // Currently prettyTime parses date strings in MM/DD/YY format
        builder.append(calendar.get(Calendar.MONTH) + 1).append("/") // +1 due to MONTH being 0-based (JAN = 0)
               .append(calendar.get(Calendar.DAY_OF_MONTH)).append("/")
               .append(calendar.get(Calendar.YEAR)).append(" ");
        if (calendar.get(Calendar.HOUR_OF_DAY) < 10) {
            builder.append("0").append(calendar.get(Calendar.HOUR_OF_DAY)).append(":");
        } else {
            builder.append(calendar.get(Calendar.HOUR_OF_DAY)).append(":");
        }
        if (calendar.get(Calendar.MINUTE) < 10) {
            builder.append("0").append(calendar.get(Calendar.MINUTE));
        } else {
            builder.append(calendar.get(Calendar.MINUTE));
        }
        return builder.toString();
    }

}
```
###### \java\seedu\multitasky\testutil\SampleEntries.java
``` java
    // Events
    public static final Entry DINNER, CAT, MOVIE, OPENING;
    // Deadlines
    public static final Entry TAX, PAPER, SUBMISSION, UPGRADE;
    // Floating tasks
    public static final Entry COOK, PROGRAMMING, HIRE, SPECTACLES, CLEAN, SELL;

    static {
        try {
            // Events
            DINNER = EntryBuilder.build("Dinner with family",
                                        new GregorianCalendar(2017, Calendar.DECEMBER, 25, 19, 00),
                                        new GregorianCalendar(2017, Calendar.DECEMBER, 25, 21, 00),
                                        "cook");
            CAT = EntryBuilder.build("Feed the cat",
                                     new GregorianCalendar(2017, Calendar.JULY, 12, 19, 00),
                                     new GregorianCalendar(2017, Calendar.JULY, 12, 21, 00),
                                     "pet");
            MOVIE = EntryBuilder.build("Watch Spiderman",
                                       new GregorianCalendar(2017, Calendar.JULY, 15, 15, 00),
                                       new GregorianCalendar(2017, Calendar.JULY, 15, 17, 30),
                                       "marvel", "comics");
            OPENING = EntryBuilder.build("Attend exhibition opening",
                                         new GregorianCalendar(2017, Calendar.OCTOBER, 7, 18, 00),
                                         new GregorianCalendar(2017, Calendar.OCTOBER, 7, 21, 00),
                                         "tuxedo", "suit");

            // Deadlines
            TAX = EntryBuilder.build("Submit tax forms",
                                     new GregorianCalendar(2017, Calendar.JULY, 1, 00, 00),
                                     "money", "pay");
            PAPER = EntryBuilder.build("CS2103 finals",
                                       new GregorianCalendar(2017, Calendar.JULY, 28, 10, 0),
                                       "school", "exam", "study");
            SUBMISSION = EntryBuilder.build("Submit assignment",
                                            new GregorianCalendar(2017, Calendar.JULY, 12, 16, 00),
                                            "school");
            UPGRADE = EntryBuilder.build("Upgrade computer",
                                         new GregorianCalendar(2017, Calendar.DECEMBER, 1, 00, 00),
                                         "personal", "project");

            // Floating tasks
            COOK = EntryBuilder.build("Learn to cook",
                                      "goals");
            PROGRAMMING = EntryBuilder.build("Learn programming",
                                             "lessons", "computer");
            HIRE = EntryBuilder.build("Hire an assistant",
                                      "help");
            SPECTACLES = EntryBuilder.build("Make new spectacles",
                                            "health", "eyesight");
            CLEAN = EntryBuilder.build("Clean up room",
                                       "never", "hopefully");
            SELL = EntryBuilder.build("Sell old things",
                                      "sale", "clutter");

        } catch (Exception e) {
            throw new AssertionError("Sample data cannot be invalid", e);
        }
    }

    public static Entry[] getSampleEntries() {
        return new Entry[] {
            DINNER, TAX, PAPER, COOK, PROGRAMMING
        };
    }

    public static Entry[] getSampleEvents() {
        return new Entry[] { DINNER };
    }

    public static Entry[] getSampleDeadlines() {
        return new Entry[] { TAX, PAPER };
    }

    public static Entry[] getSampleFloatingTasks() {
        return new Entry[] { COOK, PROGRAMMING };
    }
```
