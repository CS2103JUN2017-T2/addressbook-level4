# A0126623L
###### \java\guitests\AddCommandTest.java
``` java
    @Test
    public void add_overlappingEventToExistingList_successWithAppropriateAlert() {
        Entry overlappingEventToAdd = SampleEntries.createOverlappingEvent(SampleEntries.DINNER);
        commandBox.runCommand(CommandUtil.getAddEventCommand(overlappingEventToAdd));
        assertEquals(String.format(AddCommand.MESSAGE_SUCCESS_WITH_OVERLAP_ALERT,
                                   overlappingEventToAdd.getName().toString()),
                     resultDisplay.getText());
    }

```
###### \java\guitests\AddCommandTest.java
``` java
    @Test
    public void add_overlappingAndOverdueEventToExistingList_successWithAppropriateAlert()
            throws IllegalValueException {
        Entry firstOverdueEvent = SampleEntries.createOverdueEvent();
        Entry secondOverdueEventThatOverlaps = SampleEntries.createOverlappingEvent(firstOverdueEvent);
        commandBox.runCommand(CommandUtil.getAddEventCommand(firstOverdueEvent));
        commandBox.runCommand(CommandUtil.getAddEventCommand(secondOverdueEventThatOverlaps));
        assertEquals(String.format(AddCommand.MESSAGE_SUCCESS_WITH_OVERLAP_AND_OVERDUE_ALERT,
                                   secondOverdueEventThatOverlaps.getName().toString()),
                     resultDisplay.getText());
    }

```
###### \java\guitests\AddCommandTest.java
``` java
    @Test
    public void add_overdueDeadlineToExistingList_successWithAppropriateAlert() throws IllegalValueException {
        Entry overdueDeadline = SampleEntries.createOverdueDeadline();
        commandBox.runCommand(CommandUtil.getAddDeadlineCommand(overdueDeadline));
        assertEquals(String.format(AddCommand.MESSAGE_SUCCESS_WITH_OVERDUE_ALERT,
                                   overdueDeadline.getName().toString()),
                     resultDisplay.getText());
    }

```
###### \java\guitests\ClearCommandTest.java
``` java
    @Test
    public void clearActive_emptyList_success() {
        assertClearActiveCommandSuccess();
        assertClearActiveCommandSuccess();
    }
```
###### \java\guitests\ClearCommandTest.java
``` java
    @Test
    public void clearArchive_emptyList_success() {
        assertClearArchiveCommandSuccess();
        assertClearArchiveCommandSuccess();
    }
```
###### \java\guitests\ClearCommandTest.java
``` java
    @Test
    public void clearBin_emptyList_success() {
        assertClearBinCommandSuccess();
        assertClearBinCommandSuccess();
    }
```
###### \java\guitests\ClearCommandTest.java
``` java
    @Test
    public void clear_addEventAfterClearActive_success() {
        assertClearActiveCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddEventCommand(SampleEntries.CAT));
        commandBox.runCommand(CommandUtil.getListCommand());
        assertTrue(eventListPanel.isListMatching(SampleEntries.CAT));
    }
```
###### \java\guitests\ClearCommandTest.java
``` java
    @Test
    public void clear_addDeadlineAfterClearActive_success() {
        assertClearActiveCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddDeadlineCommand(SampleEntries.SUBMISSION));
        commandBox.runCommand(CommandUtil.getListCommand());
        assertTrue(deadlineListPanel.isListMatching(SampleEntries.SUBMISSION));
    }
```
###### \java\guitests\ClearCommandTest.java
``` java
    @Test
    public void clear_addFloatingTaskAfterClearActive_success() {
        assertClearActiveCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddFloatingTaskCommand(SampleEntries.CLEAN));
        commandBox.runCommand(CommandUtil.getListCommand());
        assertTrue(floatingTaskListPanel.isListMatching(SampleEntries.CLEAN));
    }
```
###### \java\guitests\ClearCommandTest.java
``` java
    @Test
    public void clear_completeEventAfterClearArchive_success() {
        assertClearArchiveCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddEventCommand(SampleEntries.CAT));
        commandBox.runCommand(CommandUtil.getCompleteByFullNameCommand(SampleEntries.CAT));
        commandBox.runCommand(CommandUtil.getListArchiveCommand());
        assertTrue(eventListPanel.isListMatching(SampleEntries.CAT));
    }
```
###### \java\guitests\ClearCommandTest.java
``` java
    @Test
    public void clear_completeDeadlineAfterClearArchive_success() {
        assertClearArchiveCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddDeadlineCommand(SampleEntries.SUBMISSION));
        commandBox.runCommand(CommandUtil.getCompleteByFullNameCommand(SampleEntries.SUBMISSION));
        commandBox.runCommand(CommandUtil.getListArchiveCommand());
        assertTrue(deadlineListPanel.isListMatching(SampleEntries.SUBMISSION));
    }
```
###### \java\guitests\ClearCommandTest.java
``` java
    @Test
    public void clear_completeFloatingTaskAfterClearArchive_success() {
        assertClearArchiveCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddFloatingTaskCommand(SampleEntries.CLEAN));
        commandBox.runCommand(CommandUtil.getCompleteByFullNameCommand(SampleEntries.CLEAN));
        commandBox.runCommand(CommandUtil.getListArchiveCommand());
        assertTrue(floatingTaskListPanel.isListMatching(SampleEntries.CLEAN));
    }
```
###### \java\guitests\ClearCommandTest.java
``` java
    @Test
    public void clear_completeEventAfterClearBin_success() {
        assertClearBinCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddEventCommand(SampleEntries.CAT));
        commandBox.runCommand(CommandUtil.getDeleteByFullNameCommand(SampleEntries.CAT));
        commandBox.runCommand(CommandUtil.getListBinCommand());
        assertTrue(eventListPanel.isListMatching(SampleEntries.CAT));
    }
```
###### \java\guitests\ClearCommandTest.java
``` java
    @Test
    public void clear_completeDeadlineAfterClearBin_success() {
        assertClearBinCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddDeadlineCommand(SampleEntries.SUBMISSION));
        commandBox.runCommand(CommandUtil.getDeleteByFullNameCommand(SampleEntries.SUBMISSION));
        commandBox.runCommand(CommandUtil.getListBinCommand());
        assertTrue(deadlineListPanel.isListMatching(SampleEntries.SUBMISSION));
    }
```
###### \java\guitests\ClearCommandTest.java
``` java
    @Test
    public void clear_completeFloatingTaskAfterClearBin_success() {
        assertClearBinCommandSuccess();
        commandBox.runCommand(CommandUtil.getAddFloatingTaskCommand(SampleEntries.CLEAN));
        commandBox.runCommand(CommandUtil.getDeleteByFullNameCommand(SampleEntries.CLEAN));
        commandBox.runCommand(CommandUtil.getListBinCommand());
        assertTrue(floatingTaskListPanel.isListMatching(SampleEntries.CLEAN));
    }
```
###### \java\guitests\ClearCommandTest.java
``` java
    /**
     * Executes {@code list archive}, followed by {@code clear archive}
     */
    private void assertClearArchiveCommandSuccess() {
        commandBox.runCommand(CommandUtil.getListArchiveCommand());
        commandBox.runCommand(CommandUtil.getClearArchiveCommand());
        assertCurrentlyViewedPanelCleared();
        assertResultMessage(ClearCommand.MESSAGE_ARCHIVE_SUCCESS);
    }
```
###### \java\guitests\ClearCommandTest.java
``` java
    /**
     * Executes {@code list bin}, followed by {@code clear bin}
     */
    private void assertClearBinCommandSuccess() {
        commandBox.runCommand(CommandUtil.getListBinCommand());
        commandBox.runCommand(CommandUtil.getClearBinCommand());
        assertCurrentlyViewedPanelCleared();
        assertResultMessage(ClearCommand.MESSAGE_BIN_SUCCESS);
    }
```
###### \java\guitests\ListCommandTest.java
``` java
    @Test
    public void list_archive_success() {
        commandBox.runCommand(CommandUtil.getListArchiveCommand());
        assertTrue(eventListPanel.isListMatching(SampleEntries.getSampleArchivedEvents()));
        assertTrue(deadlineListPanel.isListMatching(SampleEntries.getSampleArchivedDeadlines()));
        assertTrue(floatingTaskListPanel.isListMatching(SampleEntries.getSampleArchivedFloatingTasks()));
    }

    @Test
    public void list_bin_success() {
        commandBox.runCommand(CommandUtil.getListBinCommand());
        assertTrue(eventListPanel.isListMatching(SampleEntries.getSampleDeletedEvents()));
        assertTrue(deadlineListPanel.isListMatching(SampleEntries.getSampleDeletedDeadlines()));
        assertTrue(floatingTaskListPanel.isListMatching(SampleEntries.getSampleDeletedFloatingTasks()));
    }

    @Test
    public void list_allEntries_success() {
        commandBox.runCommand(CommandUtil.getListAllCommand());
        assertTrue(eventListPanel.isListMatching(SampleEntries.getAllEvents()));
        assertTrue(deadlineListPanel.isListMatching(SampleEntries.getAllDeadlines()));
        assertTrue(floatingTaskListPanel.isListMatching(SampleEntries.getAllFloatingTasks()));
    }

```
###### \java\guitests\RestoreCommandArchiveTest.java
``` java
    @Before
    public void setUp() {
        commandBox.runCommand(CommandUtil.getListArchiveCommand());
    }
```
###### \java\guitests\RestoreCommandBinTest.java
``` java
public class RestoreCommandBinTest extends EntryBookGuiTest {

    @Before
    public void setUp() {
        commandBox.runCommand(CommandUtil.getListBinCommand());
    }

    /**********************
     * Restoring by Index *
     *********************/
    @Test
    public void restore_firstEventByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleDeletedEvents();
        Index targetIndex = SampleEntries.INDEX_FIRST_ENTRY;
        assertRestoreEventByIndexSuccess(targetIndex, currentList);
    }

    @Test
    public void restore_lastEventByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleDeletedEvents();
        Index targetIndex = Index.fromOneBased(currentList.length);
        assertRestoreEventByIndexSuccess(targetIndex, currentList);
    }

    @Test
    public void restore_invalidEventIndex_errorMessage() {
        Entry[] currentList = SampleEntries.getSampleDeletedEvents();
        Index targetIndex = Index.fromOneBased(currentList.length + 1);
        commandBox.runCommand(CommandUtil.getRestoreEventByIndexCommand(targetIndex));
        assertResultMessage(Messages.MESSAGE_INVALID_ENTRY_DISPLAYED_INDEX);
    }

    @Test
    public void restore_firstDeadlineByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleDeletedDeadlines();
        Index targetIndex = SampleEntries.INDEX_FIRST_ENTRY;
        assertRestoreDeadlineByIndexSuccess(targetIndex, currentList);
    }

    @Test
    public void restore_lastDeadlineByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleDeletedDeadlines();
        Index targetIndex = Index.fromOneBased(currentList.length);
        assertRestoreDeadlineByIndexSuccess(targetIndex, currentList);
    }

    @Test
    public void restore_invalidDeadlineIndex_errorMessage() {
        Entry[] currentList = SampleEntries.getSampleDeletedDeadlines();
        Index targetIndex = Index.fromOneBased(currentList.length + 1);
        commandBox.runCommand(CommandUtil.getRestoreDeadlineByIndexCommand(targetIndex));
        assertResultMessage(Messages.MESSAGE_INVALID_ENTRY_DISPLAYED_INDEX);
    }

    @Test
    public void restore_firstFloatingTaskByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleDeletedFloatingTasks();
        Index targetIndex = SampleEntries.INDEX_FIRST_ENTRY;
        assertRestoreFloatingTaskByIndexSuccess(targetIndex, currentList);
    }

    @Test
    public void restore_lastFloatingTaskByIndex_success() {
        Entry[] currentList = SampleEntries.getSampleDeletedFloatingTasks();
        Index targetIndex = Index.fromOneBased(currentList.length);
        assertRestoreFloatingTaskByIndexSuccess(targetIndex, currentList);
    }

    @Test
    public void restore_invalidFloatingTaskIndex_errorMessage() {
        Entry[] currentList = SampleEntries.getSampleDeletedFloatingTasks();
        Index targetIndex = Index.fromOneBased(currentList.length + 1);
        commandBox.runCommand(CommandUtil.getRestoreFloatingTaskByIndexCommand(targetIndex));
        assertResultMessage(Messages.MESSAGE_INVALID_ENTRY_DISPLAYED_INDEX);
    }

    /************************
     * Restoring by Keyword *
     ************************/
    @Test
    public void restore_eventKeyword_success() {
        Entry[] currentList = SampleEntries.getSampleDeletedEvents();
        Entry entryToRestore = SampleEntries.GYM;
        commandBox.runCommand(RestoreCommand.COMMAND_WORD + " gym");
        assertEventRestoredNormally(entryToRestore, currentList);
    }

    @Test
    public void restore_deadlineKeyword_success() {
        Entry[] currentList = SampleEntries.getSampleDeletedDeadlines();
        Entry entryToRestore = SampleEntries.APPOINTMENT;
        commandBox.runCommand(RestoreCommand.COMMAND_WORD + " appointment");
        assertDeadlineRestored(entryToRestore, currentList);
    }

    @Test
    public void restore_floatingTaskKeyword_success() {
        Entry[] currentList = SampleEntries.getSampleDeletedFloatingTasks();
        Entry entryToRestore = SampleEntries.BAKE;
        commandBox.runCommand(RestoreCommand.COMMAND_WORD + " baking");
        assertFloatingTaskRestoredNormally(entryToRestore, currentList);
    }

```
###### \java\guitests\RestoreCommandBinTest.java
``` java
    /********************************
     * Restore Command's Exceptions *
     ********************************/

    @Test
    public void restoreByKeyword_duplicateFloatingTask_throwDuplicateEntryException() {
        Entry deletedEntryToRestore = SampleEntries.BAKE;
        Entry duplicatedActiveEntry = EntryBuilder.build(deletedEntryToRestore);
        commandBox.runCommand(CommandUtil.getAddFloatingTaskCommand(duplicatedActiveEntry));
        commandBox.runCommand(RestoreCommand.COMMAND_WORD + " baking");
        assertResultMessage(DuplicateEntryException.MESSAGE);
    }

    @Test
    public void restoreByKeyword_overdueDeadline_overdueEntryAlertDisplayed() {
        try {
            Entry overdueDeadline = SampleEntries.createOverdueDeadline();

            commandBox.runCommand(CommandUtil.getAddDeadlineCommand(overdueDeadline));
            commandBox.runCommand(CommandUtil.getDeleteByFullNameCommand(overdueDeadline));
            assertResultMessage(String.format(DeleteCommand.MESSAGE_SUCCESS, overdueDeadline));
            commandBox.runCommand(CommandUtil.getRestoreByFullNameCommand(overdueDeadline));
            assertResultMessage(String.format(RestoreCommand.MESSAGE_SUCCESS_WITH_OVERDUE_ALERT,
                                              overdueDeadline.getName()));
        } catch (IllegalValueException e) {
            fail("IllegalValueException should not be thrown here, or something is wrong.");
        }
    }

    @Test
    public void restoreByIndex_duplicateFloatingTask_throwDuplicateEntryException() {
        Entry deletedEntryToRestore = SampleEntries.BAKE;
        Entry duplicatedActiveEntry = EntryBuilder.build(deletedEntryToRestore);
        commandBox.runCommand(CommandUtil.getClearBinCommand());
        commandBox.runCommand(CommandUtil.getAddFloatingTaskCommand(duplicatedActiveEntry));
        commandBox.runCommand(CommandUtil.getDeleteByFullNameCommand(duplicatedActiveEntry));
        commandBox.runCommand(CommandUtil.getAddFloatingTaskCommand(duplicatedActiveEntry));
        commandBox.runCommand(RestoreCommand.COMMAND_WORD + " baking");
        assertResultMessage(DuplicateEntryException.MESSAGE);
    }

    @Test
    public void restoreByIndex_overdueDeadline_overdueEntryAlertDisplayed() {
        try {
            Entry overdueDeadline = SampleEntries.createOverdueDeadline();

            commandBox.runCommand(CommandUtil.getClearBinCommand());
            commandBox.runCommand(CommandUtil.getAddDeadlineCommand(overdueDeadline));
            commandBox.runCommand(CommandUtil.getDeleteByFullNameCommand(overdueDeadline));
            commandBox.runCommand(CommandUtil.getRestoreDeadlineByIndexCommand(Index.fromOneBased(1)));
            assertResultMessage(String.format(RestoreCommand.MESSAGE_SUCCESS_WITH_OVERDUE_ALERT,
                                              overdueDeadline.getName()));
        } catch (IllegalValueException e) {
            fail("IllegalValueException should not be thrown here, or something is wrong.");
        }
    }

    @Test
    public void restoreByKeyword_overlappingEvent_successWithAppropriateAlert() {
        Entry overlappingEntryToRestore = SampleEntries.GYM;
        Entry overlappingEventInActiveList = SampleEntries.createOverlappingEvent(overlappingEntryToRestore);
        commandBox.runCommand(CommandUtil.getAddEventCommand(overlappingEventInActiveList));
        commandBox.runCommand(CommandUtil.getRestoreByFullNameCommand(overlappingEntryToRestore));
        assertResultMessage(String.format(RestoreCommand.MESSAGE_SUCCESS_WITH_OVERLAP_ALERT,
                                          overlappingEntryToRestore.getName().toString()));
    }

    @Test
    public void restoreByIndex_overlappingEvent_successWithAppropriateAlert() {
        // Set up deleted entry that will result in overlap alert when restored
        commandBox.runCommand(CommandUtil.getClearBinCommand());
        Entry overlappingEntryToRestore = SampleEntries.GYM;
        commandBox.runCommand(CommandUtil.getAddEventCommand(overlappingEntryToRestore));
        commandBox.runCommand(CommandUtil.getDeleteByFullNameCommand(overlappingEntryToRestore));

        // Create entry in active list that will overlap with overlappingEntryToRestore
        Entry overlappingEventInActiveList = SampleEntries.createOverlappingEvent(overlappingEntryToRestore);
        commandBox.runCommand(CommandUtil.getAddEventCommand(overlappingEventInActiveList));

        commandBox.runCommand(CommandUtil.getRestoreEventByIndexCommand(Index.fromOneBased(1)));
        assertResultMessage(String.format(RestoreCommand.MESSAGE_SUCCESS_WITH_OVERLAP_ALERT,
                                          overlappingEntryToRestore.getName().toString()));
    }

    @Test
    public void restoreByKeyword_overlappingAndOverdueEvent_successWithAppropriateAlert()
            throws IllegalValueException {
        Entry overdueEvent = SampleEntries.createOverdueEvent();
        Entry overlappingAndOverdueEvent = SampleEntries.createOverlappingEvent(overdueEvent);

        commandBox.runCommand(CommandUtil.getAddEventCommand(overdueEvent));
        commandBox.runCommand(CommandUtil.getAddEventCommand(overlappingAndOverdueEvent));
        commandBox.runCommand(CommandUtil.getDeleteByFullNameCommand(overlappingAndOverdueEvent));
        commandBox.runCommand(CommandUtil.getRestoreByFullNameCommand(overlappingAndOverdueEvent));
        assertResultMessage(String.format(RestoreCommand.MESSAGE_SUCCESS_WITH_OVERLAP_AND_OVERDUE_ALERT,
                                          overlappingAndOverdueEvent.getName().toString()));
    }

    @Test
    public void restoreByIndex_overlappingAndOverdueEvent_successWithAppropriateAlert()
            throws IllegalValueException {
        Entry overdueEvent = SampleEntries.createOverdueEvent();
        Entry overlappingAndOverdueEvent = SampleEntries.createOverlappingEvent(overdueEvent);

        commandBox.runCommand(CommandUtil.getClearBinCommand());
        commandBox.runCommand(CommandUtil.getAddEventCommand(overdueEvent));
        commandBox.runCommand(CommandUtil.getAddEventCommand(overlappingAndOverdueEvent));
        commandBox.runCommand(CommandUtil.getDeleteByFullNameCommand(overlappingAndOverdueEvent));
        commandBox.runCommand(CommandUtil.getRestoreEventByIndexCommand(Index.fromOneBased(1)));
        assertResultMessage(String.format(RestoreCommand.MESSAGE_SUCCESS_WITH_OVERLAP_AND_OVERDUE_ALERT,
                                          overlappingAndOverdueEvent.getName().toString()));
    }

```
###### \java\seedu\multitasky\model\entry\DeadlineListTest.java
``` java
public class DeadlineListTest {

    private DeadlineList deadlineList1, deadlineList2, deadlineList3;
    private Deadline[] sampleDeadlineArray = DeadlineTest.getSampleDeadlineArray();

    /**
     * Copies the deadlines in the given deadlines collection into an Deadline List.
     *
     * @param deadlines cannot be null
     * @return DeadlineList
     * @throws DuplicateEntryException if duplicate deadlines are given
     */
    public static DeadlineList getDeadlineList(Deadline... deadlines) throws DuplicateEntryException {
        DeadlineList deadlineList = new DeadlineList();
        for (Deadline deadline : deadlines) {
            Objects.requireNonNull(deadline);
            deadlineList.add(EntryBuilder.build(deadline));
        }
        return deadlineList;
    }

    /**
     * Copies all the elements of a given deadline list into a new deadline list
     *
     * @param deadlineListToCopy
     * @return copiedDeadlineList
     */
    public static DeadlineList copyDeadlineList(DeadlineList deadlineListToCopy) {
        DeadlineList copiedDeadlineList = new DeadlineList();
        try {
            for (Entry e : deadlineListToCopy) {
                Objects.requireNonNull(e);
                assert (e instanceof Deadline) : "DeadlineList copy error: e is not an Deadline";
                copiedDeadlineList.add(EntryBuilder.build(e));
            }
            return copiedDeadlineList;
        } catch (DuplicateEntryException e) {
            fail("List with duplicated entries was given to DeadlineListTest.copyDeadlineList().");
            return null;
        }
    }

    /**
     * Generates an array of 3 DeadlineList samples.
     * The first two deadlines are meaningfully equivalent, the third one is unique.
     */
    public static DeadlineList[] getListOfSampleDeadlineLists() {

        DeadlineList deadlineList1, deadlineList2, deadlineList3;

        Deadline[] sampleDeadlineArray = DeadlineTest.getSampleDeadlineArray();
        try {
            deadlineList1 = DeadlineListTest.getDeadlineList(sampleDeadlineArray[0], sampleDeadlineArray[2]);
            deadlineList2 = DeadlineListTest.getDeadlineList(sampleDeadlineArray[0], sampleDeadlineArray[2]);
            deadlineList3 = DeadlineListTest.getDeadlineList(sampleDeadlineArray[0], sampleDeadlineArray[3]);

            return new DeadlineList[] { deadlineList1, deadlineList2, deadlineList3 };
        } catch (DuplicateEntryException e) {
            fail("Error in DeadlineListTest.getSampleDeadlineListArrayData() due to duplication.");
            return null;
        }
    }

    @Before
    public void setUp() {
        DeadlineList[] listOfDeadlineList = DeadlineListTest.getListOfSampleDeadlineLists();
        deadlineList1 = listOfDeadlineList[0];
        deadlineList2 = listOfDeadlineList[1];
        deadlineList3 = listOfDeadlineList[2];
    }

    /**
     * Tests if sample entries used in this test class are considered equal when necessary.
     */
    @Test
    public void equals_millisecondsDifference_consideredEqual() {
        /*
         * Because of the way they are instantiated, the start time of
         * the deadlines of sampleDeadlineArray's and deadlineList1's first deadline
         * element are different by milliseconds. This should not be
         * considered different as the constructor reset milliseconds to
         * zero.
         */
        assertTrue(sampleDeadlineArray[0].equals(deadlineList1.asObservableList().get(0)));
    }

    /**
     * Dependent on the correct functioning of the contains method.
     */
    @Test
    public void add_sampleDeadline_success() {
        DeadlineList deadlineListUnderTest = new DeadlineList();

        try {
            deadlineListUnderTest.add(EntryBuilder.build(sampleDeadlineArray[0]));
            deadlineListUnderTest.add(sampleDeadlineArray[2]);

            assertTrue(deadlineListUnderTest.contains(sampleDeadlineArray[0]));
            assertTrue(deadlineListUnderTest.contains(sampleDeadlineArray[2]));
            assertFalse(deadlineListUnderTest.contains(sampleDeadlineArray[3]));

        } catch (DuplicateEntryException e) {
            e.printStackTrace();
        }
    }

    @Test(expected = DuplicateEntryException.class)
    public void add_duplicateDeadline_throwDuplicateEntryException() throws DuplicateEntryException {
        DeadlineList deadlineListUnderTest = DeadlineListTest.copyDeadlineList(deadlineList1);
        Deadline copiedDeadline = (Deadline) EntryBuilder.build(deadlineListUnderTest.asObservableList()
                                                                                     .get(0));
        deadlineListUnderTest.add(copiedDeadline);
    }

    @Test
    public void equals_variousSampleDeadlines_success() {
        DeadlineList dummyDeadlineList = DeadlineListTest.copyDeadlineList(deadlineList2);
        assertTrue(deadlineList1.equals(deadlineList2));
        assertTrue(deadlineList1.equals(dummyDeadlineList));

        dummyDeadlineList.asObservableList().get(0).setState(Entry.State.ARCHIVED);
        assertFalse(deadlineList1.equals(dummyDeadlineList));

        assertFalse(deadlineList1.equals(deadlineList3));
    }

    @Test
    public void remove_removeSampleDeadline_success() throws EntryNotFoundException {
        DeadlineList deadlineListToTest = DeadlineListTest.copyDeadlineList(deadlineList1);

        deadlineListToTest.remove(sampleDeadlineArray[0]);
        assertTrue(!deadlineListToTest.contains(sampleDeadlineArray[0]));
        assertTrue(deadlineListToTest.asObservableList().get(0).equals(sampleDeadlineArray[2]));
    }

    @Test(expected = EntryNotFoundException.class)
    public void remove_nonExistentEntry_returnEntryNotFoundException() throws EntryNotFoundException {
        DeadlineList deadlineListUnderTest = DeadlineListTest.copyDeadlineList(deadlineList1);

        deadlineListUnderTest.remove(sampleDeadlineArray[3]);
    }

    @Test
    public void update_updateSampleDeadline_success() throws EntryNotFoundException {
        DeadlineList deadlineListToTest = DeadlineListTest.copyDeadlineList(deadlineList1);
        assertTrue(deadlineListToTest.equals(deadlineList1));
        assertFalse(deadlineListToTest.contains(sampleDeadlineArray[3]));
        try {
            deadlineListToTest.updateEntry(sampleDeadlineArray[0], sampleDeadlineArray[3]);

            assertFalse(deadlineListToTest.equals(deadlineList1));
            assertTrue(deadlineListToTest.contains(sampleDeadlineArray[3]));

        } catch (DuplicateEntryException e) {
            fail("DeadlineListTest.updateEntryTest() failed due to duplicate entry.");
        }
    }

    @Test
    public void setEntries_newDeadlineList_equalsMethodReturnsFalse() {
        DeadlineList deadlineListToTest = DeadlineListTest.copyDeadlineList(deadlineList3);
        assertTrue(deadlineListToTest.equals(deadlineList3));

        assertTrue(!deadlineListToTest.equals(deadlineList1));
        deadlineListToTest.setEntries(deadlineList1);
        assertTrue(deadlineListToTest.equals(deadlineList1));
    }

}
```
###### \java\seedu\multitasky\model\entry\DeadlineTest.java
``` java
public class DeadlineTest {

    private Deadline deadline1, deadline2, deadline3, deadline4, deadline5;

    /**
     * Gets an array of 5 sample deadlines.
     * The first two deadlines are meaningfully equivalent, the remaining are unique.
     * @return Deadline[] of 5 sample deadlines.
     */
    public static Deadline[] getSampleDeadlineArray() {

        Calendar calendar1 = Calendar.getInstance();
        calendar1.set(2017, 6, 7, 18, 30); // 7th July 2017, 6:30pm
        Calendar calendar2 = Calendar.getInstance();
        calendar2.set(2017, 6, 8, 18, 30); // 8th July 2017, 6:30pm
        Calendar calendar3 = Calendar.getInstance();
        calendar3.set(2017, 6, 9, 18, 30); // 9th July 2017, 6:30pm

        try {
            return new Deadline[] {
                new Deadline(new Name("SampleName1"), calendar1, TagSetBuilder.getTagSet("tag1")),
                new Deadline(new Name("SampleName1"), calendar1, TagSetBuilder.getTagSet("tag1")),
                new Deadline(new Name("SampleName2"), calendar1, TagSetBuilder.getTagSet("tag1")),
                new Deadline(new Name("SampleName1"), calendar2, TagSetBuilder.getTagSet("tag1")),
                new Deadline(new Name("SampleName3"), calendar1, TagSetBuilder.getTagSet("tag2"))
            };
        } catch (Exception e) {
            fail("Deadline array initialisation failed.");
            return null;
        }
    }

    /**
     * Returns a list of Deadlines of 5 sample elements.
     */
    public static List<Deadline> getSampleDeadlineList() {
        return Arrays.asList(DeadlineTest.getSampleDeadlineArray());
    }

    @Before
    public void setUp() {
        Deadline[] sampleDeadlineArrayData = getSampleDeadlineArray();

        deadline1 = sampleDeadlineArrayData[0];
        deadline2 = sampleDeadlineArrayData[1];
        deadline3 = sampleDeadlineArrayData[2];
        deadline4 = sampleDeadlineArrayData[3];
        deadline5 = sampleDeadlineArrayData[4];
    }

    @Test
    public void getName_actualAndExpected_success() {
        assertEquals("error at getName()", "SampleName1", deadline1.getName().fullName);
    }

    @Test
    public void getTags_actualAndExpected_success() {
        // Same tags
        assertTrue(deadline1.getTags().equals(deadline2.getTags()));

        // Different tags
        assertFalse(deadline1.getTags().equals(deadline5.getTags()));
    }

    @Test
    public void resetData_sampleDeadlineToReset_success() {
        try {
            Entry tempDeadline = EntryBuilder.build(deadline1);
            assert (tempDeadline instanceof Deadline) : "Error in DeadlineTest.resetDataTest().";

            Deadline tester999 = (Deadline) tempDeadline;
            assertFalse(tester999.equals(deadline3));
            tester999.resetData(deadline3);
            assertTrue(tester999.equals(deadline3));

        } catch (Exception e) {
            fail("DeadlineTest.resetDataTest() failed.");
        }
    }

    @Test
    public void getStartAndEndTime_invokeGetterMethods_nulls() {
        assertNull(deadline1.getStartDateAndTime());
        assertNull(deadline1.getStartDateAndTimeString());
    }

    @Test
    public void toString_expectedString_success() {
        assertEquals("Deadline formatting is wrong",
                     "SampleName1, Deadline: Jul 7, 2017 6:30 PM, Tags: [tag1]",
                     deadline1.toString());
    }

    @Test
    public void equals_variousCases_success() {
        // Equal
        assertTrue(deadline1.equals(deadline2));

        // Not equal
        assertFalse(deadline1.equals(deadline3));
        assertFalse(deadline1.equals(deadline4));
        assertFalse(deadline1.equals(deadline5));
    }

    @Test
    public void isOverdue_variousCases_success() {
        final int offsetAmount = 10;
        try {
            // Overdue deadline
            Entry overdueDeadline = EntryBuilder.build(new Name("deadlineSample"),
                                                       Calendar.getInstance(),
                                                       "tag1");
            overdueDeadline.getEndDateAndTime().add(Calendar.YEAR, -offsetAmount);
            assertTrue(((Deadline) overdueDeadline).isOverdue());

            // Current deadline should be considered overdue
            Entry currentDeadline = EntryBuilder.build(new Name("deadlineSample"),
                                                       Calendar.getInstance(),
                                                       "tag1");
            assertTrue(((Deadline) currentDeadline).isOverdue());

            // Future deadline
            // Overdue deadline
            Entry futureDeadline = EntryBuilder.build(new Name("deadlineSample"),
                                                      Calendar.getInstance(),
                                                      "tag1");
            futureDeadline.getEndDateAndTime().add(Calendar.YEAR, offsetAmount + 1);
            assertFalse(((Deadline) futureDeadline).isOverdue());

        } catch (Exception e) {
            fail("Should not fail.");
        }

    }

}
```
###### \java\seedu\multitasky\model\entry\EntryTest.java
``` java
    @Test
    public void setState_invokeSetState_success() throws IllegalValueException {
        Entry eventUnderTest = EntryBuilder.build("dummyName");
        assertTrue(eventUnderTest.getState().toString().equals("ACTIVE"));

        eventUnderTest.setState(Entry.State.ARCHIVED);
        assertTrue(eventUnderTest.getState().toString().equals("ARCHIVED"));

        eventUnderTest.setState(Entry.State.DELETED);
        assertTrue(eventUnderTest.getState().toString().equals("DELETED"));
    }

}
```
###### \java\seedu\multitasky\model\entry\EventListTest.java
``` java
public class EventListTest {

    private EventList eventList1, eventList2, eventList3;
    private Event[] sampleEventArray = EventTest.getSampleEventArray();

    /**
     * Copies the events in the given events collection into an Event List.
     *
     * @param events cannot be null
     * @return EventList
     * @throws DuplicateEntryException if duplicate events are given
     */
    public static EventList getEventList(Event... events) throws DuplicateEntryException {
        EventList eventList = new EventList();
        for (Event event : events) {
            Objects.requireNonNull(event);
            eventList.add(EntryBuilder.build(event));
        }
        return eventList;
    }

    /**
     * Copies all the elements of a given event list into a new event list
     *
     * @param eventListToCopy
     * @return copiedEventList
     */
    public static EventList copyEventList(EventList eventListToCopy) {
        EventList copiedEventList = new EventList();
        try {
            for (Entry e : eventListToCopy) {
                Objects.requireNonNull(e);
                assert (e instanceof Event) : "EventList copy error: e is not an Event";
                copiedEventList.add(EntryBuilder.build(e));
            }
            return copiedEventList;
        } catch (DuplicateEntryException e) {
            fail("List with duplicated entries was given to EventListTest.copyEventList().");
            return null;
        }
    }

    /**
     * Generates an array of 3 EventList samples.
     * The first two EventList objects are meaningfully equivalent, the third one is unique.
     */
    public static EventList[] getListOfSampleEventLists() {

        EventList eventList1, eventList2, eventList3;

        Event[] sampleEventArray = EventTest.getSampleEventArray();
        try {
            eventList1 = EventListTest.getEventList(sampleEventArray[0], sampleEventArray[2]);
            eventList2 = EventListTest.getEventList(sampleEventArray[0], sampleEventArray[2]);
            eventList3 = EventListTest.getEventList(sampleEventArray[0], sampleEventArray[3]);

            return new EventList[] { eventList1, eventList2, eventList3 };
        } catch (DuplicateEntryException e) {
            fail("Error in EventListTest.getSampleEventListArrayData() due to duplication.");
            return null;
        }
    }

    @Before
    public void setUp() {
        EventList[] listOfEventList = EventListTest.getListOfSampleEventLists();
        eventList1 = listOfEventList[0];
        eventList2 = listOfEventList[1];
        eventList3 = listOfEventList[2];
    }

    /**
     * Tests if sample entries used in this test class are considered equal when necessary.
     */
    @Test
    public void equals_millisecondsDifference_consideredEqual() {
        /*
         * Because of the way they are instantiated, the start time of
         * the events of sampleEventArray's and eventList1's first event
         * element are different by milliseconds. This should not be
         * considered different as the constructor reset milliseconds to
         * zero.
         */
        assertTrue(sampleEventArray[0].equals(eventList1.asObservableList().get(0)));
    }

    /**
     * Dependent on the correct functioning of the contains method.
     */
    @Test
    public void add_sampleEvent_success() {
        EventList eventListUnderTest = new EventList();

        try {
            eventListUnderTest.add(EntryBuilder.build(sampleEventArray[0]));
            eventListUnderTest.add(sampleEventArray[2]);

            assertTrue(eventListUnderTest.contains(sampleEventArray[0]));
            assertTrue(eventListUnderTest.contains(sampleEventArray[2]));
            assertFalse(eventListUnderTest.contains(sampleEventArray[3]));

        } catch (DuplicateEntryException e) {
            e.printStackTrace();
        }
    }

    @Test(expected = DuplicateEntryException.class)
    public void add_duplicateEvent_throwDuplicateEntryException() throws DuplicateEntryException {
        EventList eventListUnderTest = EventListTest.copyEventList(eventList1);
        Event copiedEvent = (Event) EntryBuilder.build(eventListUnderTest.asObservableList().get(0));
        eventListUnderTest.add(copiedEvent);
    }

    @Test
    public void equals_variousSampleEvents_success() {
        EventList dummyEventList = EventListTest.copyEventList(eventList2);
        assertTrue(eventList1.equals(eventList2));
        assertTrue(eventList1.equals(dummyEventList));

        dummyEventList.asObservableList().get(0).setState(Entry.State.ARCHIVED);
        assertFalse(eventList1.equals(dummyEventList));

        assertFalse(eventList1.equals(eventList3));
    }

    @Test
    public void remove_removeSampleEvent_success() throws EntryNotFoundException {
        EventList eventListToTest = EventListTest.copyEventList(eventList1);

        eventListToTest.remove(sampleEventArray[0]);
        assertTrue(!eventListToTest.contains(sampleEventArray[0]));
        assertTrue(eventListToTest.asObservableList().get(0).equals(sampleEventArray[2]));
    }

    @Test(expected = Exception.class)
    public void remove_nonExistentEntry_returnEntryNotFoundException() throws EntryNotFoundException {
        EventList eventListUnderTest = EventListTest.copyEventList(eventList1);

        eventListUnderTest.remove(sampleEventArray[3]);
    }

    @Test
    public void update_updateSampleEvent_success() throws EntryNotFoundException {
        EventList eventListToTest = EventListTest.copyEventList(eventList1);
        assertTrue(eventListToTest.equals(eventList1));
        assertFalse(eventListToTest.contains(sampleEventArray[3]));
        try {
            eventListToTest.updateEntry(sampleEventArray[0], sampleEventArray[3]);

            assertFalse(eventListToTest.equals(eventList1));
            assertTrue(eventListToTest.contains(sampleEventArray[3]));

        } catch (DuplicateEntryException e) {
            fail("EventListTest.updateEntryTest() failed due to duplicate entry.");
        }
    }

    @Test
    public void setEntries_newEventList_equalsMethodReturnsFalse() {
        EventList eventListToTest = EventListTest.copyEventList(eventList3);
        assertTrue(eventListToTest.equals(eventList3));

        assertTrue(!eventListToTest.equals(eventList1));
        eventListToTest.setEntries(eventList1);
        assertTrue(eventListToTest.equals(eventList1));
    }

    @Test
    public void hasOverlapping_overlappingAndNonOverlappingSampleEvents_success() {
        int offsetAmount = 1000;

        Entry overlappingEventToAdd = this.sampleEventArray[0];
        assertTrue(eventList1.hasOverlappingEvent(overlappingEventToAdd));
        try {
            Entry nonOverlappingEvent = EntryBuilder.build(new Name("nonOverlappingEventName"),
                                                           Calendar.getInstance(),
                                                           Calendar.getInstance(),
                                                           "tag1");
            nonOverlappingEvent.getEndDateAndTime().add(Calendar.YEAR, offsetAmount + 1);
            nonOverlappingEvent.getStartDateAndTime().add(Calendar.YEAR, offsetAmount);
            assertFalse(eventList1.hasOverlappingEvent(nonOverlappingEvent));
        } catch (Exception e) {
            fail("Should not fail.");
        }
    }

    @Test
    public void hasOverlappingEventAfterUpdate_overlappingEventAfterUpdate_success() {
        Entry eventToManipulate = eventList1.asObservableList().get(0);
        eventToManipulate.setState(Entry.State.DELETED);
        assertTrue(eventList1.asObservableList().get(0).isDeleted());

        Entry activatedManipulatedEvent = EntryBuilder.build(eventToManipulate);
        activatedManipulatedEvent.setState(Entry.State.ACTIVE);

        assertFalse(activatedManipulatedEvent.equals(eventToManipulate));
        assertTrue(eventList1.hasOverlappingEventAfterUpdate(eventToManipulate, activatedManipulatedEvent));
    }

}
```
###### \java\seedu\multitasky\model\entry\EventTest.java
``` java
public class EventTest {

    private Event event1, event2, event3, event4, event5, event6;

    /**
     * Gets an array of 6 sample events.
     * The first two events are meaningfully equivalent, the remaining are unique.
     * @return Event[] of 6 sample events.
     */
    public static Event[] getSampleEventArray() {

        Calendar calendar1 = Calendar.getInstance();
        calendar1.set(2017, 6, 7, 18, 30); // 7th July 2017, 6:30pm
        Calendar calendar2 = Calendar.getInstance();
        calendar2.set(2017, 6, 8, 18, 30); // 8th July 2017, 6:30pm
        Calendar calendar3 = Calendar.getInstance();
        calendar3.set(2017, 6, 9, 18, 30); // 9th July 2017, 6:30pm

        try {
            return new Event[] {
                new Event(new Name("SampleName1"), calendar1, calendar2,
                          TagSetBuilder.getTagSet("tag1")),
                new Event(new Name("SampleName1"), calendar1, calendar2,
                          TagSetBuilder.getTagSet("tag1")),
                new Event(new Name("SampleName2"), calendar1, calendar2,
                          TagSetBuilder.getTagSet("tag1")),
                new Event(new Name("SampleName1"), calendar2, calendar3,
                          TagSetBuilder.getTagSet("tag1")),
                new Event(new Name("SampleName1"), calendar1, calendar3,
                          TagSetBuilder.getTagSet("tag1")),
                new Event(new Name("SampleName3"), calendar1, calendar2,
                          TagSetBuilder.getTagSet("tag2"))
            };
        } catch (Exception e) {
            fail("Event array initialisation failed.");
            return null;
        }
    }

    /**
     * method that returns list of Events of 6 sample elements.
     */
    public static List<Event> getSampleEventList() {
        return Arrays.asList(EventTest.getSampleEventArray());
    }

    @Before
    public void setUp() {
        Event[] sampleEventArrayData = getSampleEventArray();

        event1 = (Event) EntryBuilder.build(sampleEventArrayData[0]);
        event2 = (Event) EntryBuilder.build(sampleEventArrayData[1]);
        event3 = (Event) EntryBuilder.build(sampleEventArrayData[2]);
        event4 = (Event) EntryBuilder.build(sampleEventArrayData[3]);
        event5 = (Event) EntryBuilder.build(sampleEventArrayData[4]);
        event6 = (Event) EntryBuilder.build(sampleEventArrayData[5]);
    }

    @Test
    public void getName_actualAndExpected_success() {
        assertEquals("error at getName()", "SampleName1", event1.getName().fullName);
    }

    @Test
    public void getTags_actualAndExpected_success() {
        // Same tags
        assertTrue(event1.getTags().equals(event2.getTags()));

        // Different tags
        assertFalse(event1.getTags().equals(event6.getTags()));
    }

    @Test
    public void resetData_sampleEventToReset_success() {
        Event tester999 = (Event) EntryBuilder.build(event1);
        assertFalse(tester999.equals(event3));

        tester999.resetData(event3);
        assertTrue(tester999.equals(event3));
    }

    @Test
    public void toString_expectedString_success() {
        assertEquals("Event formatting is wrong",
                     "SampleName1, Start: Jul 7, 2017 6:30 PM, End: Jul 8, 2017 6:30 PM, Tags: [tag1]",
                     event1.toString());
    }

    @Test
    public void equals_variousCases_success() {
        Event dummyEvent = (Event) EntryBuilder.build(event2);

        // Equal
        assertTrue(event1.equals(event2));
        assertTrue(dummyEvent.equals(event1));

        dummyEvent.setState(Entry.State.ARCHIVED);

        // Not equal
        assertFalse(dummyEvent.equals(event1));
        assertFalse(event1.equals(event3));
        assertFalse(event1.equals(event4));
        assertFalse(event1.equals(event5));
        assertFalse(event1.equals(event6));

        dummyEvent.setState(Entry.State.ACTIVE);
        assertTrue(dummyEvent.equals(event1));

        // Test EventTest.getSampleEventArray()
        Event[] array1 = EventTest.getSampleEventArray();
        Event[] array2 = EventTest.getSampleEventArray();
        assertFalse(array1[0] == array2[0]);
        assertNotSame(array1[0], array2[0]);
        assertTrue(array1[0].equals(array2[0]));
    }

    @Test
    public void overlaps_variousCases_success() {
        final int offsetAmount = 2;

        // Make an event with start time overlapping with event1.
        Entry eventWithStartTimeOverlapped = EntryBuilder.build(event1);
        eventWithStartTimeOverlapped.getStartDateAndTime().add(Calendar.HOUR, offsetAmount);
        eventWithStartTimeOverlapped.getEndDateAndTime().add(Calendar.HOUR, offsetAmount);
        assertTrue(eventWithStartTimeOverlapped instanceof OverlapCapable);
        assertTrue(event1.overlapsWith((OverlapCapable) eventWithStartTimeOverlapped));

        // Make an event with start time overlapping with event1.
        Entry eventWithEndTimeOverlapped = EntryBuilder.build(event1);
        eventWithEndTimeOverlapped.getStartDateAndTime().add(Calendar.HOUR, -offsetAmount);
        eventWithEndTimeOverlapped.getEndDateAndTime().add(Calendar.HOUR, -offsetAmount);
        assertTrue(eventWithEndTimeOverlapped instanceof OverlapCapable);
        assertTrue(event1.overlapsWith((OverlapCapable) eventWithEndTimeOverlapped));

        // Make an event fully overlapped with event1.
        Entry eventFullyOverlapped = EntryBuilder.build(event1);
        assertTrue(eventFullyOverlapped instanceof OverlapCapable);
        assertTrue(event1.overlapsWith((OverlapCapable) eventFullyOverlapped));

        try {
            // Make an event that doesn't overlap with event1.
            Entry eventWithNoOverlap = EntryBuilder.build(new Name("noOverlapEvent"),
                                                          Calendar.getInstance(),
                                                          Calendar.getInstance(),
                                                          "tag1");
            eventWithNoOverlap.getStartDateAndTime().add(Calendar.YEAR, offsetAmount);
            eventWithNoOverlap.getEndDateAndTime().add(Calendar.YEAR, offsetAmount + 1);
            assertTrue(eventWithNoOverlap instanceof OverlapCapable);
            assertFalse(event1.overlapsWith((OverlapCapable) eventWithNoOverlap));
        } catch (Exception e) {
            fail("Should not fail.");
        }
    }

    @Test
    public void isOverdue_variousCases_success() {
        final int offsetAmount = 10;
        try {
            // Overdue event
            Entry overdueEvent = EntryBuilder.build(new Name("eventSample"),
                                                    Calendar.getInstance(),
                                                    Calendar.getInstance(),
                                                    "tag1");
            overdueEvent.getEndDateAndTime().add(Calendar.YEAR, -offsetAmount);
            overdueEvent.getStartDateAndTime().add(Calendar.YEAR, -offsetAmount - 1);
            assertTrue(((Event) overdueEvent).isOverdue());

            // Current event should be considered overdue
            Entry currentEvent = EntryBuilder.build(new Name("eventSample"),
                                                    Calendar.getInstance(),
                                                    Calendar.getInstance(),
                                                    "tag1");
            assertTrue(((Event) currentEvent).isOverdue());

            // Future event
            // Overdue event
            Entry futureEvent = EntryBuilder.build(new Name("eventSample"),
                                                   Calendar.getInstance(),
                                                   Calendar.getInstance(),
                                                   "tag1");
            futureEvent.getEndDateAndTime().add(Calendar.YEAR, offsetAmount + 1);
            futureEvent.getStartDateAndTime().add(Calendar.YEAR, offsetAmount);
            assertFalse(((Event) futureEvent).isOverdue());

        } catch (Exception e) {
            fail("Should not fail.");
        }

    }

}
```
###### \java\seedu\multitasky\model\entry\FloatingTaskListTest.java
``` java
public class FloatingTaskListTest {

    private FloatingTaskList floatingTaskList1, floatingTaskList2, floatingTaskList3;
    private FloatingTask[] sampleFloatingTaskArray = FloatingTaskTest.getSampleFloatingTaskArray();

    /**
     * Copies the floatingTasks in the given floatingTasks collection into an FloatingTask List.
     *
     * @param floatingTasks cannot be null
     * @return FloatingTaskList
     * @throws DuplicateEntryException if duplicate floatingTasks are given
     */
    public static FloatingTaskList getFloatingTaskList(FloatingTask... floatingTasks)
            throws DuplicateEntryException {
        FloatingTaskList floatingTaskList = new FloatingTaskList();
        for (FloatingTask floatingTask : floatingTasks) {
            Objects.requireNonNull(floatingTask);
            floatingTaskList.add(EntryBuilder.build(floatingTask));
        }
        return floatingTaskList;
    }

    /**
     * Copies all the elements of a given floatingTask list into a new floatingTask list
     *
     * @param floatingTaskListToCopy
     * @return copiedFloatingTaskList
     */
    public static FloatingTaskList copyFloatingTaskList(FloatingTaskList floatingTaskListToCopy) {
        FloatingTaskList copiedFloatingTaskList = new FloatingTaskList();
        try {
            for (Entry e : floatingTaskListToCopy) {
                Objects.requireNonNull(e);
                assert (e instanceof FloatingTask) : "FloatingTaskList copy error: e is not an FloatingTask";
                copiedFloatingTaskList.add(EntryBuilder.build(e));
            }
            return copiedFloatingTaskList;
        } catch (DuplicateEntryException e) {
            fail("List with duplicated entries was given to FloatingTaskListTest.copyFloatingTaskList().");
            return null;
        }
    }

    /**
     * Generates an array of 3 FloatingTaskList samples.
     * The first two floatingTasks are meaningfully equivalent, the third one is unique.
     */
    public static FloatingTaskList[] getListOfSampleFloatingTaskLists() {

        FloatingTaskList floatingTaskList1, floatingTaskList2, floatingTaskList3;

        FloatingTask[] sampleFloatingTaskArray = FloatingTaskTest.getSampleFloatingTaskArray();
        try {
            floatingTaskList1 = FloatingTaskListTest.getFloatingTaskList(sampleFloatingTaskArray[0],
                                                                         sampleFloatingTaskArray[2]);
            floatingTaskList2 = FloatingTaskListTest.getFloatingTaskList(sampleFloatingTaskArray[0],
                                                                         sampleFloatingTaskArray[2]);
            floatingTaskList3 = FloatingTaskListTest.getFloatingTaskList(sampleFloatingTaskArray[0],
                                                                         sampleFloatingTaskArray[3]);

            return new FloatingTaskList[] { floatingTaskList1, floatingTaskList2, floatingTaskList3 };
        } catch (DuplicateEntryException e) {
            fail("Error in FloatingTaskListTest.getSampleFloatingTaskListArrayData() due to duplication.");
            return null;
        }
    }

    @Before
    public void setUp() {
        FloatingTaskList[] listOfFloatingTaskList = FloatingTaskListTest.getListOfSampleFloatingTaskLists();
        floatingTaskList1 = listOfFloatingTaskList[0];
        floatingTaskList2 = listOfFloatingTaskList[1];
        floatingTaskList3 = listOfFloatingTaskList[2];
    }

    /**
     * Dependent on the correct functioning of the contains method.
     */
    @Test
    public void add_sampleFloatingTask_success() {
        FloatingTaskList floatingTaskListUnderTest = new FloatingTaskList();

        try {
            floatingTaskListUnderTest.add(EntryBuilder.build(sampleFloatingTaskArray[0]));
            floatingTaskListUnderTest.add(sampleFloatingTaskArray[2]);

            assertTrue(floatingTaskListUnderTest.contains(sampleFloatingTaskArray[0]));
            assertTrue(floatingTaskListUnderTest.contains(sampleFloatingTaskArray[2]));
            assertFalse(floatingTaskListUnderTest.contains(sampleFloatingTaskArray[3]));

        } catch (DuplicateEntryException e) {
            e.printStackTrace();
        }
    }

    @Test(expected = DuplicateEntryException.class)
    public void add_duplicateFloatingTask_throwDuplicateEntryException() throws DuplicateEntryException {
        FloatingTaskList floatingTaskListUnderTest = FloatingTaskListTest.copyFloatingTaskList(floatingTaskList1);
        FloatingTask copiedFloatingTask = (FloatingTask) EntryBuilder.build(floatingTaskListUnderTest.asObservableList()
                                                                                                     .get(0));
        floatingTaskListUnderTest.add(copiedFloatingTask);
    }

    @Test
    public void equals_variousSampleFloatingTasks_success() {
        FloatingTaskList dummyFloatingTaskList = FloatingTaskListTest.copyFloatingTaskList(floatingTaskList2);
        assertTrue(floatingTaskList1.equals(floatingTaskList2));
        assertTrue(floatingTaskList1.equals(dummyFloatingTaskList));

        dummyFloatingTaskList.asObservableList().get(0).setState(Entry.State.ARCHIVED);
        assertFalse(floatingTaskList1.equals(dummyFloatingTaskList));

        assertFalse(floatingTaskList1.equals(floatingTaskList3));
    }

    @Test
    public void remove_removeSampleFloatingTask_success() throws EntryNotFoundException {
        FloatingTaskList floatingTaskListToTest = FloatingTaskListTest.copyFloatingTaskList(floatingTaskList1);

        floatingTaskListToTest.remove(sampleFloatingTaskArray[0]);
        assertTrue(!floatingTaskListToTest.contains(sampleFloatingTaskArray[0]));
        assertTrue(floatingTaskListToTest.asObservableList().get(0).equals(sampleFloatingTaskArray[2]));
    }

    @Test(expected = Exception.class)
    public void remove_nonExistentEntry_returnEntryNotFoundException() throws EntryNotFoundException {
        FloatingTaskList floatingTaskListUnderTest = FloatingTaskListTest.copyFloatingTaskList(floatingTaskList1);

        floatingTaskListUnderTest.remove(sampleFloatingTaskArray[3]);
    }

    @Test
    public void update_updateSampleFloatingTask_success() throws EntryNotFoundException {
        FloatingTaskList floatingTaskListToTest = FloatingTaskListTest.copyFloatingTaskList(floatingTaskList1);
        assertTrue(floatingTaskListToTest.equals(floatingTaskList1));
        assertFalse(floatingTaskListToTest.contains(sampleFloatingTaskArray[3]));
        try {
            floatingTaskListToTest.updateEntry(sampleFloatingTaskArray[0], sampleFloatingTaskArray[3]);

            assertFalse(floatingTaskListToTest.equals(floatingTaskList1));
            assertTrue(floatingTaskListToTest.contains(sampleFloatingTaskArray[3]));

        } catch (DuplicateEntryException e) {
            fail("FloatingTaskListTest.updateEntryTest() failed due to duplicate entry.");
        }
    }

    @Test
    public void setEntriesTest_newFloatingTaskList_equalsMethodReturnsFalse() {
        FloatingTaskList floatingTaskListToTest = FloatingTaskListTest.copyFloatingTaskList(floatingTaskList3);
        assertTrue(floatingTaskListToTest.equals(floatingTaskList3));

        assertTrue(!floatingTaskListToTest.equals(floatingTaskList1));
        floatingTaskListToTest.setEntries(floatingTaskList1);
        assertTrue(floatingTaskListToTest.equals(floatingTaskList1));
    }

    @Test(expected = DuplicateEntryException.class)
    public void duplicatePermission_activeDuplicateFloatingTask_throwsDuplicateEntryException()
            throws DuplicateEntryException {
        FloatingTaskList floatingTaskListUnderTest = FloatingTaskListTest.copyFloatingTaskList(floatingTaskList1);
        assertTrue(floatingTaskListUnderTest.contains(sampleFloatingTaskArray[0]));

        floatingTaskListUnderTest.add(sampleFloatingTaskArray[0]);
        fail("Should not reach this step as a duplicate active floating task is added.");

    }

    @Test
    public void duplicatePermission_nonActiveDuplicateFloatingTask_success() {
        FloatingTaskList floatingTaskListUnderTest = FloatingTaskListTest.copyFloatingTaskList(floatingTaskList1);

        FloatingTask entryToUpdate = (FloatingTask) EntryBuilder.build(sampleFloatingTaskArray[0]);
        FloatingTask editedEntry = (FloatingTask) EntryBuilder.build(sampleFloatingTaskArray[0]);
        editedEntry.setState(Entry.State.DELETED);

        try {
            floatingTaskListUnderTest.updateEntry(entryToUpdate, editedEntry);
        } catch (Exception e) {
            fail("Error in FloatingTaskListTest.shouldAllowDuplicateNonActiveFloatingTask() test method.");
        }
        assertFalse(floatingTaskListUnderTest.contains(sampleFloatingTaskArray[0]));

        try {
            floatingTaskListUnderTest.add(EntryBuilder.build(sampleFloatingTaskArray[0]));
        } catch (DuplicateEntryException e) {
            fail("Faulty EntryList.add() method - disallows duplicate non-active floating tasks.");
        }
        assertTrue(floatingTaskListUnderTest.contains(sampleFloatingTaskArray[0]));
    }

    @Test(expected = DuplicateEntryException.class)
    public void duplicatePermission_sameNameAndDifferent_throwDuplicateEntryException()
            throws IllegalValueException, DuplicateEntryException {
        FloatingTaskList floatingTaskListUnderTest = FloatingTaskListTest.copyFloatingTaskList(floatingTaskList1);
        assertTrue(floatingTaskListUnderTest.contains(sampleFloatingTaskArray[0]));

        Entry floatingTaskWithDifferentTag = EntryBuilder.build(sampleFloatingTaskArray[0].getName());
        assertTrue(floatingTaskWithDifferentTag instanceof FloatingTask);

        floatingTaskListUnderTest.add(floatingTaskWithDifferentTag);
    }
}
```
###### \java\seedu\multitasky\model\entry\FloatingTaskTest.java
``` java
public class FloatingTaskTest {

    private FloatingTask floatingTask1, floatingTask2, floatingTask3, floatingTask4;

    /**
     * Gets an array of 4 sample floatingTasks.
     * The first two floatingTasks are meaningfully equivalent, the remaining are unique.
     * @return FloatingTask[] of 4 sample floatingTasks.
     */
    public static FloatingTask[] getSampleFloatingTaskArray() {

        Calendar calendar1 = Calendar.getInstance();
        calendar1.set(2017, 6, 7, 18, 30); // 7th July 2017, 6:30pm
        Calendar calendar2 = Calendar.getInstance();
        calendar2.set(2017, 6, 8, 18, 30); // 8th July 2017, 6:30pm
        Calendar calendar3 = Calendar.getInstance();
        calendar3.set(2017, 6, 9, 18, 30); // 9th July 2017, 6:30pm

        try {
            return new FloatingTask[] {
                new FloatingTask(new Name("SampleName1"), TagSetBuilder.getTagSet("tag1")),
                new FloatingTask(new Name("SampleName1"), TagSetBuilder.getTagSet("tag1")),
                new FloatingTask(new Name("SampleName2"), TagSetBuilder.getTagSet("tag1")),
                new FloatingTask(new Name("SampleName3"), TagSetBuilder.getTagSet("tag2"))
            };
        } catch (Exception e) {
            fail("FloatingTask array initialisation failed.");
            return null;
        }
    }

    /**
     * Returns list of FloatingTasks of 4 sample elements.
     */
    public static List<FloatingTask> getSampleFloatingTaskList() {
        return Arrays.asList(FloatingTaskTest.getSampleFloatingTaskArray());
    }

    @Before
    public void setUp() {
        FloatingTask[] sampleFloatingTaskArrayData = getSampleFloatingTaskArray();

        floatingTask1 = sampleFloatingTaskArrayData[0];
        floatingTask2 = sampleFloatingTaskArrayData[1];
        floatingTask3 = sampleFloatingTaskArrayData[2];
        floatingTask4 = sampleFloatingTaskArrayData[3];
    }

    @Test
    public void getName_actualAndExpected_success() {
        assertEquals("error at getName()", "SampleName1", floatingTask1.getName().fullName);
    }

    @Test
    public void getTags_actualAndExpected_success() {
        // Same tags
        assertTrue(floatingTask1.getTags().equals(floatingTask2.getTags()));

        // Different tags
        assertFalse(floatingTask1.getTags().equals(floatingTask4.getTags()));
    }

    @Test
    public void resetData_sampleFloatingTaskToReset_success() {
        FloatingTask tester999 = (FloatingTask) EntryBuilder.build(floatingTask1);
        assertFalse(tester999.equals(floatingTask3));

        tester999.resetData(floatingTask3);
        assertTrue(tester999.equals(floatingTask3));
    }

    @Test
    public void getStartAndEndTime_invokeGetterMethods_nulls() {
        assertNull(floatingTask1.getStartDateAndTime());
        assertNull(floatingTask1.getEndDateAndTime());
        assertNull(floatingTask1.getStartDateAndTimeString());
        assertNull(floatingTask1.getEndDateAndTimeString());
    }

    @Test
    public void toString_expectedString_success() {
        assertEquals("FloatingTask formatting is wrong",
                     "SampleName1, Tags: [tag1]",
                     floatingTask1.toString());
    }

    @Test
    public void equals_variousCases_success() {
        // Equal
        assertTrue(floatingTask1.equals(floatingTask2));

        // Not equal
        assertFalse(floatingTask1.equals(floatingTask3));
        assertFalse(floatingTask1.equals(floatingTask4));
    }

}
```
###### \java\seedu\multitasky\model\entry\MiscEntryListTest.java
``` java
public class MiscEntryListTest {

    /**
     * @return MiscEntryList containing samples of active entries
     * @throws DuplicateEntryException
     */
    public static MiscEntryList getSampleMiscActiveEntryList() throws DuplicateEntryException {
        Entry[] activeEventArray = SampleEntries.getSampleActiveEvents();
        Entry[] activeDeadlineArray = SampleEntries.getSampleActiveDeadlines();
        Entry[] activeFloatingTaskArray = SampleEntries.getSampleActiveFloatingTasks();

        MiscEntryList miscEntryList = new MiscEntryList();
        miscEntryList.add(activeEventArray[0]);
        miscEntryList.add(activeDeadlineArray[0]);
        miscEntryList.add(activeFloatingTaskArray[0]);

        return miscEntryList;
    }

    @Test
    public void add_sampleEntries_success() throws DuplicateEntryException {
        Entry[] activeEventArray = SampleEntries.getSampleActiveEvents();
        Entry[] activeDeadlineArray = SampleEntries.getSampleActiveDeadlines();
        Entry[] activeFloatingTaskArray = SampleEntries.getSampleActiveFloatingTasks();

        MiscEntryList miscEntryListUnderTest = MiscEntryListTest.getSampleMiscActiveEntryList();

        assertTrue(miscEntryListUnderTest.contains(activeEventArray[0]));
        assertTrue(miscEntryListUnderTest.contains(activeDeadlineArray[0]));
        assertTrue(miscEntryListUnderTest.contains(activeFloatingTaskArray[0]));
    }

    @Test
    public void setEntries_resetWithSingleFloatingTask_success() throws IllegalValueException {
        MiscEntryList miscEntryListUnderTest = MiscEntryListTest.getSampleMiscActiveEntryList();
        MiscEntryList referenceEntryList = MiscEntryListTest.getSampleMiscActiveEntryList();

        FloatingTask sampleFloatingTask = (FloatingTask) EntryBuilder.build("randomEntry");
        assertTrue(sampleFloatingTask instanceof FloatingTask);
        ArrayList<ReadOnlyEntry> listForReset = new ArrayList<ReadOnlyEntry>();
        listForReset.add(sampleFloatingTask);

        miscEntryListUnderTest.setEntries(listForReset);

        assertTrue(miscEntryListUnderTest.contains(sampleFloatingTask));
        assertFalse(miscEntryListUnderTest.equals(referenceEntryList));
    }
}
```
###### \java\seedu\multitasky\model\entry\NameTest.java
``` java
public class NameTest {

    @Test
    public void isValidName_variousNames_success() {
        // invalid name
        assertFalse(Name.isValidName("")); // empty string
        assertFalse(Name.isValidName(" ")); // spaces only
        assertFalse(Name.isValidName("^")); // only non-alphanumeric characters
        assertFalse(Name.isValidName("/test")); // non-alphanumeric as first character

        // valid name
        assertTrue(Name.isValidName("abc")); // joined alphabets only
        assertTrue(Name.isValidName("peter jack")); // alphabets with space
        assertTrue(Name.isValidName("peter jack ")); // trailing whitespace
        assertTrue(Name.isValidName("12345")); // numbers only
        assertTrue(Name.isValidName("peter the 2nd")); // alphanumeric characters
        assertTrue(Name.isValidName("Capital Tan")); // with capital letters
        assertTrue(Name.isValidName("David Roger Jackson Ray Jr 2nd")); // long names
        assertTrue(Name.isValidName("peter$")); // contains currency sign
        assertTrue(Name.isValidName("peter?.,")); // punctuation marks
        assertTrue(Name.isValidName("peter? . , / * &")); // punctuation marks with space characters
    }

    @Test
    public void equalsTest() {

        // initialize
        try {
            Name name1 = new Name("Jim");
            Name name2 = new Name("Jim");
            Name name3 = new Name("Jane");

            // equality
            assertTrue(name1.equals(name2)); // Meaningfully equal

            // inequality
            assertFalse(name1 == name3);
            assertFalse(name1.equals(name3));

        } catch (Exception e) {
            fail("Invalid name used in test.");
        }
    }
}
```
###### \java\seedu\multitasky\model\EntryBookTest.java
``` java
public class EntryBookTest {

    private EventList[] listOfEventLists = EventListTest.getListOfSampleEventLists();
    private DeadlineList[] listOfDeadlineLists = DeadlineListTest.getListOfSampleDeadlineLists();
    private FloatingTaskList[] listOfFloatingTaskLists = FloatingTaskListTest.getListOfSampleFloatingTaskLists();

    /**
     * @return EntryBook    with sample events, deadlines and floating tasks.
     * @throws DuplicateEntryException
     */
    public static EntryBook getSampleEntryBook() throws DuplicateEntryException {

        EventList[] listOfEventLists = EventListTest.getListOfSampleEventLists();
        DeadlineList[] listOfDeadlineLists = DeadlineListTest.getListOfSampleDeadlineLists();
        FloatingTaskList[] listOfFloatingTaskLists = FloatingTaskListTest.getListOfSampleFloatingTaskLists();

        EntryBook entryBook = new EntryBook();

        for (Entry event : listOfEventLists[0]) {
            assertTrue(event instanceof Event);
            try {
                entryBook.addEntry(event);
            } catch (OverlappingEventException oee) {
                // Do nothing. OverlappingEventException is to be expected here.
            } catch (OverlappingAndOverdueEventException e) {
                // Do nothing. Overlapping and overdue entries are fine.
            } catch (EntryOverdueException e) {
                // Do nothing. Overdue entries are fine.
            }
        }

        for (Entry event : listOfDeadlineLists[0]) {
            assertTrue(event instanceof Deadline);
            try {
                entryBook.addEntry(event);
            } catch (OverlappingEventException oee) {
                // Do nothing. OverlappingEventException is to be expected here.
            } catch (OverlappingAndOverdueEventException e) {
                // Do nothing. Overlapping and overdue entries are fine.
            } catch (EntryOverdueException e) {
                // Do nothing. Overdue entries are fine.
            }
        }

        for (Entry event : listOfFloatingTaskLists[0]) {
            assertTrue(event instanceof FloatingTask);
            try {
                entryBook.addEntry(event);
            } catch (OverlappingEventException oee) {
                // Do nothing. OverlappingEventException is to be expected here.
            } catch (OverlappingAndOverdueEventException e) {
                // Do nothing. Overlapping and overdue entries are fine.
            } catch (EntryOverdueException e) {
                // Do nothing. Overdue entries are fine.
            }
        }

        return entryBook;
    }

    @Test
    public void add_sampleEntryBook_success() {
        try {
            EntryBook entryBookUnderTest = EntryBookTest.getSampleEntryBook();

            List<ReadOnlyEntry> actualEventList = entryBookUnderTest.getEventList();
            List<Entry> eventListExpected = listOfEventLists[0].asObservableList();
            assertTrue(actualEventList.equals(eventListExpected));

            List<ReadOnlyEntry> actualDeadlineList = entryBookUnderTest.getDeadlineList();
            List<Entry> deadlineListExpected = listOfDeadlineLists[0].asObservableList();
            assertTrue(actualDeadlineList.equals(deadlineListExpected));

            List<ReadOnlyEntry> actualFloatingTaksList = entryBookUnderTest.getFloatingTaskList();
            List<Entry> floatingTaskListExpected = listOfFloatingTaskLists[0].asObservableList();
            assertTrue(actualFloatingTaksList.equals(floatingTaskListExpected));

        } catch (DuplicateEntryException e) {
            fail("Error in EntryBookTest.getSampleEntryBook().");
        }
    }

    @Test
    public void remove_entriesInSampleEntryBook_success() throws EntryNotFoundException {
        try {
            EntryBook entryBookUnderTest = EntryBookTest.getSampleEntryBook();

            Entry eventToRemove = listOfEventLists[0].asObservableList().get(0);
            assertTrue(entryBookUnderTest.getAllEntries().contains(eventToRemove));
            Entry deadlineToRemove = listOfDeadlineLists[0].asObservableList().get(0);
            assertTrue(entryBookUnderTest.getAllEntries().contains(deadlineToRemove));
            Entry floatingTaskToRemove = listOfFloatingTaskLists[0].asObservableList().get(0);
            assertTrue(entryBookUnderTest.getAllEntries().contains(floatingTaskToRemove));

            entryBookUnderTest.removeEntry(eventToRemove);
            assertFalse(entryBookUnderTest.getAllEntries().contains(eventToRemove));
            entryBookUnderTest.removeEntry(deadlineToRemove);
            assertFalse(entryBookUnderTest.getAllEntries().contains(deadlineToRemove));
            entryBookUnderTest.removeEntry(floatingTaskToRemove);
            assertFalse(entryBookUnderTest.getAllEntries().contains(floatingTaskToRemove));

            try {
                entryBookUnderTest.removeEntry(eventToRemove);
                fail("Should not reach here.");
            } catch (EntryNotFoundException e) {
                // Do nothing. EntryNotFoundException is to be expected here.
            }

            try {
                entryBookUnderTest.removeEntry(deadlineToRemove);
                fail("Should not reach here.");
            } catch (EntryNotFoundException e) {
                // Do nothing. EntryNotFoundException is to be expected here.
            }

            try {
                entryBookUnderTest.removeEntry(floatingTaskToRemove);
                fail("Should not reach here.");
            } catch (EntryNotFoundException e) {
                // Do nothing. EntryNotFoundException is to be expected here.
            }
        } catch (DuplicateEntryException e) {
            fail("Error in EntryBookTest.getSampleEntryBook().");
        }
    }

    @Test
    public void setAllEntriesList_validSampleEntryBook_success() {
        try {
            EntryBook entryBookToSet = new EntryBook();
            EntryBook expectedEntryBook = EntryBookTest.getSampleEntryBook();
            assertFalse(entryBookToSet.equals(expectedEntryBook));

            entryBookToSet.resetData(expectedEntryBook);
            assertTrue(entryBookToSet.equals(expectedEntryBook));
        } catch (DuplicateEntryException e) {
            e.printStackTrace();
        }
    }

    @Test(expected = NullPointerException.class)
    public void setAllEntries_null_nullPointerExceptionThrown() {
        EntryBook entryBookToSet = new EntryBook();
        EntryBook entryBookUsedForReset = null;
        assertFalse(entryBookToSet.equals(entryBookUsedForReset));

        entryBookToSet.resetData(entryBookUsedForReset);
        fail("Should not reach here. Reset data should fail.");
    }

    @Test
    public void updateEntryTest_validEditedFloatingTask_success() {
        try {
            EntryBook entryBookUnderTest = EntryBookTest.getSampleEntryBook();
            ReadOnlyEntry targetEntryToEdit = entryBookUnderTest.getFloatingTaskList().get(0);

            // Create edited Entry
            Entry editedEntry = EntryBuilder.build(targetEntryToEdit);
            editedEntry.setName(new Name("modifiedName"));

            entryBookUnderTest.updateEntry(targetEntryToEdit, editedEntry);
            assertTrue(editedEntry.equals(targetEntryToEdit));

        } catch (Exception e) {
            fail("Should not result in any exceptions here.");
        }
    }

    @Test(expected = OverlappingAndOverdueEventException.class)
    public void updateEntryTest_validEditedOverlappingAndOverdueEvent_success()
            throws OverlappingAndOverdueEventException {
        try {
            EntryBook entryBookUnderTest;
            entryBookUnderTest = EntryBookTest.getSampleEntryBook();

            ReadOnlyEntry targetEntryToEdit = entryBookUnderTest.getEventList().get(0);

            // Create edited Entry
            Entry editedEntry = EntryBuilder.build(targetEntryToEdit);
            editedEntry.setName(new Name("modifiedName"));
            try {
                entryBookUnderTest.updateEntry(targetEntryToEdit, editedEntry);
            } finally {
                assertTrue(editedEntry.equals(targetEntryToEdit));
            }
        } catch (EntryNotFoundException | EntryOverdueException
                 | IllegalValueException | OverlappingEventException e) {
            e.printStackTrace();
        }
    }

    @Test(expected = EntryOverdueException.class)
    public void updateEntryTest_validEditedOverdueDeadline_success()
            throws EntryOverdueException {
        try {
            EntryBook entryBookUnderTest;
            entryBookUnderTest = EntryBookTest.getSampleEntryBook();

            ReadOnlyEntry targetEntryToEdit = entryBookUnderTest.getDeadlineList().get(0);

            // Create edited Entry
            Entry editedEntry = EntryBuilder.build(targetEntryToEdit);
            editedEntry.setName(new Name("modifiedName"));
            try {
                entryBookUnderTest.updateEntry(targetEntryToEdit, editedEntry);
            } finally {
                assertTrue(editedEntry.equals(targetEntryToEdit));
            }
        } catch (EntryNotFoundException | OverlappingAndOverdueEventException
                 | IllegalValueException | OverlappingEventException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void clearStateSpecificEntriesTest_clearActiveEntries_success() {
        EntryBook entryBookUnderTest = SampleEntries.getSampleEntryBook();
        entryBookUnderTest.clearStateSpecificEntries(Entry.State.ACTIVE);

        boolean activeEntriesPresent = entriesOfSpecificStatePresent(entryBookUnderTest,
                                                                     Entry.State.ACTIVE);
        assertFalse(activeEntriesPresent);
    }

    @Test
    public void clearStateSpecificEntriesTest_clearArchivedEntries_success() {
        EntryBook entryBookUnderTest = SampleEntries.getSampleEntryBook();
        boolean archivedEntriesPresent = entriesOfSpecificStatePresent(entryBookUnderTest,
                                                                       Entry.State.ARCHIVED);
        assertTrue(archivedEntriesPresent);

        entryBookUnderTest.clearStateSpecificEntries(Entry.State.ARCHIVED);

        archivedEntriesPresent = entriesOfSpecificStatePresent(entryBookUnderTest,
                                                               Entry.State.ARCHIVED);
        assertFalse(archivedEntriesPresent);
    }

    @Test
    public void clearStateSpecificEntriesTest_clearDeletedEntries_success() {
        EntryBook entryBookUnderTest = SampleEntries.getSampleEntryBook();
        boolean deletedEntriesPresent = entriesOfSpecificStatePresent(entryBookUnderTest,
                                                                      Entry.State.DELETED);
        assertTrue(deletedEntriesPresent);

        entryBookUnderTest.clearStateSpecificEntries(Entry.State.DELETED);

        deletedEntriesPresent = entriesOfSpecificStatePresent(entryBookUnderTest,
                                                              Entry.State.DELETED);
        assertFalse(deletedEntriesPresent);
    }

    private boolean entriesOfSpecificStatePresent(ReadOnlyEntryBook entryBook, Entry.State targetState) {
        List<ReadOnlyEntry> allEntries = entryBook.getAllEntries();

        switch (targetState) {
        case ACTIVE:
            for (ReadOnlyEntry e : allEntries) {
                if (e.isActive()) {
                    return true;
                }
            }
            break;
        case ARCHIVED:
            for (ReadOnlyEntry e : allEntries) {
                if (e.isArchived()) {
                    return true;
                }
            }
            break;
        case DELETED:
            for (ReadOnlyEntry e : allEntries) {
                if (e.isDeleted()) {
                    return true;
                }
            }
            break;
        default:
            break;
        }
        return false;
    }

    @Test
    public void changeEntryStateTest_changeActiveToDeleted_success() {
        EntryBook entryBookUnderTest = SampleEntries.getSampleEntryBookWithActiveEntries();
        assertFalse(this.entriesOfSpecificStatePresent(entryBookUnderTest, Entry.State.DELETED));

        Entry eventToChange = (Entry) entryBookUnderTest.getEventList().get(0);
        Entry deadlineToChange = (Entry) entryBookUnderTest.getDeadlineList().get(0);

        try {
            entryBookUnderTest.changeEntryState(eventToChange, Entry.State.ARCHIVED);
            assert (this.entriesOfSpecificStatePresent(entryBookUnderTest, Entry.State.ARCHIVED));
            entryBookUnderTest.changeEntryState(deadlineToChange, Entry.State.DELETED);
            assert (this.entriesOfSpecificStatePresent(entryBookUnderTest, Entry.State.DELETED));
        } catch (DuplicateEntryException | EntryNotFoundException | OverlappingEventException
                 | OverlappingAndOverdueEventException | EntryOverdueException e) {
            // These specific set of exceptions an be ignored in this test.
        }
    }

}
```
###### \java\seedu\multitasky\model\tag\TagTest.java
``` java
    @Test
    public void isValidTagName() {
        // invalid tagName
        assertFalse(Tag.isValidTagName("")); // empty string
        assertFalse(Tag.isValidTagName(" ")); // spaces only
        assertFalse(Tag.isValidTagName("^")); // only non-alphanumeric characters
        assertFalse(Tag.isValidTagName("/test")); // non-alphanumeric as first character
        assertFalse(Tag.isValidTagName("cs2103 project")); // alphanumeric with space
        assertFalse(Tag.isValidTagName("abc ")); // trailing whitespace

        // valid tagName
        assertTrue(Tag.isValidTagName("abc")); // joined alphabets only
        assertTrue(Tag.isValidTagName("12345")); // numbers only
        assertTrue(Tag.isValidTagName("cs2103_project")); // underscore
    }

```
###### \java\seedu\multitasky\model\tag\TagTest.java
``` java
    @Test
    public void equalsTest() {

        // initialize
        try {
            Tag tag1 = new Tag("cs2103");
            Tag tag2 = new Tag("cs2103");
            Tag tag3 = new Tag("cs2010");

            // equality
            assertTrue(tag1.equals(tag2)); // Meaningfully equal

            // inequality
            assertFalse(tag1 == tag3);
            assertFalse(tag1.equals(tag3));

        } catch (Exception e) {
            fail("Invalid name used in test.");
        }
    }
}
```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns a delete command string for deleting by an entry's full name.
     */
    public static String getDeleteByFullNameCommand(ReadOnlyEntry entry) {
        return DeleteCommand.COMMAND_WORD + " " + entry.getName().toString();
    }

```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns a delete command string for deleting by an entry's full name.
     */
    public static String getRestoreByFullNameCommand(ReadOnlyEntry entry) {
        return RestoreCommand.COMMAND_WORD + " " + entry.getName().toString();
    }
```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns a restore command string for restoring an event by index.
     */
    public static String getRestoreEventByIndexCommand(Index index) {
        return RestoreCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_EVENT + " " + index.getOneBased();
    }
```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns a restore command string for restoring a deadline by index.
     */
    public static String getRestoreDeadlineByIndexCommand(Index index) {
        return RestoreCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_DEADLINE + " " + index.getOneBased();
    }
```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java

    /**
     * Returns a restore command string for restoring a floating task by index.
     */
    public static String getRestoreFloatingTaskByIndexCommand(Index index) {
        return RestoreCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_FLOATINGTASK + " " + index.getOneBased();
    }
```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns an list command string for listing active entries.
     */
    public static String getListCommand() {
        return ListCommand.COMMAND_WORD;
    }
    // @@ author

```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns an list command string for listing archive.
     */
    public static String getListArchiveCommand() {
        return ListCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_ARCHIVE;
    }
    // @@ author

```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns an list command string for listing bin.
     */
    public static String getListBinCommand() {
        return ListCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_BIN;
    }
    // @@ author

```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns an list command string for listing all entries.
     */
    public static String getListAllCommand() {
        return ListCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_ALL;
    }
    // @@ author

```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns a clear command string for clearing active entries.
     */
    public static String getClearCommand() {
        return ClearCommand.COMMAND_WORD;
    }
    // @@ author

```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns a clear command string for clearing archive.
     */
    public static String getClearArchiveCommand() {
        return ClearCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_ARCHIVE;
    }
    // @@ author

```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns a clear command string for clearing bin.
     */
    public static String getClearBinCommand() {
        return ClearCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_BIN;
    }
    // @@ author

```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns a clear command string for clearing all entries.
     */
    public static String getClearAllCommand() {
        return ClearCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_ALL;
    }
    // @@ author

```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns an complete command string for complete by matching an entry's full name.
     */
    public static String getCompleteByFullNameCommand(Entry entry) {
        return CompleteCommand.COMMAND_WORD + " " + entry.getName().toString();
    }
    // @@ author

```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns an list command string for listing all entries.
     */
    public static String getCompleteEventByIndexCommand(int index) {
        return CompleteCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_EVENT + " " + index;
    }
    // @@ author

```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns an list command string for listing all entries.
     */
    public static String getCompleteDeadlineByIndexCommand(int index) {
        return CompleteCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_DEADLINE + " " + index;
    }
    // @@ author

```
###### \java\seedu\multitasky\testutil\CommandUtil.java
``` java
    /**
     * Returns an list command string for listing all entries.
     */
    public static String getCompleteFloatingTaskByIndexCommand(int index) {
        return CompleteCommand.COMMAND_WORD + " " + CliSyntax.PREFIX_FLOATINGTASK + " " + index;
    }
    // @@ author

}
```
###### \java\seedu\multitasky\testutil\EditEntryDescriptorBuilder.java
``` java
/**
 * A utility class to help with building EditEntryDescriptor objects.
 */
public class EditEntryDescriptorBuilder {

    private EditEntryDescriptor descriptor;

    public EditEntryDescriptorBuilder() {
        descriptor = new EditEntryDescriptor();
    }

    public EditEntryDescriptorBuilder(EditEntryDescriptor descriptor) {
        this.descriptor = new EditEntryDescriptor(descriptor);
    }

```
###### \java\seedu\multitasky\testutil\SampleEntries.java
``` java
    /**
     * @return Entry[] of sample events of mixed states (i.e. active, archived, deleted)
     */
    public static Entry[] getAllEvents() {
        ArrayList<Entry> allEntriesList = new ArrayList<Entry>();

        allEntriesList.addAll(Arrays.asList(SampleEntries.getSampleActiveEvents()));
        allEntriesList.addAll(Arrays.asList(SampleEntries.getSampleArchivedEvents()));
        allEntriesList.addAll(Arrays.asList(SampleEntries.getSampleDeletedEvents()));
        allEntriesList.sort(Comparators.EVENT_DEFAULT);

        return allEntriesList.toArray(new Entry[0]);
    }

    /**
     * @return Entry[] of sample deadlines of mixed states (i.e. active, archived, deleted)
     */
    public static Entry[] getAllDeadlines() {
        ArrayList<Entry> allEntriesList = new ArrayList<Entry>();

        allEntriesList.addAll(Arrays.asList(SampleEntries.getSampleActiveDeadlines()));
        allEntriesList.addAll(Arrays.asList(SampleEntries.getSampleArchivedDeadlines()));
        allEntriesList.addAll(Arrays.asList(SampleEntries.getSampleDeletedDeadlines()));
        allEntriesList.sort(Comparators.DEADLINE_DEFAULT);

        return allEntriesList.toArray(new Entry[0]);
    }

    /**
     * @return Entry[] of sample floating tasks of mixed states (i.e. active, archived, deleted)
     */
    public static Entry[] getAllFloatingTasks() {
        ArrayList<Entry> allEntriesList = new ArrayList<Entry>();

        allEntriesList.addAll(Arrays.asList(SampleEntries.getSampleActiveFloatingTasks()));
        allEntriesList.addAll(Arrays.asList(SampleEntries.getSampleArchivedFloatingTasks()));
        allEntriesList.addAll(Arrays.asList(SampleEntries.getSampleDeletedFloatingTasks()));
        allEntriesList.sort(Comparators.FLOATING_TASK_DEFAULT);

        return allEntriesList.toArray(new Entry[0]);
    }

```
###### \java\seedu\multitasky\testutil\SampleEntries.java
``` java
    public static Entry[] getSampleArchivedEntries() {
        return new Entry[] {
            ASSIGNMENT, QUIZ, EXERCISE
        };
    }

    public static Entry[] getSampleArchivedEvents() {
        return new Entry[] {
            ASSIGNMENT
        };
    }

    public static Entry[] getSampleArchivedDeadlines() {
        return new Entry[] {
            QUIZ
        };
    }

    public static Entry[] getSampleArchivedFloatingTasks() {
        return new Entry[] {
            EXERCISE
        };
    }

    public static Entry[] getSampleDeletedEntries() {
        return new Entry[] {
            GYM, APPOINTMENT, BAKE
        };
    }

    public static Entry[] getSampleDeletedEvents() {
        return new Entry[] {
            GYM
        };
    }

    public static Entry[] getSampleDeletedDeadlines() {
        return new Entry[] {
            APPOINTMENT
        };
    }

    public static Entry[] getSampleDeletedFloatingTasks() {
        return new Entry[] {
            BAKE
        };
    }

    /**
     * Adds sample entries to the provided EntryBook
     */
    public static void loadEntryBookWithSampleActiveEntries(EntryBook entryBook) {
        Objects.requireNonNull(entryBook);
        for (Entry entry : getSampleActiveEntries()) {
            try {
                entryBook.addEntry(EntryBuilder.build(entry));
            } catch (OverlappingEventException oee) {
                // Do nothing. OverlappingEventException is to be expected here.
            } catch (OverlappingAndOverdueEventException e) {
                // Do nothing. Overlapping and overdue entries are fine.
            } catch (EntryOverdueException e) {
                // Do nothing. Overdue entries are fine.
            } catch (DuplicateEntryException e) {
                assert false : "Sample entries cannot have duplicate entries.";
            }
        }
    }

    private static void loadEntryBookWithSampleArchivedEntries(EntryBook entryBook) {
        Objects.requireNonNull(entryBook);
        for (Entry entry : getSampleArchivedEntries()) {
            try {
                entryBook.addEntry(entry);
            } catch (OverlappingEventException oee) {
                // Do nothing. OverlappingEventException is to be expected here.
            } catch (OverlappingAndOverdueEventException e) {
                // Do nothing. Overlapping and overdue entries are fine.
            } catch (EntryOverdueException e) {
                // Do nothing. Overdue entries are fine.
            } catch (DuplicateEntryException e) {
                assert false : "Sample entries cannot have duplicate entries.";
            }
        }
    }

    private static void loadEntryBookWithSampleDeletedEntries(EntryBook entryBook) {
        Objects.requireNonNull(entryBook);
        for (Entry entry : getSampleDeletedEntries()) {
            try {
                entryBook.addEntry(entry);
            } catch (OverlappingEventException oee) {
                // Do nothing. OverlappingEventException is to be expected here.
            } catch (OverlappingAndOverdueEventException e) {
                // Do nothing. Overlapping and overdue entries are fine.
            } catch (EntryOverdueException e) {
                // Do nothing. Overdue entries are fine.
            } catch (DuplicateEntryException e) {
                assert false : "Sample entries cannot have duplicate entries.";
            }
        }
    }

    /**
     * @return an {@code EntryBook} with active sample events, deadlines and floating tasks.
     */
    public static EntryBook getSampleEntryBookWithActiveEntries() {
        EntryBook entryBook = new EntryBook();
        loadEntryBookWithSampleActiveEntries(entryBook);
        return entryBook;
    }

    /**
     * @return  an {@code EntryBook} with sample events, deadlines and floating tasks
     *          of various states (i.e. active, archived, deleted).
     */
    public static EntryBook getSampleEntryBook() {
        EntryBook entryBook = new EntryBook();
        loadEntryBookWithSampleActiveEntries(entryBook);
        loadEntryBookWithSampleArchivedEntries(entryBook);
        loadEntryBookWithSampleDeletedEntries(entryBook);
        return entryBook;
    }

    /**
     * Creates an overlapping event with the given {@code Event} by creating a copy
     * of the given {@code Event} and changing the name.
     * @return {@code Entry}
     */
    public static Entry createOverlappingEvent(Entry entryToOverlapWith) {
        Entry overlappingEventToAdd = EntryBuilder.build(entryToOverlapWith);
        try {
            overlappingEventToAdd.setName(new Name("Overlapping entry dummy name"));
            assertFalse(overlappingEventToAdd.equals(entryToOverlapWith));
        } catch (IllegalValueException e) {
            fail("Should not fail here.");
        }
        return overlappingEventToAdd;
    }

    /**
     * Creates a sample overdue {@code Event}.
     * @return {@code Entry}
     * @throws IllegalValueException
     */
    public static Entry createOverdueEvent() throws IllegalValueException {
        Calendar startDate = Calendar.getInstance();
        startDate.set(Calendar.YEAR, 2013);
        Calendar endDate = Calendar.getInstance();
        endDate.set(Calendar.YEAR, 2014);

        return EntryBuilder.build("D&D", startDate, endDate, "party");
    }

    /**
     * Creates a sample overdue {@code Deadline}.
     * @return {@code Entry}
     * @throws IllegalValueException
     */
    public static Entry createOverdueDeadline() throws IllegalValueException {
        Calendar endDate = Calendar.getInstance();
        endDate.set(Calendar.YEAR, 2014);
        return EntryBuilder.build("dummy overdue entry name", endDate, "deadline");
    }
}
```
###### \java\seedu\multitasky\testutil\TestUtil.java
``` java
    /**
     * @return FloatingTask[] of 10 sample elements.
     */
    private static FloatingTask[] getSampleFloatingTaskArrayData() {
        try {
            return new FloatingTask[] {
                new FloatingTask(new Name("Take lunch to work"), getTagSet()),
                new FloatingTask(new Name("Take dog for walk"), getTagSet()),
                new FloatingTask(new Name("Fill up cat food bowl"), getTagSet()),
                new FloatingTask(new Name("Write novel"), getTagSet()),
                new FloatingTask(new Name("Buy groceries"), getTagSet()),
                new FloatingTask(new Name("Refactor code"), getTagSet()),
                new FloatingTask(new Name("Write two more tasks"), getTagSet()),
                new FloatingTask(new Name("Import test cases"), getTagSet()),
                new FloatingTask(new Name("Scold Travis"), getTagSet()),
                new FloatingTask(new Name("Get dinner"), getTagSet())
            };
        } catch (IllegalValueException e) {
            fail("TestUtil floating task array generation failed.");
            return null;
        }
    }
```
###### \java\seedu\multitasky\testutil\TestUtil.java
``` java
    /**
     * @return List&lt;FloatingTask&gt; of 10 sample elements.
     */
    public static List<FloatingTask> getSampleFloatingTaskListData() {
        return Arrays.asList(SAMPLE_FLOATING_TASK_ARRAY_DATA);
    }

    /**
     * Appends the file name to the sandbox folder path.
     * Creates the sandbox folder if it doesn't exist.
     *
     * @param fileName
     * @return
     */
    public static String getFilePathInSandboxFolder(String fileName) {
        try {
            FileUtil.createDirs(new File(SANDBOX_FOLDER));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return SANDBOX_FOLDER + fileName;
    }

    public static <T> void createDataFileWithData(T data, String filePath) {
        try {
            File saveFileForTesting = new File(filePath);
            FileUtil.createIfMissing(saveFileForTesting);
            XmlUtil.saveDataToFile(saveFileForTesting, data);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Gets mid point of a node relative to the screen.
     *
     * @param node
     * @return
     */
    public static Point2D getScreenMidPoint(Node node) {
        double x = getScreenPos(node).getMinX() + node.getLayoutBounds().getWidth() / 2;
        double y = getScreenPos(node).getMinY() + node.getLayoutBounds().getHeight() / 2;
        return new Point2D(x, y);
    }

    public static Bounds getScreenPos(Node node) {
        return node.localToScreen(node.getBoundsInLocal());
    }

    /**
     * Removes a subset from the list of entries.
     *
     * @param entries The list of entries
     * @param entriesToRemove The subset of entries.
     * @return The modified entries after removal of the subset from entries.
     */
    public static Entry[] removeEntriesFromList(final Entry[] entries, Entry... entriesToRemove) {
        List<Entry> listOfEntries = asList(entries);
        listOfEntries.removeAll(asList(entriesToRemove));
        return listOfEntries.toArray(new Entry[listOfEntries.size()]);
    }

    /**
     * Returns a copy of the list with the entry at specified index removed.
     *
     * @param list original list to copy from
     */
    public static Entry[] removeEntryFromList(final Entry[] list, Index index) {
        return removeEntriesFromList(list, list[index.getZeroBased()]);
    }

    /**
     * Appends entries to the array of entries.
     *
     * @param entries A array of entries.
     * @param entriesToAdd The entries that are to be appended behind the original array.
     * @return The modified array of entries.
     */
    public static Entry[] addEntriesToList(final Entry[] entries, Entry... entriesToAdd) {
        List<Entry> listOfEntries = asList(entries);
        listOfEntries.addAll(asList(entriesToAdd));
        return listOfEntries.toArray(new Entry[listOfEntries.size()]);
    }

    public static Entry[] addEntriesToSortedList(final Entry[] entries, Entry... entriesToAdd) {
        List<Entry> listOfEntries = asList(entries);
        listOfEntries.addAll(asList(entriesToAdd));
        if (entries.length > 0) {
            if (entries[0] instanceof Event) {
                Collections.sort(listOfEntries, Comparators.EVENT_DEFAULT);
            } else if (entries[0] instanceof Deadline) {
                Collections.sort(listOfEntries, Comparators.DEADLINE_DEFAULT);
            } else if (entries[0] instanceof FloatingTask) {
                Collections.sort(listOfEntries, Comparators.FLOATING_TASK_DEFAULT);
            } else {
                throw new AssertionError("Unknown entry array type");
            }
        }
        return listOfEntries.toArray(new Entry[listOfEntries.size()]);
    }

    public static <T> List<T> asList(T[] objs) {
        List<T> list = new ArrayList<>();
        for (T obj : objs) {
            list.add(obj);
        }
        return list;
    }

    public static boolean compareCardAndEntry(EntryCardHandle card, ReadOnlyEntry entry) {
        return card.isSameEntry(entry);
    }

}
```
